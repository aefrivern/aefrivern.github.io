<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>old-driver-zeroの小屋</title>
  <icon>https://old-driver-zero.github.io/icon.png</icon>
  <subtitle>欢迎来到old-driver-zeroの小屋作客</subtitle>
  <link href="https://old-driver-zero.github.io/atom.xml" rel="self"/>
  
  <link href="https://old-driver-zero.github.io/"/>
  <updated>2024-04-27T00:47:49.000Z</updated>
  <id>https://old-driver-zero.github.io/</id>
  
  <author>
    <name>old_driver_zero</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式</title>
    <link href="https://old-driver-zero.github.io/posts/364ea8cc.html"/>
    <id>https://old-driver-zero.github.io/posts/364ea8cc.html</id>
    <published>2024-04-21T06:00:00.000Z</published>
    <updated>2024-04-27T00:47:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>基于 <em>Design Patterns: Elements of Reusable Object-OrientedSoftware</em> 编写</p><h1 id="介绍">介绍</h1><p>设计模式有四大必备元素：</p><ul><li>模式名</li><li>问题：何时应用此模式</li><li>解决方案：应用于不同情况下的模板</li><li>后果：应用该模式的结果与取舍</li></ul><p>多种设计模式可以组合使用，事实上也经常组合使用</p><p>设计模式解决问题的方法：</p><ul><li>找到合适的对象</li><li>确定对象的粒度</li><li>具体说明对象接口</li><li>具体说明对象实现</li><li>类与接口继承</li><li>给接口编程，而不是向实现</li></ul><p>为了让复用机制生效</p><ul><li>继承与组合——倾向于组合</li><li>指派</li><li>继承与参数化类型</li></ul><p>运行时和编译时结构</p><ul><li><strong>aggregation</strong>：一个对象<strong>拥有</strong>另一个对象，即两者有相同的生命周期</li><li><strong>acquaintance</strong>：一个对象仅仅<strong>知道</strong>另一个对象</li></ul><p>为改变而设计：</p><ul><li>通过</li></ul><p>应用程序：</p><ul><li>工具集</li><li>框架</li></ul><h1 id="创建模式">创建模式</h1><h2 id="抽象工厂-abstract-factory">抽象工厂 Abstract Factory</h2><p>目的：在具体说明具体类的情况下创建相关的对象家族</p><p>应用</p><ul><li>一个应该被配置为多种产品家族之一的系统</li><li>一个家族的相关产品被一起使用</li><li>提供一类库的产品</li></ul><p>结构</p><figure><img src="/illustration/设计模式/抽象工厂.webp" alt="抽象工厂" /><figcaption aria-hidden="true">抽象工厂</figcaption></figure><p>参与者</p><ul><li>抽象工厂 - 具体工厂</li><li>抽象产品 - 具体产品</li><li>客户</li></ul><p>协作方式</p><ul><li>运行时具体的工厂类被创建</li><li>抽象工厂将产品的创建延迟到具体工厂子类中</li></ul><p>后果</p><ul><li>隔离了具体的类</li><li>让改变产品家族更容易</li><li>提高了产品之间的一致度</li><li>但是支持新产品种类较难</li></ul><p>实现</p><ul><li>工厂作为单例</li><li>创建产品</li><li>定义扩展工厂</li></ul><p>相关模式：</p><ul><li>抽象工厂类通过用工厂方法实现，也可以使用原型</li><li>具体工厂是通常是一个单例</li></ul><h2 id="建造者-builder">建造者 Builder</h2><p>意图：将复杂对象的构造从表示中分离，使得相同的构造过程可以创建不同的表示</p><p>应用</p><ul><li>创建复杂对象的方法独立于构成对象的部分</li><li>创建过程必须允许不同的构造对象的表示</li></ul><p>结构</p><figure><img src="/illustration/设计模式/建造者.webp" alt="建造者" /><figcaption aria-hidden="true">建造者</figcaption></figure><p>参与者</p><ul><li>建造者 - 具体建造者</li><li>指导者：使用建造者的接口建造对象</li><li>产品</li></ul><p>协作</p><ul><li>客户创建指导者对象并用期望的建造者对象配置</li><li>当有产品的某部分应该构建时，指导者提示建造者</li><li>建造者处理请求并添加部分</li><li>客户从建造者获取产品</li></ul><p>后果</p><ul><li>产品的内部表示可变</li><li>隔离构造和表示</li><li>对构造过程更好的控制</li></ul><p>实现</p><ul><li>装配和构造接口</li><li>建造者默认空方法</li></ul><p>相关模式</p><ul><li>抽象工厂非常类似，但侧重于创建一个家族的产品对象，每一步都会返回产品</li><li>建造者一步一步地创建一个复杂的产品，并在最后返回一整个产品</li></ul><h2 id="工厂方法-factory-method">工厂方法 Factory Method</h2><p>意图：定义创建对象的接口，但是让子类决定实例化哪个类，即将实例化延迟到子类</p><p>应用</p><ul><li>一个类不参与它即将创建的对象类</li><li>一个需要它的子类类具体说明创建的对象</li></ul><figure><img src="/illustration/设计模式/工厂方法.webp" alt="工厂方法" /><figcaption aria-hidden="true">工厂方法</figcaption></figure><p>协作：创造者依赖于子类定义工厂方法，返回一个合适的具体产品的实例</p><p>后果</p><ul><li>给子类提供了 hook</li><li>连接平行的类层次结构</li></ul><p>实现</p><ul><li>两个主要变式</li><li>参数化工厂方法</li><li>使用模板来避免子类</li><li>命名惯例</li></ul><p>相关模式</p><ul><li>抽象工厂通常用工厂方法实现</li><li>工厂方法在模板方法中被调用</li><li>原型不需要子类创造者</li></ul><h2 id="原型-prototype">原型 Prototype</h2><p>意图：使用原型实例具体说明对象的类型，通过复制原型来创建对象</p><p>应用</p><ul><li>运行时指明要实例化的对象</li><li>避免构造和类产品层次结构平行的工厂</li><li>产品的实例只有几种不同的状态组合</li></ul><figure><img src="/illustration/设计模式/原型.webp" alt="原型" /><figcaption aria-hidden="true">原型</figcaption></figure><p>协作：客户要求一个原型复制自己</p><p>后果</p><ul><li>运行时添加和移除产品</li><li>通过变化值指定新对象</li><li>减少子类</li><li>动态配置应用</li></ul><p>实现</p><ul><li>使用原型管理器</li><li>实现 Clone 操作</li><li>初始化克隆体</li></ul><p>相关模式：原型和抽象工厂是竞争的，但也可以一起使用</p><h2 id="单例-singleton">单例 Singleton</h2><p>意图：确保一个类只有一个实例，提供一个全局点访问它</p><p>应用：只能有一个类，并必须通过一个众所周知的访问点访问</p><figure><img src="/illustration/设计模式/单例.webp" alt="单例" /><figcaption aria-hidden="true">单例</figcaption></figure><p>协作：客户仅通过单例的 Instance 操作访问单例实例</p><p>后果</p><ul><li>控制对单独实例的访问</li><li>减少命名空间</li><li>灵活</li></ul><p>实现</p><ul><li>确保唯一实例</li><li>单例类的子类</li></ul><p>相关模式：前面的几个都可以使用单例模式实现</p><h1 id="结构模式">结构模式</h1><h2 id="适配器-adapter">适配器 Adapter</h2><p>意图：将一个类的接口转化为客户需要的接口</p><p>应用</p><ul><li>想要使用现存的类，但接口不匹配</li><li>想要一个可以和其他无关或未预见到的类协同的类</li></ul><figure><img src="/illustration/设计模式/适配器.webp" alt="适配器" /><figcaption aria-hidden="true">适配器</figcaption></figure><p>后果：</p><p>类适配器</p><ul><li>通过一个具体适配器类适配</li><li>只引入一个对象</li></ul><p>对象适配器</p><ul><li>让一个适配器和多个被适配者工作</li><li>难以重载被适配者的行为</li></ul><p>实现</p><ul><li>从目标 public 继承而从被适配者 private 继承</li><li>可插拔适配器<ul><li>抽象操作</li><li>指派对象</li><li>参数化适配器</li></ul></li></ul><p>相关模式</p><ul><li>与桥类似，但是桥是为了分离接口与实现，而适配器是为了改变<strong>现存</strong>的对象的接口</li><li>修饰器不改变接口</li><li>代理则充当代理人的角色</li></ul><h2 id="桥-bridge">桥 Bridge</h2><p>意图：将抽象从实现中解耦合</p><p>应用</p><ul><li>避免抽象和实现的绑定</li><li>改变实现对客户没有影响</li><li>完全隐藏抽象的实现</li></ul><figure><img src="/illustration/设计模式/桥.webp" alt="桥" /><figcaption aria-hidden="true">桥</figcaption></figure><p>协作：抽象将客户请求转发给实现对象</p><p>后果</p><ul><li>解耦合接口和实现</li><li>增强扩展性</li><li>对客户隐藏实现细节</li></ul><p>实现</p><ul><li>只有一个实现者时也可以使用</li><li>创建正确的实现对象</li><li>共享实现者</li></ul><p>相关模式</p><ul><li>抽象工厂可以创建并配置一个特定的桥</li><li>适配器通常是马后炮，而桥则出现在设计之前</li></ul><h2 id="组合-composite">组合 Composite</h2><p>意图：将对象组合为树形结构来表示部分-整体层次结构。可以一致地处理单独的对象和对象的组合</p><p>应用</p><ul><li>想要表示部分-整体的对象层次结构</li><li>想要忽略单独的对象和对象的组合的区别</li></ul><figure><img src="/illustration/设计模式/组合.webp" alt="组合" /><figcaption aria-hidden="true">组合</figcaption></figure><figure><img src="/illustration/设计模式/组合对象.webp" alt="组合对象" /><figcaption aria-hidden="true">组合对象</figcaption></figure><p>协作：客户使用组合类接口与对象交互。如果接受者是叶，则直接处理请求；如果是组合，则转发请求到子组件</p><p>后果</p><ul><li>由原始对象和组合对象定义了类的层次结构</li><li>使客户端更简单</li><li>添加新组件更容易</li><li>使设计过于一般</li></ul><p>实现</p><ul><li>显式父引用</li><li>共享组件</li><li>最小化组件接口</li><li>声明子组件操作</li></ul><p>相关模式</p><ul><li>组件-父亲链接通常用于责任链</li><li>修饰器通常和组合一起使用</li><li>享元可以共享组件，但是不能够引用父亲</li><li>迭代器可以用于遍历组合</li></ul><h2 id="修饰器-decorator">修饰器 Decorator</h2><p>意图：动态给一个对象附加责任。相比子类，修饰器扩展功能更灵活</p><p>应用</p><ul><li>动态、透明地给个别对象添加责任</li></ul><figure><img src="/illustration/设计模式/修饰器.webp" alt="修饰器" /><figcaption aria-hidden="true">修饰器</figcaption></figure><p>协作：将请求转发给组件对象，可能在请求前后添加操作</p><p>后果</p><ul><li>比静态的继承更灵活</li><li>避免了继承中的功能负担</li><li>修饰器和组件不相同</li><li>很多小对象</li></ul><p>实现</p><ul><li>接口一致</li><li>忽略抽象修饰器类</li><li>保持组件类轻量</li><li>换皮 vs 换本</li></ul><p>相关模式</p><ul><li>适配器：改变了接口</li><li>相当于只有一个对象的组合</li><li>策略改变了本质，修饰器改变了表面</li></ul><h2 id="外观-facade">外观 Facade</h2><p>意图：提供子系统中的接口集合的统一接口</p><p>应用</p><ul><li>想要给一个复杂的系统提供一个简单的接口</li><li>客户和抽象的实现类有很多依赖</li><li>给系统分层</li></ul><figure><img src="/illustration/设计模式/外观.webp" alt="外观" /><figcaption aria-hidden="true">外观</figcaption></figure><p>协作：客户端不能直接访问子系统对象，只能通过给外观发送请求来与子系统通信</p><p>后果</p><ul><li>对客户隐藏了子系统组件</li><li>提高了子系统和客户的弱耦合</li></ul><p>实现</p><ul><li>减少客户-子系统的耦合</li><li>公共 vs 私有子系统类：子系统封装了类，类封装了状态和操作</li></ul><p>相关模式</p><ul><li>抽象工厂可以和外观一起使用来提供创建子系统对象</li><li>中介者与外观类似，但目的是抽象同事之间的通信</li><li>外观对象通常是单例的</li></ul><h2 id="享元-flyweight">享元 Flyweight</h2><p>意图：使用共享来高效支持大量细粒度的对象</p><p>应用</p><ul><li>需要大量对象</li><li>存储花费高</li><li>大量对象状态可以放到外部</li><li>一旦外部状态被移除，许多对象组可以被较少的共享对象替代</li><li>应用不依赖于对象实体</li></ul><figure><img src="/illustration/设计模式/享元.webp" alt="享元" /><figcaption aria-hidden="true">享元</figcaption></figure><figure><img src="/illustration/设计模式/共享享元.webp" alt="共享享元" /><figcaption aria-hidden="true">共享享元</figcaption></figure><p>协作</p><ul><li>享元内部的状态存在具体享元对象中，外部状态存储或由客户对象计算，客户在使用享元的操作时可以将这状态传递给享元</li><li>客户不应该直接实例化具体享元</li></ul><p>后果：增加了运行时间，但减少了空间</p><p>实现</p><ul><li>移除外部状态</li><li>管理共享对象</li></ul><p>相关模式</p><ul><li>和组合一起来创建一个有向无环图</li><li>最好将状态和策略对象实现为享元</li></ul><h2 id="代理-proxy">代理 Proxy</h2><p>意图：通过控制对象访问的代理人</p><p>应用</p><ul><li><strong>远程代理</strong>提供不同地址空间的对象的本地表示</li><li><strong>虚拟代理</strong>按需创造昂贵的对象</li><li><strong>保护代理</strong>控制对原始对象的访问</li><li><strong>智能引用</strong>是对普通指针的替代</li></ul><figure><img src="/illustration/设计模式/代理.webp" alt="代理" /><figcaption aria-hidden="true">代理</figcaption></figure><figure><img src="/illustration/设计模式/运行时代理.webp" alt="运行时代理" /><figcaption aria-hidden="true">运行时代理</figcaption></figure><p>后果</p><ul><li>远程代理可以隐藏对象在一个不同地址空间的事实</li><li>虚拟代理可以按需创建对象来执行优化</li><li>保护代理和智能引用运行额外的内务任务</li></ul><p>实现</p><ul><li>重载 <code>-&gt;</code></li><li>并不总是知道实际对象的类型</li></ul><p>相关模式</p><ul><li>适配器提供的是不同的接口</li><li>代理控制对一个对象的访问，而修饰器添加对象的职责</li></ul><h1 id="表现模式">表现模式</h1><h2 id="责任链-chain-of-responsibility">责任链 Chain ofResponsibility</h2><p>意图：通过给予多个对象处理请求的机会来避免将请求的发送者耦合到接收者。</p><p>应用：</p><ul><li>多个对象可能处理请求</li><li>不显示指明接收者来对多个对象中的一个发送请求</li><li>处理请求的对象集合应该动态指明</li></ul><figure><img src="/illustration/设计模式/责任链.webp" alt="责任链" /><figcaption aria-hidden="true">责任链</figcaption></figure><figure><img src="/illustration/设计模式/责任链对象结构.webp"alt="责任链对象结构" /><figcaption aria-hidden="true">责任链对象结构</figcaption></figure><p>协作：当客户发起请求，请求通过链传导直到一个具体的处理者处理它</p><p>后果</p><ul><li>减少耦合</li><li>添加给对象分配责任的灵活性</li><li>收据不保证</li></ul><p>实现</p><ul><li>实现继承链<ul><li>定义新链</li><li>使用现成链</li></ul></li><li>连接继承者</li><li>表示请求</li></ul><p>相关模式：通常和组合一起使用，即一个组件的父亲可以是其继承者</p><h2 id="命令-command">命令 Command</h2><p>意图：将请求封装为对象，使得能够用不同请求来参数化客户</p><p>应用</p><ul><li>通过执行的动作来初始化对象</li><li>支持撤销</li><li>基于原始操作构建高级操作系统</li></ul><figure><img src="/illustration/设计模式/命令.webp" alt="命令" /><figcaption aria-hidden="true">命令</figcaption></figure><p>协作</p><ul><li>客户创建具体命令对象并指明接收者</li><li>调用者对象存储具体命令对象</li><li>调用者通过调用对命令调用 Execute 来发起请求</li><li>具体命令对象调用它的接收者的操作来处理请求</li></ul><figure><img src="/illustration/设计模式/命令协作.webp" alt="命令协作" /><figcaption aria-hidden="true">命令协作</figcaption></figure><p>后果</p><ul><li>从直到如果执行命令的一些处解耦合了操作</li><li>命令是第一类对象</li><li>可以将命令组装为一个组合命令</li><li>添加新命令很容易</li></ul><p>实现</p><ul><li>命令应该多智能</li><li>支持撤销和重做</li><li>避免撤销过程中的错误积累</li><li>使用 C++ 模板</li></ul><p>相关模式</p><ul><li>组合可以用于实现大型命令</li><li>备忘录可以保持需要撤销影响的命令的状态</li><li>在放到历史列表中必须复制的命令作为一个原型</li></ul><h2 id="解释器-interpreter">解释器 Interpreter</h2><p>意图：给定语言，用一个解释器为其语法定义表示</p><p>应用</p><ul><li>语法简单</li><li>效率不是关键点</li></ul><figure><img src="/illustration/设计模式/解释器.webp" alt="解释器" /><figcaption aria-hidden="true">解释器</figcaption></figure><p>协作</p><ul><li>客户用抽象语法树建立句子</li><li>每个非终止结点解释</li></ul><p>后果</p><ul><li>容易改变和扩展语法</li><li>实现语法很容易</li><li>复杂的语法很难维护</li><li>添加新的解释表达式的方法</li></ul><p>实现</p><ul><li>创建抽象语法树</li><li>定义解释操作</li><li>用享元共享终止符</li></ul><p>相关模式</p><ul><li>抽象语法树是组合模式的一个实例</li><li>终止符是享元</li><li>使用迭代器来遍历结构</li></ul><h2 id="迭代器-iterator">迭代器 Iterator</h2><p>意图：在不暴露底层表示的情况下提供顺序访问聚合对象的方法</p><p>应用</p><ul><li>不暴露内部表示的情况下访问聚合对象内容</li><li>提供多重遍历聚合对象的方法</li><li>提供遍历不同聚合结构的一致接口</li></ul><figure><img src="/illustration/设计模式/迭代器.webp" alt="迭代器" /><figcaption aria-hidden="true">迭代器</figcaption></figure><p>协作：具体迭代器跟踪聚合中的当前对象并计算遍历中的下一个对象</p><p>后果</p><ul><li>支持聚合的遍历过程中更改</li><li>简化聚合接口</li><li>多种遍历方式</li></ul><p>实现</p><ul><li>谁控制迭代<ul><li>外部迭代器</li><li>内部迭代器</li></ul></li><li>迭代器是否健壮，即是否支持在遍历过程中添加或删除对象</li></ul><p>相关模式</p><ul><li>通常应用于递归结构，如组合</li><li>依赖于工厂方法来实例化迭代器子类</li><li>使用备忘录捕捉迭代状态</li></ul><h2 id="中介者-mediator">中介者 Mediator</h2><p>意图：定义一个封装了一个集合的对象交互方法的对象，通过防止对象直接与彼此交互</p><p>应用</p><ul><li>集合的对象通信复杂</li><li>因为引用到和通信了太多对象而复用对象困难</li></ul><figure><img src="/illustration/设计模式/中介者.webp" alt="中介者" /><figcaption aria-hidden="true">中介者</figcaption></figure><figure><img src="/illustration/设计模式/中介者对象结构.webp"alt="中介者对象结构" /><figcaption aria-hidden="true">中介者对象结构</figcaption></figure><p>协作：同事通过中介者对象发送和接收请求</p><p>后果</p><ul><li>限制子类</li><li>解耦合同事</li><li>简化对象协议</li><li>抽象对象协作</li><li>中心化控制</li></ul><p>实现</p><ul><li>忽略抽象中介者类</li><li>同事-中介者通信</li></ul><p>相关模式：外观抽象了子系统的对象来提供一个更方便的接口，是单向的；而中介者方便了同事对象的协作表现，是双向的</p><h2 id="备忘录-memento">备忘录 Memento</h2><p>意图：在不违反封装的前提下，捕获并外部化对象的内部状态，使得对象可以在一会儿恢复状态</p><p>应用</p><ul><li>一个对象的状态必须保存以恢复状态</li><li>获取状态的直接接口会暴露实现细节</li></ul><figure><img src="/illustration/设计模式/备忘录.webp" alt="备忘录" /><figcaption aria-hidden="true">备忘录</figcaption></figure><p>协作</p><ul><li>保管者从发起人请求一个备忘录，保存一段时间，然后将其交还给发起人</li></ul><figure><img src="/illustration/设计模式/备忘录协作.webp" alt="备忘录协作" /><figcaption aria-hidden="true">备忘录协作</figcaption></figure><ul><li>备忘录是被动的，只有创建一份备忘录的发起人可以赋值或获取状态</li></ul><p>后果</p><ul><li>保持封装边界</li><li>简化发起人</li><li>使用备忘录可能昂贵</li><li>保管备忘录的代价</li></ul><p>实现</p><ul><li>狭窄的公共接口：将 <code>Originator</code> 设为友元，其余内容全为private</li><li>存储增量改变</li></ul><p>相关模式</p><ul><li>命令可以使用备忘录来撤销操作</li><li>迭代器</li></ul><h2 id="观察者-observer">观察者 Observer</h2><p>意图：定义对象之间一对多的依赖，使得当一个对象改变状态时，所有的依赖都被通知并自动更新</p><p>应用</p><ul><li>一个依赖于另一个</li><li>一个改变，其余的也会改变，但不知道多少对象需要改变</li><li>需要通知其他对象，但不知道是什么</li></ul><figure><img src="/illustration/设计模式/观察者.webp" alt="观察者" /><figcaption aria-hidden="true">观察者</figcaption></figure><p>协作</p><ul><li>当改变发生时，具体主体通知观察者</li><li>具体观察者可能向主体询问信息</li></ul><figure><img src="/illustration/设计模式/观察者协作.webp" alt="观察者协作" /><figcaption aria-hidden="true">观察者协作</figcaption></figure><p>后果</p><ul><li>抽象主体和观察者之间的耦合</li><li>支持广播通信</li></ul><p>实现</p><ul><li>将主体映射到观察者</li><li>观察超过一个对象</li><li>谁发送更新<ul><li>当状态改变时，主体自动发送通知</li><li>客户手动通知</li></ul></li><li>悬垂指针</li><li>确保主体状态在通知之前是自我一致的</li><li>避免观察者指明的更新协议：推送和拉取模型</li><li>使用改变管理器封装复杂的更新语法</li></ul><p>相关模式</p><ul><li>改变管理器充当主体和观察者的中介者</li><li>改变管理器使用单例</li></ul><h2 id="状态-state">状态 State</h2><p>意图：允许内部状态改变后，对象改变其行为，即改变了它的类</p><p>应用</p><ul><li>对象的行为依赖于状态，必须在运行时改变行为</li><li>操作有依赖于状态的大型，多部分的条件语句</li></ul><figure><img src="/illustration/设计模式/状态.webp" alt="状态" /><figcaption aria-hidden="true">状态</figcaption></figure><p>协作</p><ul><li>上下文指派特殊状态的请求给当前具体状态对象</li><li>上下文可以传递自己为参数</li><li>上下文和具体状态子类都可以决定下一个状态是什么</li></ul><p>后果</p><ul><li>局部化状态特定的行为并划分为不同状态</li><li>使状态转移显式</li><li>状态对象可以共享</li></ul><p>实现</p><ul><li>谁定义状态转移</li><li>基于表的替代</li><li>创建并销毁状态对象</li><li>使用动态继承</li></ul><p>相关模式</p><ul><li>享元解释状态共享的问题</li><li>状态对象通常是单例</li></ul><h2 id="策略-strategy">策略 Strategy</h2><p>意图：定义算法家族，封装每一个，使其可以交换</p><p>应用</p><ul><li>许多相关的类只在表现不同</li><li>需要一个算法的不同变式</li><li>使用客户不应该知道的数据的算法</li><li>类定义了许多表现，出现其操作的多重条件语句中</li></ul><figure><img src="/illustration/设计模式/策略.webp" alt="策略" /><figcaption aria-hidden="true">策略</figcaption></figure><p>协作</p><ul><li>处理和上下文交互以实现选中的算法</li><li>上下文从其客户转发请求到策略</li></ul><p>后果</p><ul><li>相关的算法家族</li><li>子类的替代</li><li>策略减少条件语句</li><li>实现的选择</li><li>客户必须了解不同的策略</li><li>策略和上下文之间通信的开销</li><li>增加对象数量</li></ul><p>实现</p><ul><li>定义策略和上下文接口</li><li>策略作为模板参数</li></ul><p>相关模式：策略对象通常是好的享元</p><h2 id="模板方法-template-method">模板方法 Template Method</h2><p>意图：在操作中定义算法的骨架，将一些步骤延迟到子类，即让子类在不改变算法结构的前提下重新定义了算法的特定步骤</p><p>应用</p><ul><li>实现算法中不变的部分，让子类实现会变的部分</li><li>子类中共同的表现重构以避免代码重复</li><li>控制子类扩展</li></ul><figure><img src="/illustration/设计模式/模板方法.webp" alt="模板方法" /><figcaption aria-hidden="true">模板方法</figcaption></figure><p>协作：具体类依赖于抽象类实现算法中不变的部分</p><p>实现</p><ul><li>最小化原始操作</li><li>命名惯例：<code>Do-</code></li></ul><p>相关模式：</p><ul><li>工厂模式通常被模板方法调用</li><li>模板方法使用继承来改变算法的部分，策略使用指派来改变整个算法</li></ul><h2 id="访问者-visitor">访问者 Visitor</h2><p>意图：表示对一个对象结构中的元素的执行的操作。可以在不改变操作的元素的类的情况下定义新的操作</p><p>应用</p><ul><li>拥有不同接口的需要类的对象的结构，想要基于具体的类执行操作</li><li>在一个对象结构中有许多不同且无关的操作需要执行，但不想要用这些操作污染类</li><li>定义对象结构的类很少改变，但在此之上经常定义新操作</li></ul><figure><img src="/illustration/设计模式/访问者.webp" alt="访问者" /><figcaption aria-hidden="true">访问者</figcaption></figure><p>协作</p><ul><li>客户创建一个具体访问者对象并遍历对象结构，使用访问者访问每个元素</li><li>当每个元素被访问时，调用相关类的访问者操作</li></ul><figure><img src="/illustration/设计模式/访问者协作.webp" alt="访问者协作" /><figcaption aria-hidden="true">访问者协作</figcaption></figure><p>后果</p><ul><li>添加新操作容易</li><li>收集相关的操作并分离无关的操作</li><li>添加新具体元素类很困难</li><li>积累状态</li></ul><p>相关模式</p><ul><li>常应用于组合</li><li>可以用于解释器</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;基于 &lt;em&gt;Design Patterns: Elements of
        
      
    
    </summary>
    
    
      <category term="工具" scheme="https://old-driver-zero.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="面向对象编程" scheme="https://old-driver-zero.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    
      <category term="软件开发" scheme="https://old-driver-zero.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>植物大战僵尸</title>
    <link href="https://old-driver-zero.github.io/posts/67bd69da.html"/>
    <id>https://old-driver-zero.github.io/posts/67bd69da.html</id>
    <published>2024-04-21T00:34:31.000Z</published>
    <updated>2024-04-21T01:37:52.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div id="aplayer-oSEOhviA"class="aplayer aplayer-tag-marker meting-tag-marker" data-id="3019706"data-server="netease" data-type="song" data-mode="random"data-autoplay="false" data-listmaxheight="340px" data-preload="auto"data-theme="#e3f2f5" data-volume="0.4" data-mutex="true"></div><div class="hide-block"><button type="button" class="hide-button" style="background-color: green;">逆天评论    </button><div class="hide-content"><ul><li>150可以买<strong>双子向日葵</strong>，而<strong>火树</strong>只要175，我的意思是，虽然可以玩姐妹花，但我宁愿多花点钱也要玩个烧的</li><li>只要在<strong>寒冰射手</strong>前面放两根<strong>火炬树桩</strong>，就会变成火焰豌豆。我的意思是不管外表多高冷，两根就受不了</li><li>一般的植物都可以放在南瓜里保护起来，但是<strong>玉米加农炮</strong>不行，所以只要够大就可以不带</li><li><strong>大喷菇</strong>升级成春哥以后能喷三路，我的意思是有钱哪个位置都能玩</li><li>虽然开局50阳光可以下向日葵，但是我选择25阳光的<strong>阳光菇</strong>等他长大，花一半的钱从小玩到大</li><li><strong>大嘴花</strong>一口就能把僵尸吃掉，而豌豆射手却需要很久才能杀掉僵尸，我的意思是，口一下就能解决的事没必要那么麻烦</li><li>蘑菇在白天不能发挥作用，但是使用<strong>咖啡豆</strong>就可以，我的意思是实在不行下点药也能玩</li><li><strong>南瓜罩</strong>可以保护大部分植物的安全，但<strong>毁灭蘑菇</strong>依然会炸出一个坑。我是说足够大足够强，套了也没用。</li><li><strong>冰西瓜投手</strong>很贵，但是伤害高又很冷，我的意思是，只要你有钱，再高冷的都能拿下</li><li>在你犯错时为你兜底，在你成功时给你奖励。——<strong>小推车</strong></li><li><strong>仙人掌</strong>要125阳光，只能发出一排尖刺，而<strong>猫尾草</strong>225阳光却可以全图追踪.我的意思是：多给一点，她会更灵活</li><li>我的意思是，前后夹击不如朝一个方向用力耕耘——<strong>双向射手</strong></li><li>配火炬正面僵尸永远打不进来，矿工绕后可以轻松破掉，这告诉我们前面的撬不开也可以从后面突破。——<strong>机枪射手</strong></li><li>只要僵尸在<strong>地刺</strong>上活动的时间足够久，僵尸就会上天堂。我的意思是，只要你上来自己动，你也能上天堂</li><li>铁桶僵尸固然强大，但只要<strong>磁力菇</strong>吸走铁桶后就不堪一击了，我的意思是，只要对面够能吸，再强大也受不了</li></ul></div></div><h1 id="最经典的游戏">最经典的游戏</h1><p>从现在的角度来看，植物大战僵尸的设计是天花板级别了。出色的引导让你甚至能在看不到英文的情况下依旧快乐地游玩，灵活的搭配让人能在无尽模式乐此不疲，还有恰到好处的音乐——尤其是打僵王博士的那段，非常带感。</p><p>植物大战僵尸有很多改版，我小时候也非常喜欢植物大战僵尸，玩过很多不同的版本，但没有一个能够接近原版的水平。同时，关于无尽版本的阵形也多有研究。这么多年过去了，经典的八炮阵经受了时间的考验，直到现在仍在发光发亮。</p><p>不过，前段时间的“胆小菇之梦”确实是让我眼前一亮</p><p>植物大战僵尸也有非常多的梗，如控大喷菇，1437大帝等，直到现在还挺火</p><p>从早期的植物，到现在的植物娘，再到一些“碰都不能碰的话题”，植物大战僵尸从一代到三代，而我们也长大了</p><h1 id="我们是僵尸">我们是僵尸</h1><p>【普通僵尸】我知道我将永远吃不到脑子，却总是饿着肚子前仆后继的冲在最前面，我不也奢求什么，只希望我的死亡能使同伴们多一点希望</p><p>【僵尸旗手】晃悠悠的拿着红旗，我注定也只能是炮灰看着自己的身体慢慢的瓦解。但我从来不肯后退一步，我做僵尸的这一生，最大的愿望便是将这面旗帜插在我们最想去的地方。明明知道不可能，却仍旧拼了命的想去实现</p><p>【路障僵尸】我知道我看起来很搞笑，拖着残缺的脚艰难的向那一片片的死亡区靠拢。当我的路障头被打掉的时候，我伸出手想去触摸那遥不可及的希望。然后，支离破碎</p><p>【撑杆跳僵尸】我永远拿着我的撑杆，永远跑的比别人快，却总是不能为我的同伴争取到一丝的时间。我忍着眼泪继续往前冲去，无法回头，也不能回头，也许你认为我很残忍，但看着同伴一个一个的死掉，这才是真正的残忍</p><p>【铁桶僵尸】我生下来就带着一个铁桶，它很重，我永远都不可能将它摘下，因为这是宿命。我偷偷的告诉你，其实豌豆打在铁桶上的声音真的让人晕头转向，但我必须挪着沉重的脚步，一步步的走向灭亡</p><p>【看报僵尸】我总是一副文质彬彬的模样，甚至在进攻时还是沉浸在我的世界，而他们将我的最爱毁去，我彻底的失去了生活着的唯一希望。我红着眼睛冲在前方，最终还是不甘的倒在地上。为什么？要残忍的剥夺我最后的希望</p><p>【纱窗门僵尸】这个东西很咯手，很冷，也很沉重。举着它，我茫然地走着，脑袋空白无法思考。就这样走着，走着，突然有什么东西掉了下来，哦，是我的手，看着面前那一阵阵的烟雾，恍惚间就是面对着自己的内心世界，空荡荡</p><p>【橄榄球僵尸】我努力啃食的原因只有一个希望用自己的身体去帮助同伴们通过。坚果墙很硬很难吃，当它消失的时候，我会得意洋洋的冲我的同伴们咧起一个傻兮兮地微笑，甚至忘记了面前的危险。于是，我轰然落地。望着天空，嘿，我的同伴们，你们冲过去了吗？我有点累呢，让我休息一下好吗？就稍微休息一下.你知道的，我从来不骗人的</p><p>【蹦极僵尸】长长的绳子系在我的腰间，落下时，你们会听见小丑一般发出尖锐至极的笑声，很难听吧？可是你们知道吗？这不是我的笑声，因为僵尸是没有眼泪的，恐惧到极致的时候，连哭声都会扭曲成笑声。一次一次的落下，一次又一次的被弹开，我的命运就是被这一根根的绳子牢牢地固定住，最终消失在一片尖锐的嘲笑声中</p><p>【潜水僵尸】我讨厌水，更讨厌水溅到身上的感觉。可是为了我的伙伴，我不得不下水，或许你们看到我从水中冒出来的样子很滑稽头上有时候会带着几根水草。但你们也永远想象不到，在水中的时候，我是多么的恐惧与痛苦</p><p>【矿工僵尸】我是所有僵尸中最贴近门口的那个，而我从没有一次跨进去。因为我知道不是每个僵尸都能像我一般，于是我不舍的看了一眼近在咫尺的成功，选择了这条不归路</p><p>【海豚骑士】我有一只海豚，他一直陪着我。他陪我冲锋，陪我前进。我的力量是他给的，我的信心是他给的，我的勇气是他给的。因为他，我不害怕死亡。我知道，即便是死，他也会陪着我</p><p>【气球僵尸】从小我就有个梦想，我想飞。我试过翅膀，每次试飞，都摔出眼泪。不是我怕疼，眼泪它不听话，它自做主张。后来，我把自己系到气球上，随风逝去</p><p>【雪撬小队】我们是一个团体，我把自己教给队友。我为队友挡子弹，队友为我挡子弹。队友倒下了，我不停留。因为，我一定会去陪他</p><p>【伽偻僵尸】我是僵尸中最强壮的，他是僵尸中最弱小的。我们是朋友。他说，他很饿。他说，他想吃肉。他说，大个子，我很喜欢你，如果我是女的，一定嫁给你。我用自己强壮的身体开路，把他送到门口。我知道，只要我上战场，一定活不下来，所有火力会在瞬间对准我。博士说，你跟在我后面。我真的很怕死，真的很怕</p><p>【小鬼僵尸】我长的小，所以经常被人欺负。我喜欢冒险，但身体单薄。我从来没有吃过肉，也从来没有吃过植物。我好饿。我的世界，只有白底，黑点闪烁。直到大个子说，你是我的朋友，你是我的伙伴。我会为你挡风雨，再不会有人欺负你。再没有人欺负我，再没有。大个子，在你把我扔出去那一刻，我就知道，有去无回。</p><p>【僵尸雪人】我胆子很小，很小。我恨我自己胆小。我讨厌自己，不敢正视危险，只会逃跑。我想，哪怕是死在战场，也比逃跑，来的勇敢。我要去战斗，哪怕是战死，也不要逃跑</p><p>【博士】我是个疯子，你们要明白。没有压迫没有剥削没有死亡没有虚伪的世界，就是我要的。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;div
        
      
    
    </summary>
    
    
      <category term="游戏人生" scheme="https://old-driver-zero.github.io/categories/%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="童年" scheme="https://old-driver-zero.github.io/tags/%E7%AB%A5%E5%B9%B4/"/>
    
      <category term="植物大战僵尸" scheme="https://old-driver-zero.github.io/tags/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/"/>
    
      <category term="塔防" scheme="https://old-driver-zero.github.io/tags/%E5%A1%94%E9%98%B2/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++</title>
    <link href="https://old-driver-zero.github.io/posts/30479bcf.html"/>
    <id>https://old-driver-zero.github.io/posts/30479bcf.html</id>
    <published>2024-04-20T01:58:45.000Z</published>
    <updated>2024-04-27T02:32:22.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>基于 <em>Effective C++ Third Edition: 55 Specific Ways to ImproveYour Programs and designs</em> 编写</p><h1 id="让你自己习惯于-c">让你自己习惯于 C++</h1><h2 id="将-c-视为语言的联邦">将 C++ 视为语言的联邦</h2><p>C++不是一门单独的语言，其具有各种不同风格的语言特性，以至于可能出现两个同样使用C++ 的人会看不懂彼此的代码。一般分为四大组成部分：</p><ul><li>C</li><li>面向对象的 C++</li><li>模板 C++</li><li>STL</li></ul><p>因此基于使用的 C++ 的部分不用，Effective C++ 编程的规则也可能不同</p><h2 id="倾向于-constenum-和-inline-而不是-define">倾向于<code>const</code>、<code>enum</code> 和 <code>inline</code> 而不是<code>#define</code></h2><p>对于变量而言，<code>const</code> 和 <code>enum</code>限制了作用域</p><p>对于函数而言，<code>inline</code> 函数能够避免一些未知错误</p><h2 id="尽可能使用-const">尽可能使用 <code>const</code></h2><p>声明某种东西 <code>const</code> 可以帮助编译器检测一些使用错误，同时const可以适用于任何作用域中的对象，包括函数参数，返回值，甚至整个成员函数</p><p>编译器强制 bitwise const，但应该使用逻辑 const 编程</p><p>当 const 和非 const 成员函数有相同的实现时，可以让非 const 版调用const 版本</p><h2 id="确保对象在被使用之前初始化">确保对象在被使用之前初始化</h2><p>手动初始化内置类型对象</p><p>在构造函数中，倾向于使用成员初始化列表</p><p>通过将非局部静态对象替换为局部静态对象来避免跨转移单元的初始化顺序问题</p><h1id="构造函数析构函数和赋值运算符">构造函数、析构函数和赋值运算符</h1><h2 id="了解-c-默默地写和调用的是什么函数">了解 C++默默地写和调用的是什么函数</h2><p>编译器可能会隐式生成类的默认构造函数，复制构造函数，复制赋值运算符和析构函数</p><h2id="显式禁止编译器生成的不想要的函数的使用">显式禁止编译器生成的不想要的函数的使用</h2><p>通过声明这些函数为 <code>private</code> 并不给出实现</p><h2 id="在多态基类中声明析构函数为-virtual">在多态基类中声明析构函数为virtual</h2><p>多态基类应该声明 virtual析构函数，即如果一个类有虚函数，则应该有虚析构函数</p><p>相反，不被设计为基类或被多态使用的类不应该声明虚析构函数</p><h2 id="避免异常离开析构函数">避免异常离开析构函数</h2><p>析构函数不应该发送异常，故析构函数应该捕捉任何其调用的函数可能抛出的异常，然后吞下这些异常或终止程序</p><p>如果类的客户需要对执行操作中抛出的异常做出反应，则类应该提供一个非析构函数来执行这个操作，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConn</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>        db.<span class="hljs-built_in">close</span>();<br>        closed = <span class="hljs-literal">true</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">DBConn</span>() &#123;<br>        <span class="hljs-keyword">if</span> (!closed) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                db.<span class="hljs-built_in">close</span>();<br>            &#125; <span class="hljs-built_in">catch</span> (...) &#123;<br><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span>:<br>    DBConnection db;<br>    <span class="hljs-type">bool</span> closed;<br>&#125;<br></code></pre></td></tr></table></figure><p>用户需要手动调用 <code>close()</code>并对其可能抛出的异常做出反应</p><h2id="永远不要在构造或析构中调用虚函数">永远不要在构造或析构中调用虚函数</h2><p>因为在构造或析构中派生类不存在，只存在基类，故调用的是基类的虚函数，这会引起误解</p><h2 id="让赋值运算符返回对-this-的引用">让赋值运算符返回对<code>*this</code> 的引用</h2><p>主要是为了支持链式赋值：<code>x = y = z = 1;</code></p><h2 id="在-operator-中处理对自己赋值的情况">在 <code>operator=</code>中处理对自己赋值的情况</h2><p>方法有</p><ul><li>比较源和目标的地址</li><li>仔细检查语句的顺序</li><li>复制并交换</li></ul><p>同理，要确保任何对多个对象操作的函数在有相同对象的情况下表现也正确</p><h2 id="复制一个对象的所有部分">复制一个对象的所有部分</h2><p>复制函数应该确保复制了一个对象的所有数据成员和<strong>所有基类的部分</strong></p><p>不要试着用一个复制函数实现另一个，而是应该将共同的功能放到一个第三者函数中</p><h1 id="资源管理">资源管理</h1><h2 id="使用对象来管理资源">使用对象来管理资源</h2><p>为了防止资源泄漏，使用 RAII对象在其构造函数中获取资源并在其析构函数中释放资源</p><p>两个常用的 RAII 类为 <code>unique_ptr</code> 和<code>shared_ptr</code></p><h2id="在资源管理类中仔细考虑复制行为">在资源管理类中仔细考虑复制行为</h2><p>复制 RAII 对象需要复制其管理的资源，所以资源的复制行为决定了 RAII对象的复制行为</p><p>一般的 RAII类复制行为是禁止复制和执行引用计数，但其他的行为是可能的</p><h2id="在资源管理类中提供对原始资源的访问">在资源管理类中提供对原始资源的访问</h2><p>API 通常需要访问原始资源，所以每个 RAII类应该提供方法来获取其管理的资源</p><p>访问可能通过显式或隐式转换，一般来说，显式转换更安全，而隐式转换对客户来说更方便</p><h2 id="在一对-new-和-delete-中使用相同的形式">在一对 <code>new</code>和 <code>delete</code> 中使用相同的形式</h2><p>如果在 <code>new</code> 中使用了 <code>[]</code>，那么在相对于的<code>delete</code> 中也要使用 <code>[]</code></p><h2id="在单独的语句中在智能指针中存储-new-的对象">在单独的语句中在智能指针中存储<code>new</code> 的对象</h2><p>如果和其他语句放在一起，则在异常抛出时，资源可能还没交给智能指针管理，造成内存泄漏</p><h1 id="设计和声明">设计和声明</h1><h2id="让接口更容易正确地使用更难错误地使用">让接口更容易正确地使用，更难错误地使用</h2><p>促进正确使用的方法包括</p><ul><li>接口的一致性</li><li>对内置类型的表现兼容</li></ul><p>防止错误的方法包括</p><ul><li>创建新的类型</li><li>限制对类型的操作</li><li>限制类型值</li><li>减少客户端资源管理的责任</li></ul><p><code>shared_ptr</code> 支持自定义删除器，可以防止跨 DLL问题，可以用于自动解锁 mutex</p><h2 id="将类设计视为类型设计">将类设计视为类型设计</h2><p>类的本质就是类型，在设计类时会和内置类型的设计者考虑相同的问题，包括：</p><ul><li>新类型的对象应该怎样被创建和销毁？</li><li>对象初始化而后对象赋值有什么不同？</li><li>按值传递对新类型的对象意味着什么？</li><li>新类型的合法值有花生米限制？</li><li>新类型的适用于继承图吗？</li><li>新类型允许哪些转换？</li><li>对新类型来说，什么运算和函数合理？</li><li>那些标准函数应该被禁止？</li><li>谁应该能够访问新类型的成员？</li><li>新类型未声明的接口是什么？关乎实现，如效率、异常安全、资源管理等的保证</li><li>新类型有多通用？</li><li>新类型真的需要吗？</li></ul><h2 id="倾向于按-const-引用传递而不是按值传递">倾向于按 const引用传递而不是按值传递</h2><p>一般来说更有效率，同时也避免了派生类传递给基类时多余的部分被切掉的问题</p><p>内置类型、STL 迭代器和函数对象类型一般来说按值传递</p><h2id="当必须返回一个对象的时候不要返回引用">当必须返回一个对象的时候，不要返回引用</h2><p>不要返回对局部栈空间的对象的指针或引用</p><p>在新标准中，编译器已经做了这种事</p><h2 id="声明数据成员为-private">声明数据成员为 <code>private</code></h2><p>因为这样给予客户一致的对数据的访问，获取细粒度的访问控制，允许强制不变量，并灵活地提供类作者实现</p><p><code>protected</code> 并没有比 <code>public</code>封装程度高，因为所有的派生类仍然能够访问这些数据</p><h2id="倾向于非成员非友元函数而不是成员函数">倾向于非成员非友元函数而不是成员函数</h2><p>这种做法提高了</p><ul><li>封装：少了一个能够访问所有私有成员的函数</li><li>打包灵活性：连通其他同类型的有用的函数打包到一个命名空间中</li><li>功能扩展：与客户端的扩展而不是类的定义更接近</li></ul><h2id="当类型转换应该适用于所有的参数时声明非成员函数">当类型转换应该适用于所有的参数时，声明非成员函数</h2><p>例如要重载乘法运算符，最好声明为成员函数，因为其左右两边的参数都可以发生隐式类型转换</p><h2 id="考虑支持不抛出异常的-swap">考虑支持不抛出异常的<code>swap</code></h2><p>当 <code>std::swap</code> 可能对你的类型不高效时，提供一个<code>swap</code> 函数，确保其不会抛出异常</p><p>如果提供了一个成员<code>swap</code>，也应该提供一个调用了该成员的非成员函数，对于类（不是类模板），同时特例化<code>std::swap</code></p><p>但调用 <code>swap</code> 时，使用<code>using std::swap</code>，然后直接调用 <code>swap()</code></p><p>对于用户定义的类型可以特例化 std 模板，但不要尝试添加全新的东西到 std中</p><h1 id="实现">实现</h1><h2 id="尽可能延迟变量定义">尽可能延迟变量定义</h2><p>这种做法增加了程序的清晰度并提高了程序效率</p><h2 id="最小化-cast">最小化 cast</h2><p>尽可能避免 cast，尤其是效率敏感的代码中的<code>dynamic_cast</code></p><p>当 cast 必须时，将其藏在函数中</p><p>选择 C++ 风格的 cast</p><h2 id="避免返回对对象内部的处理">避免返回对对象内部的“处理”</h2><p>“处理”即引用，指针或迭代器。这种做法提高了封装，有助于 const成员函数表现 const，并最小化悬垂指针的创建</p><h2 id="力求无异常的代码">力求无异常的代码</h2><p>无异常的函数即使当发生异常时，无资源泄漏且无数据结构被破坏</p><ul><li>基本保证：程序中的所有东西都在一个有效的状态</li><li>强保证：在程序无改变的状态</li><li>无异常保证：从不抛出异常</li></ul><p>强保证可以通过复制并交换来实现，但是并不是对所有函数都实用</p><p>函数可以提供不强于其调用的最弱保证的函数的保证</p><h2 id="理解-inline-的里外">理解 inline 的里外</h2><p>inline应该是小的、频繁调用的函数。这促进调试和二进制更新能力，最小化潜在的代码膨胀，最大化更快程序的可能性</p><p>不要因为其出现在头文件中，就声明函数模板为 <code>inline</code></p><h2 id="最小化文件之间的编译依赖">最小化文件之间的编译依赖</h2><p>核心思想是依赖于<strong>声明</strong>而不是<strong>定义</strong>，有两种方法：</p><p><strong>把手类 handle class</strong>：</p><p>额外提供一个声明的头文件<code>...fwd.h</code>，客户端引用这个头文件而不是定义</p><p>只有在定义中才需要引入相关的定义的头文件</p><p>同时，因为对象中的数据大小是不确定的，所以可以通过将所有数据打包为一个指向<code>...Impl</code> 的智能指针，这样类的大小就是固定的了。这个<code>...Impl</code> 和原始的类应该有相同的接口</p><p>另一种方法是<strong>接口类 interface class</strong></p><p>方法是定义一个接口类（无构造函数，虚析构函数和纯虚函数），并提供一个静态的工厂函数以创建其实现类的对象的智能指针</p><p>当然，这两种方法都是有代价的。其牺牲了一定的性能和大小。</p><p>库头文件应该存在完全和只声明的形式，无论是否有模板都适用。</p><h1 id="继承与面向对象设计">继承与面向对象设计</h1><h2 id="确保-public-继承模型-is-a">确保 public 继承模型 is-a</h2><p>任何适用于基类的东西必须都适用于派生类，因为每个派生类都<strong>是</strong>一个基类对象</p><p>注意这是一个子集的关系，而不是松散意义上的“是”。这意味着不光是基类对象的所有描述性定义，还是其衍生出来的所有性质，子类都必须拥有</p><h2 id="避免隐藏继承名字">避免隐藏继承名字</h2><p>派生类中的名称隐藏了基类中的名称，在 public继承下，这是不想要的。</p><p>为了让隐藏的名称重新可见，可以使用 using 声明或者转发函数</p><h2 id="区分接口继承和实现继承">区分接口继承和实现继承</h2><p>在 public 继承下，派生类总是继承基类的接口</p><ul><li>纯虚函数只指明了继承的接口</li><li>简单的虚函数指明了继承的接口及默认实现</li><li>非虚函数指明了继承的接口和强制性的视线</li></ul><h2 id="考虑虚函数的替代品">考虑虚函数的替代品</h2><p>包括了<strong>非虚函数接口习语 non-virtual interfaceidiom(NVI)</strong> 和可变形式的策略设计模式。NVI习语实际上就是模板方法设计模式的一个例子</p><p>将功能从成员函数中移到类外部的函数的缺点是非成员函数缺少对类中的非公共成员的访问</p><p><code>function</code>对象类似于泛化的函数指针。这种对象支持所有有相同目标签名的可调用的实体</p><h2 id="从不重定义一个继承的非虚函数">从不重定义一个继承的非虚函数</h2><p>因为可能会导致非预期的错误</p><h2id="从不重定义一个函数的继承的默认参数值">从不重定义一个函数的继承的默认参数值</h2><p>因为默认参数值是静态绑定的，然而虚函数——唯一应该重定义的函数——是动态绑定的</p><h2 id="通过组合模拟有一个或以实现">通过组合模拟“有一个”或“以…实现”</h2><p>组合与公共继承有完全不同的意思</p><ul><li>在应用领域，组合意味着 <strong>has-a</strong></li><li>在实现领域，它意味着<strong>is-implemented-in-terms-of</strong></li></ul><h2 id="谨慎使用-private-继承">谨慎使用 private 继承</h2><p>private 继承同样意味着<strong>is-implemented-in-terms-of</strong>，通常比组合低级，只有在需要访问基类中private 成员或需要重定义虚函数时才会使用</p><p>不像组合，private继承能够空基优化，对于库开发者来说，可以最小化对象大小</p><h2 id="谨慎使用多继承">谨慎使用多继承</h2><p>多继承比单继承更复杂，可能导致模棱两可的问题，需要虚继承</p><p>虚继承在大小、速度、初始化和赋值的复杂性上都有代价，只有在虚类没有数据时最实际</p><p>多继承的用处在于将从接口类的公共继承和用于实现的类的私有继承组合起来</p><h1 id="模板和泛型编程">模板和泛型编程</h1><h2 id="了解隐式接口和编译时多态">了解隐式接口和编译时多态</h2><p>类和模板都支持接口和多态</p><ul><li>对于类来说，接口是显式的，基于函数签名。多态通过虚函数在运行时出现</li><li>对于模板参数来说，接口是隐式的，基于有效的表达式。多态通过模板实例化和函数重载解析，在编译时出现</li></ul><h2 id="理解-typename-的两种意思">理解 <code>typename</code>的两种意思</h2><p>在声明模板参数时，<code>class</code> 和 <code>typename</code>是可互换的</p><p>使用 <code>typename</code>来识别嵌套依赖的类型名，除了在基类列表或在成员初始化列表中的基类标识符</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">public</span> Base&lt;T&gt;::Nested &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Derived</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">        : Base&lt;T&gt;::Nested(x) &#123;</span><br>            <span class="hljs-keyword">typename</span> Base&lt;T&gt;::Nested temp;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2id="知道如何在模板化的基类中访问名字">知道如何在模板化的基类中访问名字</h2><p>在派生类模板中，使用 <code>this-&gt;</code>、<code>using</code>声明或显式基类限定，引用基类模板中的名字</p><p>主要是因为在派生类实例化的时候，基类模板没有实例化</p><h2 id="将参数无关的代码移除出模板">将参数无关的代码移除出模板</h2><p>模板生成多个类和多个函数，故任何不依赖于模板参数的模板代码都会导致膨胀</p><p>由于非类型模板参数导致的膨胀通常可以通过将模板参数替换为函数参数或类数据成员来减少</p><p>由于类型参数导致的膨胀可以通过共享相同二进制表示的实例化类型实现来减少，如替换为指针或引用等</p><h2id="使用成员函数模板来接受任何兼容类型">使用成员函数模板来接受“任何兼容类型”</h2><p>使用成员函数模板来生成接受所有兼容类型的函数</p><p>如果声明了对泛化的复制构造函数或泛化的赋值的成员模板，则仍然需要声明正常的复制构造函数或复制赋值操作</p><h2id="当需要类型转换的时候在模板内部定义非成员函数">当需要类型转换的时候，在模板内部定义非成员函数</h2><p>当编写需要对所有参数支持隐式类型转换的类模板时，在类内部定义函数为友元</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">const</span> Rational&lt;T&gt; <span class="hljs-title">doMultiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp;lhs, <span class="hljs-type">const</span> Rational&lt;T&gt;&amp;rhs)</span></span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> Rational&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp;lhs, <span class="hljs-type">const</span> Rational&lt;T&gt;&amp;rhs) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">doMultiply</span>(lhs, rhs);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">const</span> Rational&lt;T&gt; <span class="hljs-title">doMultiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp;lhs, <span class="hljs-type">const</span> Rational&lt;T&gt;&amp;rhs)</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对于关于类型的信息使用-trait-类">对于关于类型的信息，使用 trait类</h2><p>trait 类在编译时使关于类型的信息可用，其通过模板和模板特例化实现</p><p>和重载结合，trait 类使得执行编译时对 <code>if-else</code>检测可用</p><h2 id="了解模板元编程">了解模板元编程</h2><p>模板元编程可以将运行时的工作移动到编译时，使得更早检测到错误并提高运行效率</p><p>TMP可以用于生成基于策略选择的自定义代码，也可以用于避免生成对特定类型不合适的代码</p><h1 id="自定义-new-和-delete">自定义 <code>new</code> 和<code>delete</code></h1><h2 id="理解-new-handler-的表现">理解 new-handler 的表现</h2><p><code>set_new_handler</code>运行指明当内存分配请求无法满足时调用的函数</p><p>不抛出异常的 new用处不大，因为其只适用于内存分配，但在相关的构造函数被调用时仍然有可能抛出异常</p><h2 id="理解替代-new-和-delete-的情况">理解替代 <code>new</code> 和<code>delete</code> 的情况</h2><ul><li>提高效率</li><li>调试堆使用错误</li><li>收集堆使用信息</li></ul><h2 id="在写-new-和-delete-时坚持惯例">在写 <code>new</code> 和<code>delete</code> 时坚持惯例</h2><ul><li><code>new</code> 应该<ul><li>在无限循环中尝试分配内存</li><li>如果无法满足一个内存请求，则调用 new-handler</li><li>处理 0 字节的请求</li><li>指明类的版本应该处理比期望更大的块的请求，如<code>if (size != sizeof(Base)) return ::operator new(size);</code></li></ul></li><li><code>delete</code> 应该<ul><li>如果传递的指针是 <code>null</code>，则什么都不做</li><li>指明类的版本应该处理比期望的块更大，如<code>if (size != sizeof(Base)) &#123; ::operator delete(rawMemory); return; &#125;</code></li></ul></li></ul><h2 id="如果写-new-的替代也要编写-delete-的替代">如果写 <code>new</code>的替代，也要编写 <code>delete</code> 的替代</h2><p>否则可能会发生内存泄漏</p><p>注意不要隐藏了这些函数的正常版本</p><h1 id="杂项">杂项</h1><h2 id="关注编译器警告">关注编译器警告</h2><p>力求在最大警告级别时仍然没有警告</p><p>但不要依赖于编译器警告，因为不同编译器警告不同的东西</p><h2 id="熟悉标准库包括-tr1">熟悉标准库，包括 TR1</h2><p>TR1 是一个规范，需要实现，如 Boost</p><h2 id="熟悉-boost">熟悉 Boost</h2><p><a href="https://www.boost.org/">Boost C++ Libraries</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;基于 &lt;em&gt;Effective C++ Third Edition:
        
      
    
    </summary>
    
    
      <category term="工具" scheme="https://old-driver-zero.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="C++" scheme="https://old-driver-zero.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Java 开发手册</title>
    <link href="https://old-driver-zero.github.io/posts/74c3ade.html"/>
    <id>https://old-driver-zero.github.io/posts/74c3ade.html</id>
    <published>2024-04-13T02:27:31.000Z</published>
    <updated>2024-04-14T05:05:08.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>基于 <a href="https://github.com/alibaba/p3c">Alibaba 的 Java开发手册</a>编写</p><h1 id="编程规约">编程规约</h1><h2 id="命名风格">命名风格</h2><p>类名：UpperCamelCase，其余使用 lowerCamelCase，常量全部大写</p><p>抽象类使用 <code>Abstract</code> 开头，异常类使用<code>Exception</code> 结尾，测试类以要测试的类的名称开始，以<code>Test</code> 结尾</p><p>包名统一使用<strong>单数</strong>形式</p><p>在变量命名时，表示类型的名词放在结尾，如 <code>nameList</code></p><p>设计模式应该体现出来</p><p>接口类中不要加任何修复符号</p><p>Service/DAO 层命名规约：</p><ul><li><p>获取单个对象：get</p></li><li><p>获取多个对象：list，并复数结尾</p></li><li><p>获取统计值用 count</p></li><li><p>插入 insert</p></li><li><p>删除 remove</p></li><li><p>修改 update</p></li><li><p>领域模型：</p><ul><li>数据对象：数据表名 + DO</li><li>数组传输对象：业务领域相关的名称 + DTO</li><li>展示对象：网页名称 + VO</li></ul></li></ul><h2 id="oop-规约">OOP 规约</h2><p>所有整型包装类对象之间值的比较，均使用 <code>equals</code></p><p><code>BigDecimal</code> 使用 <code>compareTo()</code> 方法比较</p><p>所有 POJO 类属性和 RPC方法必须使用包装数据类型，局部变量使用基本数据类型</p><h2 id="集合处理">集合处理</h2><p>Comparator 实现类要满足三个条件，注意考虑相等的情况</p><p>使用 <code>entrySet</code> 遍历 Map 类集合</p><h2 id="注释规约">注释规约</h2><p>类、类属性、类方法的注释必须使用 <code>Javadoc</code> 规范</p><p>所有抽象方法必须指出该方法做什么事情，实现什么功能</p><p>特殊注释标记：代办事宜 <code>TODO</code> 和错误<code>FIXME</code></p><h2 id="前后端规约">前后端规约</h2><p>前后端交互的 API需要明确协议、域名、路径、请求方法、请求内容、状态码、响应体</p><p>如果返回的数据为空，则返回空数组 <code>[]</code> 或空集合<code>&#123;&#125;</code></p><p>服务器发生错误时，返回给前端的相应信息必须包括：</p><ul><li>HTTP 状态码<ul><li>200 OK</li><li>401 Unauthorized</li><li>403 Forbidden</li><li>404 NotFound</li><li>500 InternalServerError</li></ul></li><li>errorCode</li><li>errorMessage</li><li>用户提示信息</li></ul><h1 id="工程结构">工程结构</h1><h2 id="应用分层">应用分层</h2><figure><img src="/illustration/Java%20开发手册/应用分层.webp" alt="应用分层" /><figcaption aria-hidden="true">应用分层</figcaption></figure><p>分层领域模型规约：</p><ul><li><strong>DO(Data Object)</strong>：与数据库表结构一一对应，通过 DAO层向上传输数据源对象</li><li><strong>DTO(Data Transfer Object)</strong>：数据传输对象，Service 或Manager 向外传输的对象</li><li><strong>BO(Business Object)</strong>：业务对象</li><li><strong>VO(View Object)</strong>：显示层对象</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;基于 &lt;a
        
      
    
    </summary>
    
    
      <category term="工具" scheme="https://old-driver-zero.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="https://old-driver-zero.github.io/tags/Java/"/>
    
      <category term="代码规范" scheme="https://old-driver-zero.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
      <category term="阿里巴巴" scheme="https://old-driver-zero.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ IDEA</title>
    <link href="https://old-driver-zero.github.io/posts/dc5fbc03.html"/>
    <id>https://old-driver-zero.github.io/posts/dc5fbc03.html</id>
    <published>2024-04-11T01:37:22.000Z</published>
    <updated>2024-04-11T02:27:41.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a> 是 Java和 Kotlin 的知名 IDE，简单而功能强大</p><h1 id="插件推荐">插件推荐</h1><p><ahref="https://plugins.jetbrains.com/plugin/13710-chinese-simplified-language-pack----">Chinese(Simplified) Language Pack / 中文语言包</a></p><blockquote><p>我判断一个外国工具是否流行的唯一依据是其是否支持中文。——沃兹基·硕德</p></blockquote><p><ahref="https://plugins.jetbrains.com/plugin/18824-codeglance-pro">CodeGlancePro</a></p><figure><img src="/illustration/IntelliJ%20IDEA/CodeGlance%20Pro.webp"alt="CodeGlance Pro" /><figcaption aria-hidden="true">CodeGlance Pro</figcaption></figure><p>侧边栏显示代码缩略图，类似与 VS Code 的功能</p><p><ahref="https://plugins.jetbrains.com/plugin/10080-rainbow-brackets">RainbowBrackets</a></p><figure><img src="/illustration/IntelliJ%20IDEA/Rainbow%20Brackets.webp"alt="Rainbow Brackets" /><figcaption aria-hidden="true">Rainbow Brackets</figcaption></figure><p>彩虹括号，可惜是付费的，但也有免费的版本：<ahref="https://plugins.jetbrains.com/plugin/20710-rainbow-brackets-lite--free-and-opensource">RainbowBrackets Lite</a></p><p><ahref="https://plugins.jetbrains.com/plugin/14109-alibaba-java-coding-guidelines-xenoamess-tpm-">AlibabaJava Coding Guidelines(XenoAmess TPM)</a>：基于 <ahref="https://github.com/alibaba/p3c">Java开发手册</a>，提供了一系列的代码检查和修复功能</p><p><a href="https://plugins.jetbrains.com/plugin/10650-json-parser">JsonParser</a>：验证和格式化 JSON 字符串的工具</p><p><a href="https://plugins.jetbrains.com/plugin/7125-grep-console">GrepConsole</a>：给控制台输出标上颜色，过滤输出等</p><p><ahref="https://plugins.jetbrains.com/plugin/10044-atom-material-icons">AtomMaterial Icons</a>：IDEA 版的 Material 图标库</p><p><ahref="https://plugins.jetbrains.com/plugin/14280-restfultool">RestfulTool</a></p><figure><img src="/illustration/IntelliJ%20IDEA/RestfulTool.webp"alt="RestfulTool" /><figcaption aria-hidden="true">RestfulTool</figcaption></figure><p>方便查看 Restful 服务开发</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;&lt;a
        
      
    
    </summary>
    
    
      <category term="工具" scheme="https://old-driver-zero.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="IDE" scheme="https://old-driver-zero.github.io/tags/IDE/"/>
    
      <category term="JetBrains" scheme="https://old-driver-zero.github.io/tags/JetBrains/"/>
    
  </entry>
  
  <entry>
    <title>C++ 入门（下）</title>
    <link href="https://old-driver-zero.github.io/posts/8724ba9a.html"/>
    <id>https://old-driver-zero.github.io/posts/8724ba9a.html</id>
    <published>2024-04-10T08:24:19.000Z</published>
    <updated>2024-04-20T02:02:57.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="关联型容器-associative-containers">关联型容器 AssociativeContainers</h1><p>关联型容器通常需要键满足 <code>&lt;</code>，否则可以自定义一个：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compareIsbn</span><span class="hljs-params">(<span class="hljs-type">const</span> Sales_data &amp;lhs, <span class="hljs-type">const</span> Sales_data &amp;rhs)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">isbn</span>() &lt; rhs.<span class="hljs-built_in">isbn</span>();<br>&#125;<br><span class="hljs-function">multiset&lt;Sales_data, <span class="hljs-title">decltype</span><span class="hljs-params">(compareIsbn)</span>*&gt; <span class="hljs-title">bookstore</span><span class="hljs-params">(compareIsbn)</span></span>;<br></code></pre></td></tr></table></figure><p>关联性容器定义了三种类型：</p><ul><li><code>key_type</code></li><li><code>mapped_type</code></li><li><code>value_type</code><ul><li><code>set</code>：<code>key_type</code></li><li><code>map</code>：<code>pair&lt;const key_type, mapped_type&gt;</code></li></ul></li></ul><p>set 的迭代器都是 <code>const_iterator</code></p><p><code>.lower_bound()</code> &gt;=，<code>.upper_bound()</code>&gt;，<code>.equal_range()</code></p><p>除此之外，还有键可以重复的 <code>multiset</code> 和<code>multimap</code></p><p><code>unordered_set</code> 和 <code>unordered_map</code> 使用hash，不保证顺序</p><h1 id="动态内存-dynamic-memory">动态内存 Dynamic Memory</h1><p>智能指针：</p><ul><li><code>shared_ptr&lt;T&gt; sp</code> 和<code>unique_ptr&lt;T&gt; up</code></li><li><code>p.get()</code> 返回 p 中的指针</li><li><code>make_shared&lt;T&gt;(args)</code> 返回指向动态分配类型 T的对象的 <code>shared_ptr</code>，使用 <code>args</code> 初始化对象</li></ul><p><code>.reset</code> 更新引用计数并可能会删除指向的对象</p><p>也可以显式指定析构函数：<code>shared_ptr&lt;T, D&gt; s2(d)</code> 或<code>unique_ptr&lt;T, D&gt; u2(d)</code>，一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">connection c = <span class="hljs-built_in">connect</span>(&amp;d);<br><span class="hljs-function">unique_ptr&lt;connection, <span class="hljs-title">decltype</span><span class="hljs-params">(end_connection)</span>*&gt; <span class="hljs-title">p</span><span class="hljs-params">(&amp;c, end_connection)</span></span>;<br></code></pre></td></tr></table></figure><p>转移所有权的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p2</span><span class="hljs-params">(p1.release())</span></span>;<br></code></pre></td></tr></table></figure><p><code>weak_ptr</code>是不会控制指向对象的生命周期的智能指针，其通常指向由<code>shared_ptr</code> 管理的对象</p><p>因为有可能指向已经被释放的值，故不能直接访问，而是通过<code>.lock()</code>：如果已经 <code>w.expired() == true</code>，则返回<code>nullptr</code>；否则返回指向的对象的 <code>shared_ptr</code></p><p>也支持动态分配数组：<code>unique_ptr&lt;T[]&gt; u</code></p><p>但注意当使用 <code>shared_ptr</code> 时，要指定析构函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>], [](<span class="hljs-type">int</span> *p) &#123; <span class="hljs-keyword">delete</span>[] p; &#125;)</span></span>;<br></code></pre></td></tr></table></figure><p><code>allocator</code> 可以将分配从构造中分离出来</p><ul><li>定义 <code>allocator&lt;T&gt; a</code></li><li><code>a.allocate(n)</code> 分配原始的，为构造的内存以存放 n 个 T类型的对象</li><li><code>a.construct(p, args)</code>：<code>p</code> 必须指向 T类型原始内存的指针，<code>args</code> 是用来构造的参数</li><li><code>a.destroy(p)</code>：运行析构函数</li><li><code>a.deallocate(p, n)</code>：归还 <code>allocate</code>的内存</li></ul><p>一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">allocator&lt;string&gt; alloc;<br><span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> p = alloc.<span class="hljs-built_in">allocate</span>(n);<br><span class="hljs-keyword">auto</span> q = p;<br>alloc.<span class="hljs-built_in">construct</span>(q++);<br>alloc.<span class="hljs-built_in">construct</span>(q++, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;c&#x27;</span>);<br>alloc.<span class="hljs-built_in">construct</span>(q++, <span class="hljs-string">&quot;hi&quot;</span>);<br><span class="hljs-keyword">while</span> (q != p)<br>    alloc.<span class="hljs-built_in">destroy</span>(--q);<br>alloc.<span class="hljs-built_in">deallocate</span>(p, n);<br></code></pre></td></tr></table></figure><p>类似于 <code>copy</code> 和 <code>fill</code>的算法，<code>allocator</code>也有相对应的算法：<code>uninitialized_copy(b, e, b2)</code> 和<code>uninitialized_fill(b ,e t)</code></p><h1 id="复制控制-copy-control">复制控制 Copy Control</h1><h2 id="复制赋值和销毁">复制，赋值和销毁</h2><p><strong>copyconstructor</strong>：<code>Foo(const Foo&amp;);</code></p><p>复制初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(dots)</span></span>; <span class="hljs-comment">// 直接初始化</span><br>string s2 = dots; <span class="hljs-comment">// 复制初始化</span><br></code></pre></td></tr></table></figure><p>有的类使用 <code>explicit</code> 指定必须使用直接初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// ok</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v1 = <span class="hljs-number">10</span>; <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure><p><strong>copyassignment</strong>：<code>Foo&amp; operator=(const Foo&amp;);</code></p><p><strong>析构函数 destructor</strong>：<code>~Foo();</code></p><p>以上三者必须同时定义</p><p>使用 <code>= default</code> 来显式要求编译器生成默认的版本</p><p>极少数类（如 <code>iostream</code>）会禁止复制，使用<code>= delete</code></p><h2 id="复制控制和资源管理">复制控制和资源管理</h2><p>尽管很少见，但赋值运算符<strong>必须</strong>支持自己给自己赋值，故其<strong>一定</strong>要先复制<code>rhs</code> 操作数，再删除 <code>lhs</code> 操作数</p><p>尽管 <code>swap</code> 不是必须的，但是定义 <code>swap</code>可以有更好的优化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(HasPtr &amp;lhs, HasPtr &amp;rhs)</span> </span>&#123;<br>    <span class="hljs-keyword">using</span> std::swap; <span class="hljs-comment">// 一定要这么使用，而不是指定 std::swap</span><br>    <span class="hljs-built_in">swap</span>(lhs.ps, rhs.ps);<br>    <span class="hljs-built_in">swap</span>(lhs.i, rhs. i);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="swap">Swap</h2><p>可以在赋值中使用 <code>swap</code>，这种做法比较安全：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">HasPtr&amp; HasPtr::<span class="hljs-keyword">operator</span>=(HasPtr rhs) &#123;<br>    <span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>, rhs);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="移动对象">移动对象</h2><p><code>IO</code> 和 <code>unique_ptr</code> 不可以被复制，但可以被<code>move</code></p><p><strong>左值引用</strong>和<strong>右值引用</strong></p><p>可以使用 <code>std::move</code> 将左值转换为右值</p><p>相对应的，就有了 move constructor：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">StrVec::<span class="hljs-built_in">StrVec</span>(StrVec &amp;&amp;s) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">elements</span>(s.elements), <span class="hljs-built_in">first_free</span>(s.first_free), <span class="hljs-built_in">cap</span>(s.cap) &#123;<br>    s.elements = s.first_free = s.cap = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 让 s 能够安全地调用析构函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为 move constructor 没有分配资源，所以并不会抛出异常，故要加上<code>noexcept</code></p><p><code>push_back()</code>保证了如果发生异常，则原有数据保持不变。那么如果 move constructor发生了异常，则旧数据和新数据都会损坏，故只能选择 copyconstructor。所以需要显式指明不会抛出异常</p><p>对应的也就有 move assignment：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">StrVec&amp; StrVec::<span class="hljs-keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="hljs-keyword">noexcept</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) &#123; <span class="hljs-comment">// 注意要判断是否是给自己赋值</span><br>        <span class="hljs-built_in">free</span>();<br>        elements = rhs.elements;<br>        first_free = rhs.first_free;<br>        cap = rhs.cap;<br>        rhs.elements = rhs.first_free = rhs.cap = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>只有当一个类没有定义自己的复制控制的成员时，编译器才会合成 move成员</p><p>一种<strong>同时</strong>定义了 copy 和 move 赋值的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">HasPtr&amp; <span class="hljs-keyword">operator</span>=(HasPtr rhs) &#123;<br>    <span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>, rhs);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一般的迭代器在解引用时返回的是<strong>左值引用</strong>，但是<strong>move iterator</strong>返回的却是一个<strong>右值引用</strong></p><p>将迭代器转为移动迭代器的做法：<code>make_move_iterator()</code></p><p>区分复制和移动参数的重载函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> X&amp;)</span></span>; <span class="hljs-comment">// 复制</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(X&amp;&amp;)</span></span>; <span class="hljs-comment">// 移动</span><br></code></pre></td></tr></table></figure><p>类似于 <code>const *this</code>，我们也可以指定 <code>*this</code>是左值还是右值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Foo&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Foo&amp;) &amp;; <span class="hljs-comment">// this 是一个左值</span><br></code></pre></td></tr></table></figure><h1id="重载运算和转换-overloaded-operations-and-conversions">重载运算和转换Overloaded Operations and Conversions</h1><p>可以显式调用运算符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">operator</span>+(data1, data2);<br>data1.<span class="hljs-keyword">operator</span>+=(data2);<br></code></pre></td></tr></table></figure><p>成员函数与非成员函数</p><p>输入流和输出流重载</p><p>算术运算符通常使用符号赋值重载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Sales_data <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Sales_data &amp;lhs, <span class="hljs-type">const</span> Sales_data &amp;rhs) &#123;<br>    Sales_data sun = lhs;<br>    sum += rhs;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时定义</p><p>支持初始化列表的赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">StrVec&amp; StrVec::<span class="hljs-keyword">operator</span>=(initializer_list&lt;string&gt; il) &#123;<br>    <span class="hljs-keyword">auto</span> data = <span class="hljs-built_in">alloc_n_copy</span>(il.<span class="hljs-built_in">begin</span>(), il.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">free</span>();<br>    elements = data.first;<br>    first_free = cap = data.second;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义下标运算符时，通常要定义两个版本：const 和非 const 的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StrVec</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    std::string&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> n) &#123; <span class="hljs-keyword">return</span> elements[n]; &#125;<br>    <span class="hljs-type">const</span> std::string&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> n) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> elements[n]; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自增/自减分为前缀/后缀版本，用一个为 <code>0</code>的参数来区分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StrBlobPtr</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 前缀版本</span><br>    StrBlobPtr&amp; <span class="hljs-keyword">operator</span>++();<br>StrBlobPtr&amp; <span class="hljs-keyword">operator</span>--();<br>    <span class="hljs-comment">// 后缀版本</span><br>    StrBlobPtr <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>);<br>StrBlobPtr <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>甚至可以重载<strong>函数调用</strong>运算符，像函数一样使用，叫<strong>函数对象</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">absInt</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> val &lt; <span class="hljs-number">0</span> ? -val : val;<br>    &#125;<br>&#125;<br><br>absInt absObj;<br><span class="hljs-type">int</span> ui = <span class="hljs-built_in">absObj</span>(<span class="hljs-number">-42</span>);<br></code></pre></td></tr></table></figure><p>事实上，lambda 就是函数对象</p><p>对于一个捕获了局部变量的lambda，其相当于构造函数带该参数，并保存在其成员变量中</p><p><code>functional</code>头文件中定义了很多类型，如：<code>plus&lt;T&gt;</code>、<code>greater&lt;T&gt;</code>等</p><p>有多种可调用对象，如函数，函数指针，lambda，重载了 <code>()</code>的对象等，该头文件中还定义了函数原型以统一这些表达：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">map&lt;string, function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt;&gt; binops = &#123;<br>    &#123;<span class="hljs-string">&quot;+&quot;</span>, add&#125;, <span class="hljs-comment">// 函数指针</span><br>    &#123;<span class="hljs-string">&quot;-&quot;</span>, std::<span class="hljs-built_in">minus</span>&lt;<span class="hljs-type">int</span>&gt;()&#125;, <span class="hljs-comment">// 库函数对象</span><br>    &#123;<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-built_in">div</span>()&#125;, <span class="hljs-comment">// 用户定义的函数对象</span><br>    &#123;<span class="hljs-string">&quot;*&quot;</span>, [](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123; <span class="hljs-keyword">return</span> i * j; &#125;&#125; <span class="hljs-comment">// 匿名 lambda</span><br>&#125;<br></code></pre></td></tr></table></figure><p>类型转换函数的基本形式：<code>operator 类型名() const</code></p><p>前面可以加上 <code>explicit</code>，强制要求显式转换</p><h1 id="面向对象编程-object-oriented-programming">面向对象编程Object-Oriented Programming</h1><h2 id="概览">概览</h2><p><strong>基类 base class</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Quoto</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> n)</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>派生类 derived class</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bulk_quote</span> : <span class="hljs-keyword">public</span> Quote &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>动态绑定（运行时绑定）</strong>：根据运行时是对基类还是派生类的引用，调用不同类中的函数</p><p>基类一般会定义一个 <code>virtual</code> 析构函数，使得其动态绑定</p><p><code>virtual</code> 关键字表示希望派生类覆盖该成员</p><h2 id="定义基类和派生类">定义基类和派生类</h2><p>派生类会自动转换为基类，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">Bulk_quote bulk;<br>Quote *p = &amp;bulk; <span class="hljs-comment">// 指向 bulk 的 Quote 部分</span><br>Quote &amp;p = bulk; <span class="hljs-comment">// 引用 bulk 的 Quote 部分</span><br></code></pre></td></tr></table></figure><p>基类先初始化，然后才是派生类的成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Bulk_quote</span>(<span class="hljs-type">const</span> std::string&amp; book, <span class="hljs-type">double</span> p, <span class="hljs-type">double</span> disc) :<br><span class="hljs-built_in">Quote</span>(book, p), <span class="hljs-built_in">discount</span>(dics) &#123; &#125;;<br></code></pre></td></tr></table></figure><p>对于 <code>static</code> 成员，则整个层次结构中只有一个该成员实例</p><p>使用 <code>final</code>来防止一个类被继承：<code>class NoDerived final &#123; ... &#125;;</code></p><p>静态类型（编译时）和动态类型（运行时）</p><p>基类向派生类没有隐式转换</p><p>注意这只在<strong>引用</strong>和<strong>指针</strong>之间讨论，在基类和派生类<strong>对象</strong>之间没有隐式转换</p><h2 id="虚函数">虚函数</h2><p><strong>只有</strong>在通过指针或引用调用虚函数时，才会在运行时处理，否则在编译时解决</p><p>一旦某个函数被定义为 <code>virtual</code>，则会在所有派生类中都定义为<code>virtual</code></p><p>可以使用 <code>override</code> 显式指明覆盖了基类中的某个虚函数</p><p>注意只有 <code>virtual</code> 函数可以<code>override</code>，<code>final</code> 函数不会被<code>override</code></p><p>可以绕开虚函数机制</p><h2 id="抽象基类">抽象基类</h2><p><strong>纯虚函数 pure virtual</strong>不会被定义，方法是在声明时在后面加 <code>= 0</code></p><p>有纯虚函数的类是<strong>抽象基类 abstract baseclass</strong>，不能创建抽象基类的对象，其相当于提供了一个要求派生类覆盖的<strong>接口</strong></p><p>派生类的构造函数只初始化它的直接基类</p><h2 id="访问控制和继承">访问控制和继承</h2><p><code>public</code> 和 <code>private</code>继承不影响该类的访问控制，但会影响这个类的用户（包括其派生类）能否访问到其基类的成员</p><p>friend 不会被继承</p><p>类内部的 <code>using</code> 声明可以使其 <code>private</code>继承来的被访问到</p><h2 id="继承下的类作用域">继承下的类作用域</h2><p>名字的查找发生在编译时</p><h2 id="构造函数和复制控制">构造函数和复制控制</h2><p>析构函数必须是 <code>virtual</code> 的</p><p>构造时先构造基类，析构时反过来</p><h2 id="容器与继承">容器与继承</h2><p>如果我们想要容纳以继承关联的对象，一般放智能指针，这样使用的就是动态类型</p><h1 id="模板和泛型编程-templates-and-generic-programming">模板和泛型编程Templates and Generic Programming</h1><p>面向对象编程和泛型变成都是处理<strong>编写程序</strong>时不知道的类型的，但是OOP在<strong>运行</strong>时处理，泛型则在<strong>编译</strong>时处理</p><h2 id="定义一个模板">定义一个模板</h2><p>函数模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;v1, <span class="hljs-type">const</span> T &amp;v2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (v1 &lt; v2) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (v2 &lt; v1) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-built_in">compare</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>) &lt;&lt; endl; <span class="hljs-comment">// 可以推断出模板参数类型</span><br></code></pre></td></tr></table></figure><p>我们也可以定义<strong>非类型参数 nontypeparameters</strong>，即表示的是一个<strong>值</strong>而不是<strong>类型</strong>，在模板函数内部一定是一个<strong>常量表达式</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">unsigned</span> N, <span class="hljs-type">unsigned</span> M&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> (&amp;p1)[N], <span class="hljs-type">const</span> <span class="hljs-type">char</span> (&amp;p2)[M])</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(p1, p2);<br>&#125;<br><span class="hljs-built_in">compare</span>(<span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-string">&quot;mom&quot;</span>); <span class="hljs-comment">// 使用</span><br></code></pre></td></tr></table></figure><p>为了生成实例化，编译器需要定义函数模板或类模板成员函数，所以这两者一般都放在头文件中</p><p>在类的外部定义类模板成员函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>返回类型 Blob&lt;T&gt;::成员函数名(参数列表)<br></code></pre></td></tr></table></figure><p>只有当某个成员被使用时，它才会被实例化</p><p>可以让友元的成为模板的所有实例的朋友，也可以一对一成为友元</p><p>可以使模板类型参数成为友元：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> &#123;<br>    <span class="hljs-keyword">friend</span> Type;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以定义类模板的类型别名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">using</span> twin = pair&lt;T, T&gt;;<br>twin&lt;strin&gt; authors;<br></code></pre></td></tr></table></figure><p>类模板和函数参数支持设置默认值，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> F = less&lt;T&gt;&gt;<br><span class="hljs-type">int</span> <span class="hljs-built_in">compare</span>(<span class="hljs-type">const</span> T &amp;v1, <span class="hljs-type">const</span> T &amp;v2, F f = <span class="hljs-built_in">F</span>()) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">f</span>(v1, v2)) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-built_in">f</span>(v2, v1)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以显式实例化来避免开销：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">template</span> 声明; <span class="hljs-comment">// 实例化声明</span><br><span class="hljs-keyword">template</span> 声明; <span class="hljs-comment">// 实例化定义</span><br></code></pre></td></tr></table></figure><p><code>unique_ptr</code> 在编译时绑定了 deleter，而<code>shared_ptr</code> 在运行时绑定了 deleter</p><h2 id="模板参数推断">模板参数推断</h2><p>模板类型参数的仅有的自动转换是 const 转换和数组或函数指针转换</p><p>而常规的转换应用于非模板参数的类型上</p><p>函数模板可以显式指定参数类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> T3&gt;<br><span class="hljs-function">T1 <span class="hljs-title">sum</span><span class="hljs-params">(T2, T3)</span></span>;<br><br><span class="hljs-built_in">sum</span>&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;(i, lng);<br></code></pre></td></tr></table></figure><p>这是一个返回未知类型的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> It&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">fcn</span><span class="hljs-params">(It beg, It end)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(*beg)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> *beg;<br>&#125;<br></code></pre></td></tr></table></figure><p>其返回的是一个引用，但是如果是想要按值返回，则可以显式<strong>类型改变type transformation</strong>：<code>remove_reference&lt;&gt;</code></p><p>引用合并：</p><ul><li><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code>都合并为 <code>X&amp;</code></li><li><code>X&amp;&amp; &amp;&amp;</code> 合并为<code>X&amp;&amp;</code></li></ul><p>故即使参数的形式是右值 <code>&amp;&amp;</code>，也可能合并为左值<code>&amp;</code></p><p>因此，函数参数中的对模板类型的右值引用可以绑定到左值上，即若一个左值传递给这个参数，则会被实例化为左值引用</p><p>使用右值的函数模板通常被重载为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp;)</span></span>; <span class="hljs-comment">// 绑定到非 const 右值</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;)</span></span>; <span class="hljs-comment">// 左值和 const 右值</span><br></code></pre></td></tr></table></figure><p>实际上，<code>std::move</code> 的原理如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::<span class="hljs-function">type&amp;&amp; <span class="hljs-title">move</span><span class="hljs-params">(T&amp;&amp; t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>std::forward</code>可以在保持原始参数类型的情况下传递参数，其返回的类型是<code>T&amp;&amp;</code>，例如实现一个交换调用参数顺序的模板函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flip</span><span class="hljs-params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp; t2)</span> </span>&#123;<br>    <span class="hljs-built_in">f</span>(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="重载和模板">重载和模板</h2><p>当有几个重载函数都能够匹配调用时，会选择最详细的那个</p><p>如果还有非模板函数也能匹配，则更优先匹配非模板函数</p><h2 id="可变模板">可变模板</h2><p><strong>可变模板 variadic template</strong>是接受可变数量的参数的模板函数或类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;t, <span class="hljs-type">const</span> Args&amp; ... rest)</span></span>;<br></code></pre></td></tr></table></figure><p>可以使用 <code>sizeof...()</code> 获取包中的元素数量</p><p>通常使用递归实现展开：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(ostream &amp;os, <span class="hljs-type">const</span> T &amp;t, <span class="hljs-type">const</span> T &amp;t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> os &lt;&lt; t;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function">ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(ostream &amp;os, <span class="hljs-type">const</span> T &amp;t, <span class="hljs-type">const</span> Args&amp; ... rest)</span> </span>&#123;<br>    os &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">print</span>(os, rest...);<br>&#125;<br></code></pre></td></tr></table></figure><p>通常和 <code>std::forward&lt;Argss&gt;(args)...</code>一起使用转发给别的函数</p><h2 id="模板特化">模板特化</h2><p>我们可以接管编译器做的工作，即<strong>模板特化 templatespecialization</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> &amp;p1, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> &amp;p2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(p1, p2);<br>&#125;<br></code></pre></td></tr></table></figure><p>模板特化也适用于类模板，但要注意定义在同一个命名空间中</p><p>类模板可以部分特化，但函数模板不行</p><h1 id="专业化的库设施-specialized-library-facilities">专业化的库设施Specialized Library Facilities</h1><h2 id="tuple-类型"><code>tuple</code> 类型</h2><p><code>tuple</code> 和 <code>pair</code>类似，但是支持容纳多个元素</p><p>定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">tuple&lt;<span class="hljs-type">size_t</span>, <span class="hljs-type">size_t</span>, <span class="hljs-type">size_t</span>&gt; item&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><p>或者使用 <code>make_tuple</code></p><p>访问其中的元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">tuple_element&lt;<span class="hljs-number">1</span>, <span class="hljs-keyword">decltype</span>(item)&gt;::type cnt = <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(item);<br></code></pre></td></tr></table></figure><p>tuple 支持关系比较</p><h2 id="bitset-类型"><code>bitset</code> 类型</h2><p>定义 32 位：<code>bitset&lt;32&gt; bitvec(1U);</code>，其中低位为1</p><p>也可以从字符串中获取：<code>bitset&lt;32&gt; bitvec4("1100");</code>，注意最低位为0</p><p>其支持丰富的操作位的函数</p><p>以字符串格式 IO</p><h2 id="正则表达式">正则表达式</h2><h2 id="随机数">随机数</h2><p>使用到了两个类——<strong>随机数引擎 random-number engines</strong>和<strong>随机数分布类 random-number distribution classes</strong></p><p>生成均匀 <code>[0, 9]</code> 的均匀的随机数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">uniform_int_distribution&lt;<span class="hljs-type">unsigned</span>&gt; <span class="hljs-title">u</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">9</span>)</span></span>;<br><span class="hljs-function">default_random_engine <span class="hljs-title">e</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>    cout &lt;&lt; <span class="hljs-built_in">u</span>(e) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><p>还支持生成小数<code>uniform_real_distribution&lt;&gt;</code>、正态分布<code>normal_distribution&lt;&gt;</code></p><h2 id="再探-io-库">再探 IO 库</h2><p><strong>操作符 manipulator</strong> 用于控制输出的格式</p><p>如十进制、八进制，精度</p><p>还支持更低级的 IO：</p><ul><li><code>is.get(ch)</code> 读下一个字节到 ch 中</li><li><code>os.put(ch)</code> 把下一个字符 ch 放到 os 中</li><li><code>is.get()</code> 返回下一个字节为 int，因为可能读到的是EOF</li><li><code>is.unget()</code> 放回一个字节</li><li><code>is.peek()</code> 返回下一个字节为 int，但不会移除</li><li><code>is.putback(ch)</code> 把 ch 放回 is</li></ul><p>还有支持多字节的版本：</p><ul><li><code>is.getline(sink, size, delim)</code> 读至多 <code>size</code>个字节至 EOF 或 delim 到 sink 指向的位置，注意 delim 不会被存储。delim也会被保存的版本：<code>get</code></li><li><code>is.ignore(size, delim)</code></li><li><code>os.write(source, size)</code></li></ul><p>随机读写（<code>p</code> 代表<strong>写</strong>，<code>g</code>代表<strong>读</strong>，但实际上操作的是同一个标志，本没有什么区别）：</p><ul><li><code>tellg()</code> 获取当前位置</li><li><code>seekg(pos)</code> 移动当前位置</li><li><code>seekg(off, from)</code></li></ul><h1 id="用于大型程序的工具-tools-for-large-programs">用于大型程序的工具Tools for Large Programs</h1><h2 id="异常处理">异常处理</h2><p>当一个异常发生时，函数会返回并向上传递异常，直到被捕捉或退出程序，这个过程叫<strong>堆栈展开stackunwinding</strong>，在该过程中，局部对象的析构函数会被调用，所以要注意向异常传递的指针所指向的对象在异常处理时是否存在</p><p>如果一个 <code>catch</code> 无法完全解决问题，需要<strong>再抛出异常rethrow</strong>，方法很简单：<code>throw;</code></p><p>捕捉所有异常的方法 <code>catch(...)</code></p><p><strong>函数 try 块 function try block</strong> 能够将<code>catch</code> 与语句和构造函数的初始化阶段结合起来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">Blob::<span class="hljs-built_in">Blob</span>(std::initializer_list&lt;<span class="hljs-type">int</span>&gt; il) <span class="hljs-keyword">try</span> :<br><span class="hljs-built_in">data</span>(std::make_shared&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;(il)) &#123; &#125;<br><span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::bad_alloc &amp;e) &#123; <span class="hljs-built_in">handle_out_of_memory</span>(e); &#125;<br></code></pre></td></tr></table></figure><p><code>noexcept(true)</code>表示这个函数<strong>不会</strong>抛出异常，<code>noexcept(false)</code>表示这个函数可能抛出异常，<code>noexcept(函数)</code>可以判断某个函数是否会抛出异常，通常用于定义一个是否抛出异常取决于函数<code>g()</code> 的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(<span class="hljs-keyword">noexcept</span>(g()))</span></span>;<br></code></pre></td></tr></table></figure><p>异常也有继承的层次结构，可以自定义异常类型</p><h2 id="命名空间">命名空间</h2><p>为了防止全局命名空间造成的<strong>命名空间污染 namespacepollution</strong>，引入了<strong>命名空间 namespace</strong>用于防止命名冲突</p><p>命名空间的定义中包含着各命名的声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> cpp &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sales_data</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cpp::Sales_data s;<br></code></pre></td></tr></table></figure><p>命名空间的定义可以被分到多个文件中</p><p>在全局作用域定义的名字被定义在<strong>全局命名空间 globalnamespace</strong> 中，显式的使用方法为：<code>::成员名</code></p><p>命名空间可以嵌套</p><p><strong>内联命名空间 inline namespace</strong>中的名字可以不需要命名空间名限定即可使用</p><p><strong>匿名命名空间 unnamed namespace</strong>中的名字只会局限于当前文件，无法显式指定，用于替代 <code>static</code>来是名称局限于当前文件中</p><p><strong>命名空间别名 namespace alias</strong>用于定义某命名空间的缩写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> primer = cplusplus_primer;<br></code></pre></td></tr></table></figure><ul><li><strong>using 声明 using declaration</strong>每次只引入一个命名空间中的成员</li><li><strong>using 指令 using directive</strong>一次引入了所有的成员</li><li>推荐使用前者，因为如果发生了名称冲突，则会在编译时报错，而后者是在运行时报错，且更容易发生冲突</li></ul><p>注意到这种写法是允许的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">operator</span>&gt;&gt;(std::cin, s);<br></code></pre></td></tr></table></figure><p>其中的 <code>operator</code> 前并没有加上 <code>std::</code>也能正常运行，因为首先会在对象 <code>s</code> 和 <code>cin</code>定义的作用域中查找相关的 <code>operator</code></p><p>因此，<code>std::move</code> 和 <code>std::forward</code>通常要连着前面的限定一起写，因为如果使用 <code>using std::move</code>的话，一开始并不是在 <code>std</code> 命名空间中查找 <code>move</code>函数的，而 <code>move</code>是个非常常见的名称，容易被误定义过。为了避免这种事，一定要连上<code>std::</code></p><h2 id="多重和虚拟继承">多重和虚拟继承</h2><p>一个多继承的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Panda</span> : <span class="hljs-keyword">public</span> Bear, <span class="hljs-keyword">public</span> Endangered &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>其构造函数的写法和平常的没什么区别：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">Panda::<span class="hljs-built_in">Panda</span>(std::string name, <span class="hljs-type">bool</span> onExhibit)<br>    : <span class="hljs-built_in">Bear</span>(name, onExhibit, <span class="hljs-string">&quot;Panda&quot;</span>)<br>      <span class="hljs-built_in">Endangered</span>(Endangered::critical) &#123; &#125;<br></code></pre></td></tr></table></figure><p>最终基类一定第一个初始化，然后按声明的顺序</p><p>如果有不同的基类的相同名字的成员，则必须指定是哪个基类的成员</p><p>注意到 <code>Bear</code> 和 <code>Endangered</code> 继承了相同的基类<code>ZooAnimal</code>，为了防止同时继承了这两个类的派生类存在多个<code>ZooAnimal</code> 部分，需要将这两个类声明为<strong>虚继承 virtualinheritance</strong>，那个共同的基类叫<strong>虚基类 virtual baseclass</strong></p><p>声明方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bear</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> ZooAnimal &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>虚继承中构造函数保证了虚基类最先初始化，且只被初始化一次</p><h1id="专门的工具和技术-specialized-tools-and-techniques">专门的工具和技术Specialized Tools and Techniques</h1><h2 id="控制内存分配">控制内存分配</h2><p>new 表达式构造了对象并调用 new 函数分配内存</p><p>delete 同理</p><h2 id="运行时类型识别">运行时类型识别</h2><p><strong>运行时类型识别 run-time type identification(RTTI)</strong>通过两个运算符提供：</p><ul><li><code>typeid</code> 返回给定表达式的类型</li><li><code>dynamic_cast</code>操作符将指向基类的指针或引用转换为指向派生类的指针或引用</li></ul><p>对于指针，<code>dynamic_cast</code> 失败会返回<code>nullptr</code>，故一般用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (Derived *dp = <span class="hljs-built_in">dynamic_cast</span>&lt;Derived*&gt;(bp)) &#123;<br>    <br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>对于引用，则抛出 <code>bad_cast</code> 异常</p><p>注意指针的 <code>typeid</code> 返回的是编译时的类型</p><h2 id="枚举">枚举</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">color</span> &#123;red, yellow, green&#125;; <span class="hljs-comment">// 无作用域的枚举</span><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">peppers</span> &#123;red, yellow, green&#125;; <span class="hljs-comment">// 有作用域的枚举</span><br>color eyes = green; <span class="hljs-comment">// 无作用域的枚举可以直接使用</span><br>peppers p2 = peppers::red; <span class="hljs-comment">// 有作用域的枚举必须显式指定</span><br></code></pre></td></tr></table></figure><p>默认情况下从 0 开始，每次加 1，可以在定义时指定每个枚举量的值</p><p>枚举量的值是一个 <code>constexpr</code> 的量</p><p>我们可以指定枚举量的类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">intValues</span> : <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br></code></pre></td></tr></table></figure><h2 id="类成员指针">类成员指针</h2><p>针对数据成员的指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> string Screen::*pdata = &amp;Screen::contents; <span class="hljs-comment">// 定义</span><br><span class="hljs-keyword">auto</span> s = myScreen.*pdata; <span class="hljs-comment">// 使用</span><br></code></pre></td></tr></table></figure><p>当然，也可以是成员函数的指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">char</span> (Screen::*pmf2)(Screen::pos, Screen::pos) <span class="hljs-type">const</span> = &amp;Screen::get;<br></code></pre></td></tr></table></figure><p>可以通过 <code>function&lt;&gt;</code>将其转换为一个可调用对象，或者直接使用 <code>mem_fn</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">find_if</span>(svec.<span class="hljs-built_in">begin</span>(), svec.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">mem_fn</span>(&amp;string::empty));<br></code></pre></td></tr></table></figure><h2 id="嵌套类">嵌套类</h2><p>在类中声明另一个类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextQuery</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">QueryResult</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在外部定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextQuery</span>::QueryResult &#123;<br>    <span class="hljs-built_in">QueryResult</span>(std::string);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1
        
      
    
    </summary>
    
    
      <category term="工具" scheme="https://old-driver-zero.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="C++" scheme="https://old-driver-zero.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Makefile</title>
    <link href="https://old-driver-zero.github.io/posts/6441a1ac.html"/>
    <id>https://old-driver-zero.github.io/posts/6441a1ac.html</id>
    <published>2024-04-10T06:59:51.000Z</published>
    <updated>2024-04-20T02:02:55.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="介绍">介绍</h1><p>Makefile 的基本规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">target ... : prerequisites ...<br>    recipe<br>    ...<br>    ...<br></code></pre></td></tr></table></figure><ul><li><code>target</code>：可以是一个 objectfile（目标文件），也可以是一个可执行文件，还可以是一个标签（label）</li><li><code>prerequisites</code>：生成该 target 所依赖的文件和/或target</li><li><code>recipe</code>：该 target 要执行的命令（任意的 shell命令）</li></ul><p>简单来说就是指定了一个依赖关系</p><p>输入 <code>make</code> 命令时，是这么工作的：</p><ol type="1"><li><code>make</code> 会在当前目录下找名字叫 <code>Makefile</code> 或<code>makefile</code> 的文件</li><li>如果找到，它会找文件中的第一个目标文件（target），并把这个文件作为最终的目标文件</li><li>如果该文件不存在，或其所依赖的后面的 <code>.o</code>文件的文件修改时间要比这个文件新，则执行后面所定义的命令来生成这个文件</li><li>如果所依赖的 <code>.o</code> 文件也不存在，那么 make会在当前文件中找目标为 <code>.o</code>文件的依赖性，如果找到则再根据那一个规则生成 <code>.o</code> 文件</li><li>最后用 <code>.o</code> 文件生成可执行文件</li></ol><p>在 Makefile 中可以声明变量并使用变量：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">OBJ = main.o kbd.o command.o display.o<br>edit : <span class="hljs-variable">$(objects)</span><br>    cc -o edit <span class="hljs-variable">$(objects)</span><br></code></pre></td></tr></table></figure><p>事实上，make 可以自动推导文件及依赖关系后的命令，如</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">kbd.o : kbd.c defs.h command.h<br>    cc -c kbd.c<br></code></pre></td></tr></table></figure><p>可以简化为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">kbd.o : defs.h command.h<br></code></pre></td></tr></table></figure><p>每个 Makefile 都应该在最后写一个清空目标文件的规则，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">.PHONY : clean<br>clean :<br>    -rm edit <span class="hljs-variable">$(objects)</span><br></code></pre></td></tr></table></figure><p>当然，Makefile可以为任意的文件名，但在使用时必须指定：<code>make -f Make.Solaris</code></p><p>还可以把其他 Makefile 包含进来，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">include</span> 文件名...<br></code></pre></td></tr></table></figure><p>其寻找的位置是：</p><ol type="1"><li>当前目录</li><li><code>-I</code> 参数指定的目录</li><li><code>&lt;prefix&gt;/include</code></li></ol><h1 id="书写规则">书写规则</h1><p>make 支持三个通配符：<code>*</code>，<code>?</code> 和<code>~</code></p><p><code>VPATH</code> 变量指定了 make 寻找文件的目录，还有<code>vpath</code> 功能类似，但是更灵活：</p><ul><li><code>vpath &lt;pattern&gt; &lt;directories&gt;</code>：为符合模式<code>&lt;pattern&gt;</code> 的文件指定搜索目录<code>&lt;directories&gt;</code></li><li><code>vpath &lt;pattern&gt;</code>：清除符合模式<code>&lt;pattern&gt;</code> 的文件的搜索目录</li><li><code>vpath</code>：清除所有已被设置好了的文件搜索目录</li></ul><p>可以连续使用 <code>vpath</code> 语句</p><p>因为不生成 <code>clean</code>文件，故这是一个<strong>伪目标</strong>，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">.PHONY : cleanall cleanobj cleandiff<br><br>cleanall : cleanobj cleandiff<br>    rm program<br><br>cleanobj :<br>    rm *.o<br><br>cleandiff :<br>    rm *.diff<br></code></pre></td></tr></table></figure><p>Makefile 的规则中的目标可以不止一个，如</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">bigoutput littleoutput : text.g<br>    generate text.g -<span class="hljs-variable">$(<span class="hljs-built_in">subst</span> output,,<span class="hljs-variable">$@</span>)</span> &gt; <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p><strong>静态模式</strong>可以更加容易地定义多目标的规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">&lt;targets ...&gt; : &lt;target-pattern&gt; : &lt;prereq-patterns ...&gt;<br>    &lt;commands&gt;<br>    ...<br></code></pre></td></tr></table></figure><ul><li><code>targets</code> 定义了一系列的目标文件，可以有通配符</li><li><code>target-pattern</code> 是指明了 <code>targets</code>的模式，也就是的目标集模式</li><li><code>prereq-patterns</code> 是目标的依赖模式，它对<code>target-pattern</code> 形成的模式再进行一次依赖目标的定义</li></ul><p>大多数的 C/C++ 编译器都支持一个 <code>-M</code>的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系</p><p>利用这个特性，我们可以为每一个 <code>name.c</code> 的文件都生成一个<code>name.d</code> 的 Makefile 文件， <code>.d</code> 文件中就存放对应<code>.c</code> 文件的依赖关系</p><h1 id="书写命令">书写命令</h1><p>通常，make 会把执行的命令显示到屏幕上，如果不想显示，则加上<code>@</code>，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">@echo 正在编译XXX模块......<br></code></pre></td></tr></table></figure><p>当然，加上参数 <code>-s</code> 会全面禁止命令的显示</p><p>如果要让上一条命令的结果应用在下一条命令上，则应该使用 <code>;</code>分割这两条命令，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">exec:</span><br>    cd /home/hchen; pwd<br></code></pre></td></tr></table></figure><p>make 默认使用的 shell 是 <code>/bin/sh</code></p><p>make会检测每个命令的返回码，如果失败，则会终止执行当前规则；为了让其忽略出错，可以在命令前加<code>-</code>，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">clean:</span><br>    -rm -f *.o<br></code></pre></td></tr></table></figure><p>相应的全局方法是加上参数 <code>-i</code></p><p>可以嵌套执行 Makefile 文件，如总控 Makefile 可以这样写：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">subsystem:</span><br>    cd subdir &amp;&amp; <span class="hljs-variable">$(MAKE)</span><br></code></pre></td></tr></table></figure><p>其作用是执行 <code>subdir</code> 目录下的 Makefile 文件</p><p>默认情况下总控中定义的变量不会传递给下级的Makefile，如果想要传递，可以：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">export</span> &lt;variable ...&gt;;<br></code></pre></td></tr></table></figure><p>如果要传递所有的变量，则直接使用 <code>export</code></p><p>加上 <code>-w</code> 参数可以看到当前的工作目录</p><p>我们可以为相同的命令序列定义一个变量：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">define</span> run-yacc<br>yacc <span class="hljs-variable">$(<span class="hljs-built_in">firstword</span> <span class="hljs-variable">$^</span>)</span><br>mv y.tab.c <span class="hljs-variable">$@</span><br><span class="hljs-keyword">endef</span><br></code></pre></td></tr></table></figure><h1 id="使用变量">使用变量</h1><p>定义变量的方法：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">foo = <span class="hljs-variable">$(bar)</span><br>bar = <span class="hljs-variable">$(ugh)</span><br>ugh = Huh?<br></code></pre></td></tr></table></figure><p>注意到上面那种定义顺序是合法的，当然还有另一种方法避免了这种情况：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">x := foo<br>y := <span class="hljs-variable">$(x)</span> bar<br></code></pre></td></tr></table></figure><p>一种定义一个空格的变量的方法：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">nullstring :=<br>space := <span class="hljs-variable">$(nullstring)</span> <span class="hljs-comment"># 通过注释指定了一个空格</span><br></code></pre></td></tr></table></figure><p><code>?=</code> 表示如果没有定义过，则定义；反之，则什么都不做</p><p><code>$(var:a=b)</code>：把变量 <code>var</code> 中所有结尾的<code>a</code> 替换成<code>b</code>。这里的“结尾”意思是“空格”或是“结束符”。</p><p>可以使用 <code>+=</code> 给变量追加值</p><p>如果有变量是 make 的命令行参数设置的，则 Makefile中对这个变量的赋值会被忽略，如果想设置，可以在前面加<code>override</code></p><p>之前定义的变量都是“全局变量”，也可以为某个目标设置局部变量，其作用范围只在这条规则以及连带规则中：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">&lt;target ...&gt; : &lt;variable-assignment&gt;;<br></code></pre></td></tr></table></figure><p>还支持<strong>模式变量</strong>，即可以把变量定义在所有符合该模式的目标上：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">&lt;pattern ...&gt;; : &lt;variable-assignment&gt;;<br></code></pre></td></tr></table></figure><h1 id="使用条件判断">使用条件判断</h1><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(CC)</span>,gcc)<br>    <span class="hljs-variable">$(CC)</span> -o foo <span class="hljs-variable">$(objects)</span> <span class="hljs-variable">$(libs_for_gcc)</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-variable">$(CC)</span> -o foo <span class="hljs-variable">$(objects)</span> <span class="hljs-variable">$(normal_libs)</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>除了 <code>ifeq</code> 以外，还有<code>ifneq</code>、<code>ifdef</code>、<code>ifndef</code></p><h1 id="使用函数">使用函数</h1><p>函数调用类似于变量使用：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">$(&lt;function&gt; &lt;arguments&gt;)<br></code></pre></td></tr></table></figure><p>字符串替换函数 <code>subst</code>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">subst</span> &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</span><br></code></pre></td></tr></table></figure><p>把字串 <code>&lt;text&gt;</code> 中的 <code>&lt;from&gt;</code>字符串替换成 <code>&lt;to&gt;</code></p><p>还有相应的模式版本 <code>patsubst</code>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span><br></code></pre></td></tr></table></figure><p>去空格函数 <code>strip</code>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">strip</span> &lt;string&gt;)</span><br></code></pre></td></tr></table></figure><p>去掉 <code>&lt;string&gt;</code> 字串中开头和结尾的空字符</p><p>查找字符串函数 <code>findstring</code>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">findstring</span> &lt;find&gt;,&lt;in&gt;)</span><br></code></pre></td></tr></table></figure><p><code>sort</code> 排序（升序），注意同时会去重</p><p>取单词串函数 <code>wordlist</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">wordlist</span> &lt;start&gt;,&lt;end&gt;,&lt;text&gt;)</span><br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th>名称</th><th>功能</th><th>名称</th><th>功能</th></tr></thead><tbody><tr class="odd"><td><code>filter</code></td><td>过滤</td><td><code>filter-out</code></td><td>反过滤</td></tr><tr class="even"><td><code>word</code></td><td>单词个数统计</td><td><code>firstword</code></td><td>首单词</td></tr><tr class="odd"><td><code>dir</code></td><td>取目录</td><td><code>notdir</code></td><td>取非目录</td></tr><tr class="even"><td><code>suffix</code></td><td>取后缀</td><td><code>basename</code></td><td>取前缀</td></tr><tr class="odd"><td><code>addsuffix</code></td><td>加后缀</td><td><code>addprefix</code></td><td>加前缀</td></tr></tbody></table><p>连接函数 <code>join</code>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">join</span> &lt;list1&gt;,&lt;list2&gt;)</span><br></code></pre></td></tr></table></figure><p>功能：把 <code>&lt;list2&gt;</code>中的单词<strong>对应地</strong>加到 <code>&lt;list1&gt;</code>的单词后面</p><p>用来做循环的 <code>foreach</code>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</span><br></code></pre></td></tr></table></figure><p>把参数 <code>&lt;list&gt;</code> 中的单词逐一取出放到参数<code>&lt;var&gt;</code> 所指定的变量中，然后再执行<code>&lt;text&gt;</code> 所包含的表达式</p><p><code>if</code> 函数</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">if</span> &lt;condition&gt;,&lt;then-part&gt;)</span><br></code></pre></td></tr></table></figure><p><code>call</code> 可以用来创建新的参数化：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">reverse =  $(2) $(1)<br>foo = <span class="hljs-variable">$(<span class="hljs-built_in">call</span> reverse,a,b)</span><br></code></pre></td></tr></table></figure><p><code>origin</code> 告诉你变量是从哪里来的</p><p><code>shell</code> 函数参数是 shell命令，和反引号功能一致，注意其会影响性能</p><p>还有控制函数：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">error</span> &lt;text ...&gt;)</span><br><span class="hljs-variable">$(<span class="hljs-built_in">warning</span> &lt;text ...&gt;)</span><br></code></pre></td></tr></table></figure><h1 id="make-的运行">make 的运行</h1><p><code>make</code> 的时候可以指定目标</p><h1 id="隐含规则">隐含规则</h1><p>make 中有一些隐含规则，不必写出来，例如编译 C 语言的：</p><p><code>&lt;n&gt;.o</code> 的目标的依赖目标会自动推导为<code>&lt;n&gt;.c</code> ，并且其生成命令是<code>$(CC) –c $(CPPFLAGS) $(CFLAGS)</code></p><p>隐含规则使用的变量：</p><ul><li><code>AR</code>：函数库打包程序，默认命令是 <code>ar</code></li><li><code>AS</code>：汇编语言编译程序，默认命令是 <code>as</code></li><li><code>CC</code>：C 语言编译程序，默认命令是 <code>cc</code></li><li><code>CXX</code>：C++语言编译程序，默认命令是 <code>g++</code></li></ul><p>相关命令的参数：</p><ul><li><code>CFLAGS</code> : C 语言编译器参数</li><li><code>CXXFLAGS</code> : C++语言编译器参数</li><li><code>CPPFLAGS</code> : C 预处理器参数</li><li><code>LDFLAGS</code> : 链接器参数</li></ul><p><strong>模式规则</strong>：使用 <code>%</code> 通配</p><p><strong>自动化变量</strong>及其说明：</p><ul><li><code>$@</code>：表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，<code>$@</code> 就是匹配于目标中模式定义的集合</li><li><code>$%</code>：仅当目标是函数库文件中，表示规则中的目标成员名</li><li><code>$&lt;</code>：依赖目标中的第一个目标名字。如果依赖目标是以模式（即<code>%</code> ）定义的，那么 <code>$&lt;</code>将是符合模式的一系列的文件集。注意，其是一个一个取出来的</li><li><code>$?</code>：所有比目标新的依赖目标的集合</li><li><code>$^</code>：所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那么这个变量会去除重复的依赖目标，只保留一份</li><li><code>$+</code>：这个变量很像 <code>$^</code>，也是所有依赖目标的集合。只是它不去除重复的依赖目标</li></ul><h1 id="使用-make-更新函数库文件">使用 make 更新函数库文件</h1><p>一个函数库文件由多个文件组成，可以用如下格式指定函数库文件及其组成:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">archive(member)<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;介绍&quot;&gt;介绍&lt;/h1&gt;
&lt;p&gt;Makefile
        
      
    
    </summary>
    
    
      <category term="工具" scheme="https://old-driver-zero.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Makefile" scheme="https://old-driver-zero.github.io/tags/Makefile/"/>
    
      <category term="编译" scheme="https://old-driver-zero.github.io/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>打倒孔家店，救出孔夫子</title>
    <link href="https://old-driver-zero.github.io/posts/2069534c.html"/>
    <id>https://old-driver-zero.github.io/posts/2069534c.html</id>
    <published>2024-04-10T05:07:32.000Z</published>
    <updated>2024-04-11T00:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="hide-block"><button type="button" class="hide-button" style="">~~抡语~~    </button><div class="hide-content"><blockquote><p>既来之，则安之。</p></blockquote><p>既然来到了这里，那么就安葬在这里吧。</p><blockquote><p>子不语怪、力、乱、神。</p></blockquote><p>夫子不想说话，施展起怪力将人打的神志不清。</p><blockquote><p>朝闻道，夕死可矣。</p></blockquote><p>早上听到我来了，今晚你就得死。</p><blockquote><p>三人行，必有我师焉。</p></blockquote><p>有三个人，只要其中有一个是我，战力就相当于一个师。</p><blockquote><p>父母在，不远游，游必有方。</p></blockquote><p>你父母在我手里，你跑不了的，就算你跑了，我也有办法把你抓回来！</p></div></div><h1 id="论语">论语</h1><p>我小时候认为孔子说的话很有道理，也不管究竟是不是他说过的话，一律奉为圭臬。长大后有了独立思考的能力，并了解了一些历史，觉得孔子的话根本就不对。其之所以流行，只是迎合了统治阶级的需要，是用来麻痹老百姓的。再后来读了《论语》，理性思考之下，才发现我以前对孔子有很多的误解。他的很多思想直到现在都闪烁着光芒。数千年来，他为董仲舒所用、为朱熹所用、为陈独秀所用，他从一个“山东大汉”成为了一个“文弱书生”，是时候为他正名了，打倒那些人粉饰过后的“孔家店”，救出真正的那个“孔夫子”。</p><blockquote><p>以德报怨，何以报德？以直报怨，以德报德。</p></blockquote><blockquote><p>要断章取义 —— 节选自《不要断章取义》</p></blockquote><p>孔子的这句话无疑是被曲解最严重的，以至于“以德报怨”成了一个成语。实际上这是老子的观点，却因为这句话被按在了孔子的头上，成了他千百年来都无法洗刷掉的“罪行”。</p><p>或许最好的为人之道就是如孔子所说的，尤其是各类作品中充斥的“圣母婊”和现实中麻木不仁的当下，“以直报怨，以德报德”是两难博弈的最优解。</p><blockquote><p>父母在，不远游，游必有方。</p></blockquote><p>和上一句一样是断章取义的受害者，孔子的原句说的很完美，既鼓励孝顺父母，又讲了例外情况的做法。</p><blockquote><p>民可使由之不可使知之</p></blockquote><p>这句话是孔子最具争议性的一句话，主要在于怎么断句<del>标点符号真是一个伟大的发明</del>，一般有以下两种断句方法：</p><blockquote><p>子曰：民可使由之，不可使知之。（孔夫子说：老百姓可以让他们去做事情，但是不可以让他们知道为什么要这么做。）</p><p>子曰：民可使，由之；不可使，知之。（孔夫子说：如果老百姓可以，就让他们去做事情；如果不可以，那就让他们知道为什么。）</p></blockquote><p>两种解释正好意思相反，前者支持的是愚民思想，后者支持的是教化民众。不过，对于主张“有教无类”的孔子来说，我个人更倾向于第二种解释，但似乎第一种解释才是主流。</p><p>即使孔子并不是持第二种观点，我也认为第二种观点有很大的可取之处。尤其是教育普及的现代，无关乎所谓的“民主”不“民主”，只是这种方法更高效，前者对于现代的用途充其量不过是巩固自己的统治罢了。</p><blockquote><p>刑不上大夫，礼不下庶人。</p></blockquote><p><del>等哪一天发明了时光机或者能够复活死人了，一定要让孔子把他所有的言论全部解释一遍</del></p><p>乍一看是搞区别对待，仔细看来恰恰是把“礼”和“刑”真正作为治理国家的工具的典范，实现的是真正的平等。作为贵族，应该有贵族的尊严，要自裁；而对于平民，不应该苛责，遵守的礼仪不必像贵族那样繁琐。</p><p>“子贡拒金”与“子路受牛”两个典故很有意思，孔子批评了做好事不留名的子贡，表扬了贪恋钱财的子路。这又是一个很有争议的点，而我又是支持孔子的。子贡是“无私”的，但从另一种角度来看，他又是“自私”的，因为他并没有关注到自己的社会属性。也就是说，他没有考虑到自己是一个“社会中的人”，他的一举一动都具有社会属性，其实际上向整个社会传达了一种信号。从个人的角度来看，拒绝奖赏是正确的；但从社会的角度来看，拒绝奖赏是错误的。因为这种行为拔高了做好事的门槛，所以实质上传递了一种负面的信号，让别人做好事时有所犹豫。</p><h1 id="知我罪我其惟春秋">知我罪我，其惟春秋</h1><blockquote><p>知我罪我，其惟春秋。</p></blockquote><p>历史究竟是什么，要怎样写？历来常有争议。有人认为历史是客观地记录下发生的事情，有人认为历史是由胜利者的双手所著。我比较赞同孔子（和后来的司马迁）的观点，认为历史注定要有所褒贬。我们歌颂英雄与伟人，我们唾弃奸贼与小人，我们不仅要了解历史，更应该明辨是非。当然，褒贬是建立在记录事实的基础之上的，就像太史公再怎么吹嘘李广，其记载也总是败绩；再怎么批评卫青，对其功劳也照记不误。</p><p>所以孔子早就预见到了后世会围绕着他产生重大的争议，但他还是这么做了。不同时代对孔子的评价不同，但这一点也不影响他与江河一样万古留名。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;div class=&quot;hide-block&quot;&gt;&lt;button
        
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://old-driver-zero.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="论语" scheme="https://old-driver-zero.github.io/tags/%E8%AE%BA%E8%AF%AD/"/>
    
      <category term="孔子" scheme="https://old-driver-zero.github.io/tags/%E5%AD%94%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>VS Code</title>
    <link href="https://old-driver-zero.github.io/posts/60d11614.html"/>
    <id>https://old-driver-zero.github.io/posts/60d11614.html</id>
    <published>2024-04-06T00:21:22.000Z</published>
    <updated>2024-04-11T01:36:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://code.visualstudio.com/">VS Code</a>是流行的代码编辑器，可以通过插件支持各种语句的高亮、调试、编译等</p><h1 id="设置">设置</h1><p>字体喜欢使用 <a href="https://www.jetbrains.com/lp/mono/">JetBrainsMono</a>，字号设为 14，并开启连字</p><h1 id="快捷键">快捷键</h1><table><colgroup><col style="width: 10%" /><col style="width: 37%" /><col style="width: 14%" /><col style="width: 37%" /></colgroup><thead><tr class="header"><th>功能</th><th>快捷键</th><th>功能</th><th>快捷键</th></tr></thead><tbody><tr class="odd"><td>移动行</td><td><kbd>alt</kbd> + <kbd>up</kbd> / <kbd>down</kbd></td><td>查找文件</td><td><kbd>ctrl</kbd> + <kbd>p</kbd></td></tr><tr class="even"><td>显示相关插件的命令</td><td><kbd>ctrl</kbd> + <kbd>shift</kbd> + <kbd>p</kbd> 或 <kbd>F1</kbd></td><td>多行同时添加内容（光标）</td><td><kbd>ctrl</kbd> + <kbd>alt</kbd> + <kbd>up</kbd> /<kbd>down</kbd></td></tr><tr class="odd"><td>光标跳到下一个单词</td><td><kbd>ctrl</kbd>+ <kbd>left</kbd> / <kbd>RIGHT</kbd></td><td>行增加/减少缩进</td><td><kbd>ctrl</kbd> + <kbd>[</kbd> / <kbd>]</kbd></td></tr><tr class="even"><td>隐藏底部控制面板</td><td><kbd>ctrl</kbd> + <kbd>j</kbd></td><td>显示/隐藏左侧目录栏</td><td><kbd>ctrl</kbd> + <kbd>b</kbd></td></tr></tbody></table><h1 id="语言支持">语言支持</h1><h2 id="markdown">Markdown</h2><p><ahref="https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one">MarkdownAll in One</a></p><p>几乎涵盖了大部分内容</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=shd101wyy.markdown-preview-enhanced">MarkdownPreview Enhanced</a></p><figure><img src="/illustration/VS%20Code/Markdown%20Preview%20Enhanced.webp"alt="Markdown Preview Enhanced" /><figcaption aria-hidden="true">Markdown Preview Enhanced</figcaption></figure><p>Markdown 预览</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=oijaz.unicode-latex">UnicodeLatex</a></p><p>将 Latex 符号转化为 Unicode 符号，更容易辨认</p><h2 id="javascripttypescript-react">JavaScript/TypeScript + React</h2><p>原生支持（毕竟 VS Code 就是用 TypeScript 编写的，所有的扩展都是用 JS写的，但可以添加一些提高开发效率的代码片段</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=xabikos.JavaScriptSnippets">JavaScript(ES6) code snippets</a></p><p>支持 JS/TS，JSX/TSX，html 等</p><p>摘录一些常用的：</p><p><strong>导入与导出</strong></p><table><colgroup><col style="width: 8%" /><col style="width: 15%" /><col style="width: 76%" /></colgroup><thead><tr class="header"><th>触发方式</th><th>功能</th><th>示例</th></tr></thead><tbody><tr class="odd"><td><code>imp</code></td><td>导入整个模块</td><td><code>import fs from 'fs';</code></td></tr><tr class="even"><td><code>imn</code></td><td>匿名模块导入</td><td><code>import 'animate.css'</code></td></tr><tr class="odd"><td><code>imd</code></td><td>使用解构导入</td><td><code>import &#123;rename&#125; from 'fs';</code></td></tr><tr class="even"><td><code>rqr</code></td><td>需要包</td><td><code>require('');</code></td></tr><tr class="odd"><td><code>req</code></td><td>以 const 需要包</td><td><code>const packageName = require('packageName');</code></td></tr><tr class="even"><td><code>mde</code></td><td>默认导出</td><td><code>module.exports = &#123;&#125;;</code></td></tr><tr class="odd"><td><code>env</code></td><td>导出命名变量</td><td><code>export const nameVariable = localVariable;</code></td></tr><tr class="even"><td><code>enf</code></td><td>导出命名函数</td><td><code>export const log = (parameter) =&gt; &#123; console.log(parameter);&#125;;</code></td></tr><tr class="odd"><td><code>edf</code></td><td>默认导出函数</td><td><code>export default function fileName (parameter)&#123; console.log(parameter);&#125;;</code></td></tr></tbody></table><p><strong>多样的方法</strong></p><table><thead><tr class="header"><th>触发方式</th><th>功能</th><th>示例</th></tr></thead><tbody><tr class="odd"><td><code>fre→</code></td><td>forEach</td><td><code>array.forEach(currentItem =&gt; &#123;&#125;)</code></td></tr><tr class="even"><td><code>fof→</code></td><td>for ... of for</td><td><code>(const item of object) &#123;&#125;</code></td></tr><tr class="odd"><td><code>fin→</code></td><td>for ... in</td><td><code>for(const item in object) &#123;&#125;</code></td></tr><tr class="even"><td><code>anfn→</code></td><td>创建匿名函数</td><td><code>(params) =&gt; &#123;&#125;</code></td></tr><tr class="odd"><td><code>nfn→</code></td><td>创建命名函数</td><td><code>const add = (params) =&gt; &#123;&#125;</code></td></tr><tr class="even"><td><code>dob→</code></td><td>解构对象</td><td><code>const &#123;rename&#125; = fs</code></td></tr><tr class="odd"><td><code>dar→</code></td><td>解构数组</td><td><code>const [first, second] = [1,2]</code></td></tr><tr class="even"><td><code>sti→</code></td><td>设置间隔</td><td><code>setInterval(() =&gt; &#123;&#125;);</code></td></tr><tr class="odd"><td><code>sto→</code></td><td>设置时间</td><td><code>setTimeout(() =&gt; &#123;&#125;);</code></td></tr></tbody></table><p><strong>控制台方法</strong></p><table><colgroup><col style="width: 11%" /><col style="width: 34%" /><col style="width: 53%" /></colgroup><thead><tr class="header"><th>触发方式</th><th>功能</th><th>示例</th></tr></thead><tbody><tr class="odd"><td><code>clg→</code></td><td>console log</td><td><code>console.log(object)</code></td></tr><tr class="even"><td><code>clo→</code></td><td>console log 对象及其名字</td><td><code>console.log('object :&gt;&gt; ', object);</code></td></tr></tbody></table><p><ahref="https://marketplace.visualstudio.com/items?itemName=dsznajder.es7-react-js-snippets">ES7+React/Redux/React-Native snippets</a></p><p>React 的代码片段，参见 <ahref="https://github.com/r5n-dev/vscode-react-javascript-snippets/blob/185bb91a0b692c54136663464e8225872c434637/docs/Snippets.md">vscode-react-javascript-snippets</a></p><p><ahref="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">ESLint</a></p><p>向 VS Code 添加 ESLint 支持</p><p>提示是英文，可以改为中文 <ahref="https://marketplace.visualstudio.com/items?itemName=maggie.eslint-rules-zh-plugin">ESLintChinese Rules</a></p><h2 id="python">Python</h2><p>相对于编写大型项目的 PyCharm 和分析数据的 Jupyter Notebook，VS Code中的 Python 更适合小型项目的开发</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=ms-python.python">Python</a></p><p>Python 的基础支持</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=KevinRose.vsc-python-indent">PythonIndent</a></p><p>纠正 VS Code 中 Python 的缩进</p><h1 id="扩展推荐">扩展推荐</h1><h2 id="主题">主题</h2><p><ahref="https://marketplace.visualstudio.com/items?itemName=akamud.vscode-theme-onelight">AtomOne Light Theme</a></p><figure><img src="/illustration/VS%20Code/Atom%20One%20Light%20Theme.webp"alt="Atom One Light Theme" /><figcaption aria-hidden="true">Atom One Light Theme</figcaption></figure><p>个人比较喜欢白色主题，可能是通常在白天编程养成的</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme">MaterialIcon Theme</a></p><figure><imgsrc="/illustration/VS%20Code/Material%20Icon%20Theme-fileIcons.webp"alt="Material Icon Theme" /><figcaption aria-hidden="true">Material Icon Theme</figcaption></figure><figure><imgsrc="/illustration/VS%20Code/Material%20Icon%20Theme-folderIcons.webp"alt="Material Icon Theme" /><figcaption aria-hidden="true">Material Icon Theme</figcaption></figure><p>图标库</p><h2 id="功能强化">功能强化</h2><p><ahref="https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans">Chinese(Simplified) (简体中文) Language Pack for Visual Studio Code</a></p><p>中文语言包</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=adpyke.codesnap">CodeSnap</a></p><figure><img src="/illustration/VS%20Code/CodeSnap.webp" alt="CodeSnap" /><figcaption aria-hidden="true">CodeSnap</figcaption></figure><p>代码截图</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=alefragnani.project-manager">ProjectManager</a></p><p>可以简单地在几个项目之间切换</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=ms-vscode.hexeditor">HexEditor</a></p><figure><img src="/illustration/VS%20Code/Hex%20Editor.webp" alt="Hex Editor" /><figcaption aria-hidden="true">Hex Editor</figcaption></figure><p>以十六进制查看二进制文件</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner">CodeRunner</a></p><p>可以一键运行多种语言的代码，也可以只运行选中部分的代码</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=ryu1kn.partial-diff">PartialDiff</a></p><figure><img src="/illustration/VS%20Code/Partial%20Diff.webp"alt="Partial Diff" /><figcaption aria-hidden="true">Partial Diff</figcaption></figure><p>可以部分比较代码</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=uctakeoff.vscode-counter">VSCode Counter</a></p><figure><img src="/illustration/VS%20Code/VS%20Code%20Counter.webp"alt="VS Code Counter" /><figcaption aria-hidden="true">VS Code Counter</figcaption></figure><p>统计项目/目录中代码的行数，并分别以语言和目录等统计</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=usernamehw.errorlens">ErrorLens</a></p><figure><img src="/illustration/VS%20Code/Error%20Lens.webp" alt="Error Lens" /><figcaption aria-hidden="true">Error Lens</figcaption></figure><p>突出错误提示</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=chrmarti.regex">RegexPreviewer</a></p><figure><img src="/illustration/VS%20Code/Regex%20Previewer..webp"alt="Regex Previewer" /><figcaption aria-hidden="true">Regex Previewer</figcaption></figure><p>预览正则表达式的效果</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=WakaTime.vscode-wakatime">WakaTime</a></p><figure><img src="/illustration/VS%20Code/WakaTime.webp" alt="WakaTime" /><figcaption aria-hidden="true">WakaTime</figcaption></figure><p>统计编程时间</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=tomoki1207.pdf">vscode-pdf</a></p><figure><img src="/illustration/VS%20Code/vscode-pdf.webp" alt="vscode-pdf" /><figcaption aria-hidden="true">vscode-pdf</figcaption></figure><p>支持直接查看 pdf</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=Gruntfuggly.todo-tree">TodoTree</a></p><figure><img src="/illustration/VS%20Code/Todo%20Tree.webp" alt="Todo Tree" /><figcaption aria-hidden="true">Todo Tree</figcaption></figure><p>以树视图查看并高亮 TODO，FIXME 等注释</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=wayou.vscode-todo-highlight">TODOHighlight</a></p><figure><img src="/illustration/VS%20Code/TODO%20Highlight.webp"alt="TODO Highlight" /><figcaption aria-hidden="true">TODO Highlight</figcaption></figure><p>类似于上面的，但是只有高亮的效果</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=ZainChen.json">json</a></p><figure><img src="/illustration/VS%20Code/json.webp" alt="json" /><figcaption aria-hidden="true">json</figcaption></figure><p>在侧边栏添加了快速查看和操作 JSON 的按钮</p><h2 id="git-集成插件">Git 集成插件</h2><p><ahref="https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-pull-request-github">GitHubPull Requests</a></p><figure><img src="/illustration/VS%20Code/GitHub%20Pull%20Requests.webp"alt="GitHub Pull Requests" /><figcaption aria-hidden="true">GitHub Pull Requests</figcaption></figure><p>查看 GitHub 上的 Pull Request 和 Issue</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph">GitGraph</a></p><p>Git 图形化显示和操作</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=waderyan.gitblame">GitBlame</a></p><figure><img src="/illustration/VS%20Code/Git%20Blame.webp" alt="Git Blame" /><figcaption aria-hidden="true">Git Blame</figcaption></figure><p>可以在状态栏看到当前所选行的 git blame 信息</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=codezombiech.gitignore">gitignore</a></p><p>通过输入 <code>Add gitignore</code> 从 <ahref="https://github.com/github/gitignore">github/gitignore</a>存储库中拉取 <code>.gitignore</code>模板来添加本地文件<code>.gitignore</code></p><p><ahref="https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens">GitLens— Git supercharged</a></p><p>功能更多，更强，但是要付费</p><h2 id="开发效率">开发效率</h2><p><ahref="https://marketplace.visualstudio.com/items?itemName=wmaurer.change-case">change-case</a></p><p>改变命名风格</p><table><thead><tr class="header"><th>命令</th><th>变量名</th><th>命令</th><th>变量名</th></tr></thead><tbody><tr class="odd"><td>camel</td><td><code>findFirst</code></td><td>constant</td><td><code>FIND_FIRST</code></td></tr><tr class="even"><td>dot</td><td><code>find.first</code></td><td>kebab 或 param</td><td><code>find-first</code></td></tr><tr class="odd"><td>lower</td><td>小写</td><td>lowerFirst</td><td>首字母小写</td></tr><tr class="even"><td>upper</td><td>大写</td><td>upperFirst</td><td>首字母大写</td></tr><tr class="odd"><td>no</td><td><code>find first</code></td><td>pascal</td><td><code>FindFirst</code></td></tr><tr class="even"><td>path</td><td><code>find/first</code></td><td>sentence</td><td><code>Find first</code></td></tr><tr class="odd"><td>snake</td><td><code>find_first</code></td><td>swap</td><td>大小写反转</td></tr><tr class="even"><td>title</td><td><code>find_first</code></td><td></td><td></td></tr></tbody></table><p><ahref="https://marketplace.visualstudio.com/items?itemName=unbug.codelf">Codelf</a></p><p>给变量取名</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode">Prettier- Code formatter</a></p><p>自动格式化代码</p><p>还有支持 ESLint 的版本 <ahref="https://marketplace.visualstudio.com/items?itemName=rvest.vs-code-prettier-eslint">PrettierESLint</a></p><ul><li>需要在项目中安装依赖：<code>npm install -D prettier eslint prettier-eslint</code></li><li>对于TypeScript，<strong>还</strong>需要安装：<code>npm install -D @typescript-eslint/parser typescript</code></li></ul><p><ahref="https://marketplace.visualstudio.com/items?itemName=foxundermoon.shell-format">shell-format- Visual Studio Marketplace</a></p><p>shell scripts, Dockerfile, gitignore, dotenv, /etc/hosts, jvmoptions等的格式化工具</p><p>使用方法：输入 <code>Format Document</code></p><p><ahref="https://marketplace.visualstudio.com/items?itemName=kisstkondoros.vscode-gutter-preview">Imagepreview</a></p><figure><img src="/illustration/VS%20Code/Image%20preview.webp"alt="Image preview" /><figcaption aria-hidden="true">Image preview</figcaption></figure><p>图片预览</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=aaron-bond.better-comments">BetterComments</a></p><p>可以给注释分类，分别是</p><ul><li><code>*</code>：强调</li><li><code>!</code>：警告</li><li><code>?</code>：问题</li><li><code>TODO</code>：代办</li></ul><figure><img src="/illustration/VS%20Code/better-comments.webp"alt="better-comments" /><figcaption aria-hidden="true">better-comments</figcaption></figure><p><ahref="https://marketplace.visualstudio.com/items?itemName=oderwat.indent-rainbow">indent-rainbow</a></p><figure><img src="/illustration/VS%20Code/indent-rainbow.webp"alt="indent-rainbow" /><figcaption aria-hidden="true">indent-rainbow</figcaption></figure><p>彩虹色的缩进（写 Python 必备）</p><p>这是我比较喜欢的配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Using the light mode</span><br><span class="hljs-string">&quot;indentRainbow.indicatorStyle&quot;</span>: <span class="hljs-string">&quot;light&quot;</span>,<br><span class="hljs-comment">// we use a simple 1 pixel wide line</span><br><span class="hljs-string">&quot;indentRainbow.lightIndicatorStyleLineWidth&quot;</span>: <span class="hljs-number">1</span>,<br><span class="hljs-comment">// the same colors as above but more visible</span><br><span class="hljs-string">&quot;indentRainbow.colors&quot;</span>: [<br>    <span class="hljs-string">&quot;rgba(255,255,64,0.3)&quot;</span>,<br>    <span class="hljs-string">&quot;rgba(127,255,127,0.3)&quot;</span>,<br>    <span class="hljs-string">&quot;rgba(255,127,255,0.3)&quot;</span>,<br>    <span class="hljs-string">&quot;rgba(79,236,236,0.3)&quot;</span><br>],<br></code></pre></td></tr></table></figure><h2 id="前端开发">前端开发</h2><p><ahref="https://marketplace.visualstudio.com/items?itemName=christian-kohler.npm-intellisense">npmIntellisense</a>：在 import 语句中自动完成 npm 模块</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=ChakrounAnas.turbo-console-log">TurboConsole Log</a></p><ul><li><kbd>Ctrl</kbd>+<kbd>Alt</kbd> + <kbd>l</kbd> 选中变量之后，使用这个快捷键生成console.log</li><li><kbd>Alt</kbd>+<kbd>Shift</kbd> + <kbd>c</kbd> 注释所有 console.log</li><li><kbd>Alt</kbd>+<kbd>Shift</kbd> + <kbd>u</kbd> 启用所有 console.log</li><li><kbd>Alt</kbd>+<kbd>Shift</kbd> + <kbd>d</kbd> 删除所有 console.log</li></ul><p><ahref="https://marketplace.visualstudio.com/items?itemName=pranaygp.vscode-css-peek">CSSPeek</a>：查看 css 定义</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag">AutoRename Tag</a>：自动重命名标签</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=humao.rest-client">RESTClient</a>：发送 HTTP 请求</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=dotenv.dotenv-vscode">DotenvOfficial +Vault</a>：支持 DotENV 语法</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=vincaslt.highlight-matching-tag">HighlightMatching Tag</a>：高亮匹配的标签</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense">PathIntellisense</a>：自动补全路径</p><p><ahref="https://marketplace.visualstudio.com/items?itemName=jasonnutter.search-node-modules">Searchnode_modules</a>：输入 <code>node_modules</code> 搜索 node_modules中的包</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;&lt;a
        
      
    
    </summary>
    
    
      <category term="工具" scheme="https://old-driver-zero.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="IDE" scheme="https://old-driver-zero.github.io/tags/IDE/"/>
    
      <category term="VS Code" scheme="https://old-driver-zero.github.io/tags/VS-Code/"/>
    
  </entry>
  
  <entry>
    <title>C++ 入门（上）</title>
    <link href="https://old-driver-zero.github.io/posts/f8060ffb.html"/>
    <id>https://old-driver-zero.github.io/posts/f8060ffb.html</id>
    <published>2024-04-05T08:24:19.000Z</published>
    <updated>2024-04-20T02:03:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>基于 <em>C++ Primer Fifth </em> 编写</p><p><del>不愧是 C++，这才只是入门，只到 C++ 11</del></p><h1 id="开始-getting-started">开始 Getting Started</h1><p>万恶之源：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, world!&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>文件的后缀名有很多，最常见的应该是 <code>.cc</code> 和<code>.cpp</code></p><p>编译器也有很多，如使用 <code>g++</code> 编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ -o prog1 prog1.cc<br></code></pre></td></tr></table></figure><ul><li>添加支持 c++ 11 标准：<code>-std=c++11</code></li><li><code>-Wall</code> 生成更多警告信息</li></ul><p>输入输出：</p><ul><li>这里使用了 <code>iostream</code>库中的标准输入流和标准输出流，该库中还有标准错误流 <code>cerr</code> 和<code>clog</code></li><li><code>&lt;&lt;</code> 是输出操作符，<code>&gt;&gt;</code>是输入操作符</li><li><code>endl</code> 是一种<strong>控制符manipulator</strong>，有结束当前行和刷新缓冲区的作用</li></ul><p><code>std::</code> 表示使用<strong>命名空间 namespace</strong>的函数等，用于区分</p><p>一个读入的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::cin &gt;&gt; v1 &gt;&gt; v2;<br></code></pre></td></tr></table></figure><p><code>&gt;&gt;</code> 左边是一个<code>istream</code>，右边是一个对象，并返回左边的操作数为结果</p><p>注释方面依旧是两种：<code>//</code> 和 <code>/* */</code></p><p>控制流：<code>while</code>、<code>for</code></p><p>读入未知数量的输入：<code>while(std::cin &gt;&gt; value)</code>，即当输入流读到EOF 或无效输入时，会无效，导致条件为 false</p><p>键盘中的 EOF 是输入 <kbd>Ctrl</kbd> + <kbd>z</kbd></p><p><code>if</code> 语句</p><p>C++ 支持类</p><h1 id="变量与基础类型-variables-and-basic-types">变量与基础类型Variables and Basic Types</h1><h2 id="初级内置类型">初级内置类型</h2><p>算术类型：整数和浮点数</p><p>对于 unicode 字符，有 <code>char16_t</code> 和<code>char32_t</code></p><p>选择使用的类型的原则：</p><ul><li>如果非负，使用 <code>unsigned</code></li><li>整数运算一般使用 <code>int</code>，如果不够，考虑<code>long long</code></li><li><code>char</code> 和 <code>bool</code> 用于表示特殊的东西</li><li>浮点数运算用 <code>double</code></li></ul><p>注意 signed 和 unsigned 参与运算时会发生隐式转换</p><p>字面值：后面可以加 <code>u</code>、<code>l</code>、<code>ll</code>等表示整数，<code>f</code>、<code>l</code> 表示浮点数，前面加<code>u</code>、<code>U</code> 表示 16 位、32 位Unicode，<code>u8</code> 表示 utf-8 字符串</p><p>特殊的 <code>e</code></p><p>编译器自动对每个字符串字面值末尾加 <code>\0</code></p><p>可以用<strong>转义字符 excape sequence</strong>表示一些不可打印的字符，如 <code>\n</code>；也有泛化的表示，如<code>\40</code> 表示空格</p><h2 id="变量">变量</h2><p>定义时初始化：<code>int i = 0;</code>，注意这里的 <code>=</code>和赋值无关，而是表示<strong>初始化 initialization</strong></p><p>还有另外的初始化方法——<strong>列表初始化 listinitialization</strong>：<code>int i = &#123;0&#125;;</code> 或<code>int i&#123;0&#125;</code></p><p>如果没有初始化值，则是<strong>默认初始化</strong></p><p>函数内的变量未初始化</p><p>为了支持分开编译，<strong>声明 declaration</strong>使名字被程序直到，<strong>定义 definition</strong>则创建了关联的实体，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i; <span class="hljs-comment">// 声明但不定义</span><br><span class="hljs-type">int</span> j; <span class="hljs-comment">// 声明且定义</span><br></code></pre></td></tr></table></figure><p>标识符，作用域</p><h2 id="复合类型">复合类型</h2><p><strong>复合类型 compound type</strong>是以另一种类型定义的类型，如引用和指针</p><p><strong>引用 reference</strong> 相当于对象的别名，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> ival = <span class="hljs-number">1024</span>;<br><span class="hljs-type">int</span> &amp;refVal = ival;<br></code></pre></td></tr></table></figure><p>引用定义时绑定到一个对象上，且不可更改</p><p><strong>指针 pointer</strong> 指向另一个类型<code>int *ip1;</code></p><p>指针保持了另一个对象的地址，通过取址运算符 <code>&amp;</code>获取一个对象的地址：<code>int *p = &amp;ival;</code></p><p>注意指针类型和指向的对象类型必须匹配</p><p>使用解引用运算符 <code>*</code> 来访问对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">*p = <span class="hljs-number">0</span>;<br>cout &lt;&lt; *p;<br></code></pre></td></tr></table></figure><p>注意 <code>*</code> 和 <code>&amp;</code>在表达式和声明时表达的含义不同</p><p><strong>空指针 null pointer</strong>没有指向任何对象：<code>int *p1 = nullptr;</code></p><p><code>void*</code> 指针可以存任何对象的地址</p><p>当然，还有指向指针的指针：<code>int **ppi = &amp;pi;</code></p><h2 id="const-标识符">const 标识符</h2><p><code>const</code> 定义常量，必须在定义时初始化，然后不可变</p><p>变量可以赋值给常量，常量也可以赋值给变量，因为复制对象并不会改变对象</p><p><code>const int &amp;ri = i;</code>表示对常量的引用，其不可用于改变值，注意 <code>i</code> 可以是非 const的</p><p>类似的，<code>const int *cpi = &amp;i;</code>表示对常量的指针，不可用该指针改变其指向的变量的值</p><p>const指针表示其不可改变指向，类似于引用：<code>int *const curErr = &amp;errNumb</code></p><p>总的来说，指向 const 对象的叫<strong>低级const</strong>，该对象本身就是 const 的叫<strong>顶级 const</strong></p><ul><li>低级 const 只会出现在复合类型中</li><li>当复制对象时，高级 const 被忽略</li></ul><p><strong>常量表达式 constant expression</strong>表示可以在<strong>编译</strong>时确定的表达式，如<code>constexpr int limit = mf + 1;</code></p><p>注意，<code>constexpr</code> 指针暴露的顶级const：<code>constexpr int *q = nullptr;</code></p><h2 id="处理类型">处理类型</h2><p>使用 <code>typedef</code>给类型起别名：<code>typedef double wages;</code></p><p>还有另一种方法：<code>using wages = double;</code></p><p><code>auto</code> 自动推断类型</p><p>同样的，对于复合类型，忽略顶级const，如有需要，必须手动加上：<code>const auto f = &amp;i;</code></p><p><code>decltype</code> 返回操作数的类型，如<code>decltype(f()) sum = x;</code>，注意这里编译器并不会调用函数<code>f()</code>，而是依据其返回值确定类型</p><p>注意，<code>decltype((variable))</code> 始终是一个引用类型</p><h2 id="自定义数据结构">自定义数据结构</h2><p>定义一个可以直接访问数据元素的“类”：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sales_data</span> &#123;<br>    std::string bookNo;<br>    <span class="hljs-type">double</span> revenue = <span class="hljs-number">0.0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里有数据成员</p><p>为了防止被多处使用的头文件被反复包含而多次编译，使用<strong>预处理器preprocessor</strong> 来定义 <strong>header 保护</strong>，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SALES_DATA_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SALES_DATA_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sales_data</span> &#123;<br>    std::string bookNo;<br>    <span class="hljs-type">double</span> revenue = <span class="hljs-number">0.0</span>;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h1 id="字符串向量和数组-strings-vectors-and-arrays">字符串，向量和数组Strings, Vectors, and Arrays</h1><h2 id="命名空间-using-声明">命名空间 <code>using</code> 声明</h2><p>为了防止每次都要写 <code>std::cin</code>，可以使用 using声明：<code>using std::cin;</code></p><h2 id="库-string-类型">库 <code>string</code> 类型</h2><p><code>string</code> 初始化除了之前说过的，还有</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s2 = <span class="hljs-string">&quot;value&quot;</span>; <span class="hljs-comment">// 直接初始化</span><br><span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">&quot;value&quot;</span>)</span></span>; <span class="hljs-comment">// 复制初始化</span><br><span class="hljs-function">string <span class="hljs-title">s4</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;c&#x27;</span>)</span></span>; <span class="hljs-comment">// 10 个 c</span><br></code></pre></td></tr></table></figure><p>注意末尾的 <code>\0</code> 不会被复制到字符串中</p><p>字符串的操作：<code>&lt;&lt;</code>、<code>&gt;&gt;</code>、<code>getline(is, s)</code>、<code>s.empty()</code>、<code>s1 + s2</code>、<code>s1 = s2</code>、<code>s1 == s2</code>、<code>s1 &lt; s2</code>等</p><p>字符串可以直接连接，但是为了兼容 C，字符串字面值不能直接连接</p><p>在 <code>cctype</code> 头文件中有很多处理字符的函数，如<code>islower(c)</code> 和 <code>tolower(c)</code> 等</p><p><code>c</code> 开头的库表示是 C++ 版本的 C 语言库</p><p>一种 for 循环的写法：<code>for (auto c : str)</code></p><p><code>[]</code> 用于索引，范围是<code>0 &lt;= index &lt; s.size()</code></p><h2 id="库-vector-类型">库 <code>vector</code> 类型</h2><p><code>vector</code> 是一个<strong>模板template</strong>，<code>vector&lt;int&gt;</code> 等才是类型</p><p>初始化同理</p><p>添加元素：<code>push_back()</code></p><p><code>.size()</code> 返回的是<code>vector&lt;int::size_type</code></p><h2 id="介绍-iterator">介绍 <code>Iterator</code></h2><p>除了下标以外，还有一种访问方法——<strong>迭代器 iterator</strong></p><p><code>.begin()</code> 返回指向第一个元素的迭代器，<code>.end()</code>返回指向最后一个元素的下一位的迭代器</p><p>迭代器可以解引用，自增或自减，判断是否相等</p><p>注意因为 <code>.end()</code>返回的迭代器不指向某个元素，所以不可以自增或自减</p><p>一个使用迭代器迭代的写法：<code>for (auto it = s.begin(); it != s.end(); ++it)</code></p><p>类似指针，<code>vector&lt;int&gt;::const_iterator it;</code>只可读，不可写</p><p>如果操作的对象是 const 的，则 <code>.begin()</code> 等返回的是<code>const_iterator</code>，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; cv;<br>vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = cv.<span class="hljs-built_in">begin</span>();<br></code></pre></td></tr></table></figure><p>为了能够显式指明想要的是 <code>const_iterator</code>，可以使用<code>.cbegin()</code> 和 <code>.cend()</code></p><p>string 和 vector的迭代器同样支持加减、大小比较，这种运算叫做<strong>迭代器算术 iteratorarithmetic</strong></p><p>特别的，两个迭代器相减的返回值的类型是<code>difference_type</code></p><h2 id="数组">数组</h2><p>数组相当于固定大小的 vector</p><p>对数组取下标的变量的类型是 <code>size_t</code>，其定义在<code>cstddef</code> 中</p><p>数组和指针紧密相连</p><p>数组有类似于容器的两个迭代器函数：<code>int *pbeg = begin(arr), *pend = end(arr);</code></p><p>两个指针相减的返回值的类型是 <code>ptrdiff_t</code></p><p>对于 C++ 来说，最好不要使用 C 风格的 string，故这里不作介绍</p><h2 id="多维数组">多维数组</h2><p>多维数组也可以使用 for 循环，但是除了最内层以外都要使用引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;row : ia)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> col : row)<br>        cout &lt;&lt; col &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h1 id="表达式-expressions">表达式 Expressions</h1><p><strong>基础</strong></p><p>单元、二元、三元运算符</p><p>运算符重载</p><p>左值与右值</p><p>优先级与结合性</p><p>表达式中的计算是没有顺序的，如 <code>int i = f1() * f2();</code>是无法得知哪个函数先调用的；<code>cout &lt;&lt; i &lt;&lt; ++i &lt;&lt; endl;</code>也是一个未定义的行为</p><p>有定义计算循序的运算符只有<code>&amp;&amp;</code>、<code>||</code>、<code>? :</code>、<code>,</code></p><p><strong>算术运算符</strong></p><p>在计算中，小的整数类型被提升为较大的整数类型</p><p><strong>逻辑与关系运算符</strong></p><p><strong>赋值运算符</strong></p><p>返回左操作数，优先级低</p><p>自增/自减</p><p>一种常见的写法：<code>*iter++</code></p><p><strong>成员访问函数</strong></p><p><code>-&gt;</code> 返回的是一个 lvalue；如果对象是 lvalue，则<code>.</code> 返回的是一个 lvalue，，反之则是 rvalue</p><p><strong>位运算</strong></p><p>由于在位运算中符号位如何处理是未知的，所以推荐只对 unsigned变量进行位运算</p><p><code>sizeof(类型)</code> 返回<code>size_t</code>，还有一种用法：<code>sizeof 表达式</code>，注意表达式不会被求值</p><p>类型转换</p><p>隐式类型转换</p><p>显式类型转换：</p><ul><li><code>static_cast</code></li><li><code>const_cast</code> 改变了低级的 const，在重载函数中有用</li><li><code>reinterpret_cast</code> 基于操作数的 bit 的低级重新解释</li></ul><p>总之，要尽可能避免类型转换</p><h1 id="语句-statements">语句 Statements</h1><p>空语句应该有注释，以免被人忽略</p><p>块与块作用域</p><p>控制语句</p><p>对应 <code>switch</code>，最好一定要定义一个<code>default</code>，即使是空的</p><p>定义在 <code>while</code> 里的变量在每次迭代时都会创建和销毁</p><p>在 <code>stdexcept</code>中定义了通用的异常类：<code>exception</code>、<code>runtime_error</code>、<code>range_error</code>、<code>overflow_error</code>、<code>underflow_error</code>、<code>logic_erro</code>、<code>domain_error</code>、<code>invalid_argument</code>、<code>length_error</code>、<code>out_of_range</code></p><h1 id="函数-functions">函数 Functions</h1><h2 id="参数传递">参数传递</h2><p>值参数传递 vs 引用参数传递</p><p>对于较大的对象，按值传递复制的开销较大，但又不想要改变该对象，可以使用<code>const</code> 引用</p><p>因为在赋值时顶层 const 被忽略，所以<code>void fcn(const int i)</code> 和 <code>void fcn(int i)</code>是冲突的</p><p>可以传递对数组的引用：<code>f(int (&amp;arr)[10])</code></p><p>二维数组的传递：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> (*matrix)[<span class="hljs-number">10</span>], <span class="hljs-type">int</span> rowSize)</span></span>;<br><span class="hljs-comment">// 或</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> matrix[][<span class="hljs-number">10</span>], <span class="hljs-type">int</span> rowSize)</span></span>; <span class="hljs-comment">// 第一维会被编译器忽略，所以最好不要包含</span><br></code></pre></td></tr></table></figure><p>命令行参数传递：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br></code></pre></td></tr></table></figure><p>其中 <code>argv[0]</code> 为程序名称</p><p><code>initializer_list</code>类似于数组，是一个模板类型，可以用来接收未知数量的参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">error_msg</span><span class="hljs-params">(initializer_list&lt;string&gt; il)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> beg = il.<span class="hljs-built_in">begin</span>(); beg != il.<span class="hljs-built_in">end</span>(); ++beg)<br>        cout &lt;&lt; *beg &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">error_msg</span>(&#123;<span class="hljs-string">&quot;functionX&quot;</span>, <span class="hljs-string">&quot;okay&quot;</span>&#125;);<br></code></pre></td></tr></table></figure><h2 id="返回类型与返回语句">返回类型与返回语句</h2><p>一种简单的返回 <code>vector</code> 的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;functionX&quot;</span>, <span class="hljs-string">&quot;okay&quot;</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 <code>main()</code> 没有返回值，则隐式返回 0，在<code>cstdlib</code>中预处理的变量表示成功和失败：<code>EXIT_FAILURE</code> 和<code>EXIT_SUCCESS</code></p><p>对于一个返回一个数组的函数，可以使用<strong>尾随返回类型 trailingreturn type</strong>，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> -&gt; <span class="hljs-title">int</span> <span class="hljs-params">(*)</span>[10]</span>;<br></code></pre></td></tr></table></figure><h2 id="特殊用途的特色">特殊用途的特色</h2><p><code>inline</code>可以让编译器将函数展开，但编译器可以拒绝这么做</p><p><code>constexpr</code> 函数隐式 <code>inline</code>了，同时返回值不一定是 const</p><p>以上两者一般定义在头文件中</p><p><code>assert(expr);</code>：若 <code>expr</code>为假，终止程序，用于检查不会发生的条件</p><p>在编译时添加参数 <code>-D NDEBUG</code> 来关闭 debug 模式</p><p>结合一些宏，可以提高调试效率：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NDEBUG</span><br>cerr &lt;&lt; __func__ &lt;&lt; endl;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><ul><li><code>__func__</code> 输出函数名称</li><li><code>__FILE__</code> 文件名</li><li><code>__LINE__</code> 当前行数</li></ul><h2 id="函数指针">函数指针</h2><p>函数指针类似于函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">bool</span> (*pf) (<span class="hljs-type">const</span> string &amp;, <span class="hljs-type">const</span> string &amp;);<br></code></pre></td></tr></table></figure><p>使用起来类似于一个函数别名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> b = <span class="hljs-built_in">pf</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;goodbye&quot;</span>);<br></code></pre></td></tr></table></figure><p>可以将其指向其他的函数，但必须函数原型一致</p><p>函数指针也可以作为参数，可以像函数一样写，也可以显式写成函数指针的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useBigger</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s1, <span class="hljs-type">const</span> string &amp;s2, <span class="hljs-type">bool</span> pf(<span class="hljs-type">const</span> string &amp;, <span class="hljs-type">const</span> string &amp;))</span></span>;<br></code></pre></td></tr></table></figure><p>传递参数时直接使用函数名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">useBigger</span>(s1, s2, lengthCompare);<br></code></pre></td></tr></table></figure><p>当然，也可以返回一个函数指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> -&gt; <span class="hljs-title">int</span> <span class="hljs-params">(*)</span><span class="hljs-params">(<span class="hljs-type">int</span>*, <span class="hljs-type">int</span>)</span></span>;<br></code></pre></td></tr></table></figure><h1 id="类-classes">类 Classes</h1><p>在类内部定义的成员函数隐式<code>inline</code>；如果在外部定义，则要指定是哪个类：<code>Sales_data::print(const string&amp; s) &#123;...&#125;</code></p><p><code>const</code>成员函数实际上相当于：<code>const Sales_data *const this</code>，即指定了<code>this</code> 的 const 性质——不改变该对象</p><p>如果没有构造函数，编译器会自动生成一个默认构造函数，也可以显式指定：<code>Sales_data() = default;</code>。当然，这只针对内置的类型。</p><p>构造函数初始化列表：<code>Sales_data(const string &amp;s): bookNo(s) &#123; &#125;</code></p><p>一个类可以通过<strong>友元 friend</strong>使类或函数访问到其私有成员</p><p>友元声明只指定了访问，还需要另外声明友元声明的函数，该函数通常和类声明在同一个头文件中</p><p>我们可以在类中定义一个类型成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> pos = string::size_type;<br>&#125;<br></code></pre></td></tr></table></figure><p>const 成员函数返回的 <code>*this</code> 是一个 const 对象</p><p>每个类实际上定义了自己的新作用域，因此，对于定义在类外部的成员，要使用类名称指定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window_mgr</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ScreenIndex <span class="hljs-title">addScreen</span><span class="hljs-params">(ScreenIndex i)</span></span>;<br>&#125;<br><span class="hljs-function">Window_mgr::ScreenIndex <span class="hljs-title">Window_mgr::addScreen</span><span class="hljs-params">(ScreenIndex i)</span></span>;<br></code></pre></td></tr></table></figure><p>注意区分初始化 <code>ConstRef::ConstRef(int ii): i(ii) &#123; &#125;</code>和赋值 <code>ConstRef::ConstRef(int ii) &#123; i = ii; &#125;</code></p><p>其中初始化顺序一定是被<strong>声明</strong>的顺序，而不是定义中写的顺序，故最好两者顺序一致</p><p><strong>指派 delegating</strong>构造函数使用了该类的另一个构造函数执行初始化，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sales_data</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// nondelegating constructor initializes members from corresponding arguments</span><br><span class="hljs-built_in">Sales_data</span>(std::string s, <span class="hljs-type">unsigned</span> cnt, <span class="hljs-type">double</span> price):<br>            <span class="hljs-built_in">bookNo</span>(s), <span class="hljs-built_in">units_sold</span>(cnt), <span class="hljs-built_in">revenue</span>(cnt*price) &#123; &#125;<br>    <span class="hljs-comment">// remaining constructors all delegate to another constructor</span><br>    <span class="hljs-built_in">Sales_data</span>(): <span class="hljs-built_in">Sales_data</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Sales_data obj();</code>是一个<strong>函数声明</strong>，<code>Sales_data obj2;</code>才是默认构造对象</p><p>单个参数的构造函数可以隐式调用构造函数转换，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">item.<span class="hljs-built_in">combine</span>(<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;9-999&quot;</span>)); <span class="hljs-comment">// 隐式调用 Sales_data(const std::string &amp;s) 转换为 Sales_data</span><br></code></pre></td></tr></table></figure><p>为了防止这种转换，可以禁用隐式转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Sales_data</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;s)</span>: bookNo(s) &#123;</span> &#125;<br></code></pre></td></tr></table></figure><p>这样子做了之后也不可用于复制形式的初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Sales_data <span class="hljs-title">item1</span><span class="hljs-params">(null_book)</span></span>; <span class="hljs-comment">// 允许，直接初始化</span><br>Sales_data item2 = null_book; <span class="hljs-comment">// 不允许</span><br></code></pre></td></tr></table></figure><p><strong>集合体 aggregate</strong> 类</p><ul><li>所有的数据成员都是 public</li><li>没有定义任何构造函数</li><li>没有类内部的初始化</li><li>没有基类或虚函数</li></ul><p>静态成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title">rate</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> interestRate; &#125; <span class="hljs-comment">// 声明</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">rate</span><span class="hljs-params">(<span class="hljs-type">double</span> newRate)</span></span>;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">double</span> interestRate;<br>&#125;<br><br><span class="hljs-comment">// 定义</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Account::rate</span><span class="hljs-params">(<span class="hljs-type">double</span> newRate)</span> </span>&#123;<br>    interestRate = newRate;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-type">double</span> r = Account::<span class="hljs-built_in">rate</span>();<br></code></pre></td></tr></table></figure><p>静态 static const 成员可以在类内部初始化</p><h1 id="io-库-the-io-library">IO 库 The IO Library</h1><h2 id="io-类">IO 类</h2><p>IO库的头文件：<code>iostream</code>、<code>fstream</code>、<code>sstream</code></p><p>为了支持操作 <code>wchar_t</code> 类型的数据，定义了<code>wistream</code>、<code>wostream</code> 等类型，对应的有<code>wcin</code>、<code>wcout</code> 等</p><p>IO 对象不可复制或赋值</p><p>stream有四种情况：<code>eof</code>、<code>fail</code>、<code>bad</code>、<code>good</code></p><p><code>.rdstate()</code> 返回该 stream 的 <code>iostate</code></p><p><code>.clear()</code> 有两种重载：</p><ul><li>无参数的：清空所有情况</li><li>有一个参数的：<code>cin.clear(cin.rdstate, ~cin.failbit &amp; ~cin.badbit);</code></li></ul><p>io 的 buffer 刷新的情况：</p><ul><li>程序正常结束</li><li>buffer 满了</li><li>显式使用如 <code>endl</code>、<code>flush</code> 的操作符</li><li>使用 <code>unitbuf</code> 操作符，使得每次输出操作都会刷新buffer</li><li>输出流被绑定到另一个流，如 <code>cin</code> 被绑定到<code>cout</code>，故读 <code>cin</code> 会刷新 <code>cout</code> 的buffer<ul><li>解除绑定的方法：<code>cin.tie(nullptr);</code></li></ul></li></ul><h2 id="文件输入和输出">文件输入和输出</h2><p>创建一个 fstream：<code>ifstream input("input.txt");</code></p><p>文件模式：</p><ul><li><p><code>in</code>、<code>out</code></p></li><li><p><code>app</code> 每次写之后 seek 到结尾</p></li><li><p><code>ate</code> 在打开后 seek 到结尾</p></li><li><p><code>trunc</code> 截断文件</p></li><li><p><code>binary</code> 以二进制模式执行 IO 操作</p></li></ul><p>保持文件内容的输出：<code>ofstream app("file2", ofstream::out | ofstream::app)</code></p><h2 id="string-流"><code>string</code> 流</h2><p>当我们想要对一整行的独立字做一些工作时，<code>istringstream</code>很有用</p><h1 id="顺序容器-sequential-containers">顺序容器 SequentialContainers</h1><p>顺序容器类型：<code>vector</code>、<code>deque</code>、<code>list</code>、<code>forward_list</code>、<code>array</code>、<code>string</code></p><p><code>rbegin()</code>、<code>rend()</code></p><p><code>.assign()</code></p><p>支持比较大小</p><p>当 <code>push</code> 或 <code>insert</code>一个成员时，我们传递的对象类型的容器的元素类型，且会被复制到容器中；但使用<code>emplace</code> 等直接在容器管理的空间中使用构造函数来创建元素，如<code>c.emplace_back("999", 25, 15.99);</code></p><p>一个使用循环来插入元素的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (begin != v.<span class="hljs-built_in">end</span>()) &#123;<br>    ++begin;<br>    begin = v.<span class="hljs-built_in">insert</span>(begin, <span class="hljs-number">42</span>);<br>    ++begin;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们已经不再需要多余的空间了，可以使用<code>shrink_to_fit()</code>来返回未利用的内存，但实际实现可以忽略该请求</p><p>string 的搜索函数返回的是无符号的<code>string::size_type</code>，如果没找到，返回的<code>string::npos</code> 是 -1，即最大的 string 大小</p><p>将字符串转化为数字：<code>stoi(s)</code>、<code>stod(s)</code></p><p><strong>容器适配器 container adaptor</strong></p><h1 id="泛型算法-generic-algorithms">泛型算法 Generic Algorithms</h1><h2 id="初见算法">初见算法</h2><p>算法不会执行容器操作，而是基于迭代器操作，故算法从来不会改变底层容器的大小</p><p>算法通常接受由首尾迭代器指明的范围</p><p>只读算法：<code>find</code>、<code>accumulate</code>，如<code>string sum = accumulate(v.cbegin(), v.cend(), string(""));</code></p><p>有的算法可以接受两个序列，如<code>equal(roster1.cbegin(), roster1.cend(), roster2.cbegin())</code></p><p>注意第二个序列只接受了一个迭代器，我们需要确保第二个序列长度不小于第一个序列</p><p>写容器元素的算法：<code>fill</code></p><p><code>back_inserter</code>接受对容器的引用并返回一个插入迭代器，当我们通过这个迭代器赋值时，会自动调用<code>push_back</code></p><p>不少算法都有 <code>_copy</code> 的版本，如<code>replace_copy(ilst.cbegin(), ilst.cend(), back_inserter(ivec), 0, 42);</code></p><p>重新排列的算法，如去重的算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">auto</span> end_unique = <span class="hljs-built_in">unique</span>(word.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>());<br>words.<span class="hljs-built_in">erase</span>(end_unique, words.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><h2 id="自定义操作">自定义操作</h2><p>lambda表达式代表可调用的代码单元，可以被视为匿名、内联函数，有如下形式：<code>[捕获列表] (参数列表) -&gt; 返回值类型 &#123; 函数体 &#125;</code></p><p>尽管 lambda出现在函数的内部，其<strong>只有</strong>在捕获列表中指明了变量，才能使用函数内部的局部变量</p><p><code>for_each()</code>函数接受一个可调用对象并调用输入范围内的每个对象</p><p>当我们定义了一个 lambda 时，编译器生成了一个新的匿名的类。</p><p>当然，可以捕捉值，也可以捕捉引用</p><p>默认情况下，lambda 不能改变按值捕获的变量的值，但可以加上<code>mutable</code> 关键字，使得可以改变这个值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">size_t</span> v1 = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">auto</span> f = [v1] () <span class="hljs-keyword">mutable</span> &#123; reutrn ++v1; &#125;;<br>v1 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">auto</span> j = <span class="hljs-built_in">f</span>(); <span class="hljs-comment">// j = 43;</span><br></code></pre></td></tr></table></figure><p><code>fucntional</code> 头中的 <code>bind</code>可以接受可调用函数和参数，并将参数应用于该函数，形式为：<code>auto 新可调用对象 = bind(可调用对象, 参数列表)</code></p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::placeholders; <span class="hljs-comment">// _1 是占位符，在命名空间 std::placeholders 中</span><br><span class="hljs-keyword">auto</span> check6 = <span class="hljs-built_in">bind</span>(check_size, _1, <span class="hljs-number">6</span>); <span class="hljs-comment">// _1 表示其是新可调用对象的第 1 个参数</span><br></code></pre></td></tr></table></figure><p>注意 <code>bind</code>是将参数<strong>复制</strong>过去，对于不能复制的，可以使用<code>ref</code> 和 <code>cref</code> 引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">for_each(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">bind</span>(print, <span class="hljs-built_in">ref</span>(os), _1, <span class="hljs-string">&#x27; &#x27;</span>));<br></code></pre></td></tr></table></figure><h2 id="重探迭代器">重探迭代器</h2><p>迭代器的类型：<code>insert</code>、<code>stream</code>、<code>reverse</code>、<code>move</code></p><p><code>insert</code> 迭代器：</p><ul><li><code>back_inserter</code></li><li><code>front_inserter</code></li><li><code>inserter</code></li></ul><p><code>iostream</code> 迭代器：</p><ul><li><code>istream_iterator&lt;T&gt;in(is)</code> 从输入流<code>is</code> 中读数据</li><li><code>istream_iterator&lt;T&gt;end</code><code>istream_iterator</code> 的尾迭代器</li></ul><p>输出迭代器同理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ostream_iterator&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">out_iter</span><span class="hljs-params">(cout, <span class="hljs-string">&quot; &quot;</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : vec)<br>    out_iter = e; <span class="hljs-comment">// 等价于 *out_iter++ = e;</span><br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>可以通过提供反向迭代器降序排序：<code>sort(vec.rbegin(), vec.rend());</code></p><p>五类迭代器</p><h2 id="算法的结构">算法的结构</h2><p>算法的几种结构：</p><ul><li><code>alg(beg, end, 其他参数)</code></li><li><code>alg(beg, end, dest, 其他参数)</code></li><li><code>alg(beg, end, beg2, 其他参数)</code></li><li><code>alg(beg, end, beg2, end2, 其他参数)</code></li></ul><p>注意带 <code>_if</code> 和 <code>_copy</code> 后缀的算法</p><p>优先使用成员函数版本的算法</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;基于 &lt;em&gt;C++ Primer Fifth &lt;/em&gt;
        
      
    
    </summary>
    
    
      <category term="工具" scheme="https://old-driver-zero.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="C++" scheme="https://old-driver-zero.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CMU 15-445：数据库系统</title>
    <link href="https://old-driver-zero.github.io/posts/17492bb9.html"/>
    <id>https://old-driver-zero.github.io/posts/17492bb9.html</id>
    <published>2024-03-30T10:04:32.000Z</published>
    <updated>2024-04-05T08:29:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="关系模型与关系代数-relation-model-relation-algebra">关系模型与关系代数Relation Model &amp; Relation Algebra</h1><p><strong>数据库管理系统 Database ManagementSystem（DBMS）</strong>允许应用程序存储和分析数据库中的信息的软件，通常支持根据某种数据模型定义、创建、查询、更新、管理数据库</p><p><strong>数据模型 data model</strong>是描述数据库中的数据的概念的集合</p><p><strong>模式 schema</strong>是使用给定数据模型，对特定数据集合的描述</p><p>关系型数据库的发明者——Codd</p><p><strong>关系 relation</strong>是包括了表示实体的属性关系的无序集合</p><p><strong>元组 tuple</strong> 是关系中属性值的集合，类似于行</p><p><strong>主键 primary key</strong> 唯一地指定了一个 tuple</p><p><strong>外键 foreign key</strong></p><p>数据操作语言 Data ManipulationLanguages（DML）：从数据库中存取信息的方法，有程序性的（关系代数）和非程序性的</p><p><strong>关系代数 relational algebra</strong>：</p><ul><li><span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.65ex;" xmlns="http://www.w3.org/2000/svg" width="11.475ex" height="2.347ex" role="img" focusable="false" viewBox="0 -750 5071.8 1037.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g><g data-mml-node="TeXAtom" transform="translate(604,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mi" transform="translate(503,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(954,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(1420,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(1940,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(2285,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(2718,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(3247,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(3608,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g></g></g><g data-mml-node="mo" transform="translate(3534.8,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(3923.8,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mo" transform="translate(4682.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>：类似于过滤器</li><li><span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.656ex;" xmlns="http://www.w3.org/2000/svg" width="11.879ex" height="2.353ex" role="img" focusable="false" viewBox="0 -750 5250.4 1039.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D70B" d="M132 -11Q98 -11 98 22V33L111 61Q186 219 220 334L228 358H196Q158 358 142 355T103 336Q92 329 81 318T62 297T53 285Q51 284 38 284Q19 284 19 294Q19 300 38 329T93 391T164 429Q171 431 389 431Q549 431 553 430Q573 423 573 402Q573 371 541 360Q535 358 472 358H408L405 341Q393 269 393 222Q393 170 402 129T421 65T431 37Q431 20 417 5T381 -10Q370 -10 363 -7T347 17T331 77Q330 86 330 121Q330 170 339 226T357 318T367 358H269L268 354Q268 351 249 275T206 114T175 17Q164 -11 132 -11Z"></path></g><g data-mml-node="TeXAtom" transform="translate(603,-152.7) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mn" transform="translate(750,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1250,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mo" transform="translate(1528,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"></path></g><g data-mml-node="mo" transform="translate(2700,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(2978,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mi" transform="translate(3728,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g><g data-mml-node="mo" transform="translate(3713.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(4102.4,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mo" transform="translate(4861.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>：投影，可以改变属性的顺序和操作值</li><li><span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.575ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3348.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mo" transform="translate(1314.7,0) translate(0 -0.5)"><path data-c="22C2" d="M139 -217Q127 -241 114 -246Q106 -249 97 -249Q67 -249 57 -220Q55 -214 55 102Q55 152 55 221T54 312Q54 422 60 464T91 554Q120 612 165 654T257 714T337 741T392 749Q393 750 402 750Q414 750 422 749Q557 749 660 659T776 430Q777 422 777 102Q777 -214 775 -220Q765 -249 735 -249Q716 -249 708 -241T694 -217L692 428L690 441Q674 540 597 603T416 666H409Q388 666 364 662T294 638T212 581Q156 523 142 441L140 428L139 105V-217Z"></path></g><g data-mml-node="mi" transform="translate(2314.3,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mo" transform="translate(2959.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>：交</li><li><span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.575ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3348.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mo" transform="translate(1314.7,0) translate(0 -0.5)"><path data-c="22C3" d="M96 750Q103 750 109 748T120 744T127 737T133 730T137 723T139 718V395L140 73L142 60Q159 -43 237 -104T416 -166Q521 -166 597 -103T690 60L692 73L694 718Q708 749 735 749Q765 749 775 720Q777 714 777 398Q777 78 776 71Q766 -51 680 -140Q571 -249 416 -249H411Q261 -249 152 -140Q66 -51 56 71Q55 78 55 398Q55 714 57 720Q60 734 70 740Q80 750 96 750Z"></path></g><g data-mml-node="mi" transform="translate(2314.3,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mo" transform="translate(2959.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>：并</li><li><span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.702ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3404.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mo" transform="translate(1370.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(2370.4,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mo" transform="translate(3015.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>：差</li><li><span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.702ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3404.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mo" transform="translate(1370.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mi" transform="translate(2370.4,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mo" transform="translate(3015.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>：笛卡尔积</li><li><span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.937ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2182 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mi" transform="translate(1148,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mo" transform="translate(1793,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>：两张表中有一个或多个共同的属性值的元组</li></ul><p>这种代数定义了顺序，我们需要从更高维度使用声明式语句，例如 SQL</p><h1 id="现代-sql-modern-sql">现代 SQL Modern SQL</h1><p>IBM 发明了 <strong>SQL(Structured QueryLanguage)</strong>，因为其巨大的影响力，最终成为了标准</p><p>SQL 经常在更新</p><p><strong>聚合 aggregate</strong>：只能在 <code>SELECT</code>输出列表中使用，如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> student;<br></code></pre></td></tr></table></figure><p><code>GROUP BY</code>：将 tuple 分组，对每个子集计算聚合：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(s.gpa), e.cid <span class="hljs-keyword">FROM</span> enrolled <span class="hljs-keyword">AS</span> e <span class="hljs-keyword">JOIN</span> student <span class="hljs-keyword">AS</span> s <span class="hljs-keyword">ON</span> e.sid <span class="hljs-operator">=</span> s.sid <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> e.cid;<br></code></pre></td></tr></table></figure><p><code>HAVING</code>：类似于对 <code>GROUP BY</code> 的<code>WHERE</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(s.gpa), e.cid <span class="hljs-keyword">FROM</span> enrolled <span class="hljs-keyword">AS</span> e <span class="hljs-keyword">JOIN</span> student <span class="hljs-keyword">AS</span> s <span class="hljs-keyword">ON</span> e.sid <span class="hljs-operator">=</span> s.sid<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> e.cid <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(s.gpa) <span class="hljs-operator">&gt;</span> <span class="hljs-number">3.9</span>;<br></code></pre></td></tr></table></figure><p>SQL标准并不是强制的，不同数据库实现的不同，例如对于字符串，有的只支持<code>'</code>，有的则都支持；还有大小写敏感等</p><p>窗口函数：对每个 tuple 的某个属性施加一个函数，类似于<code>map</code>，有一些特殊的，如</p><ul><li><code>ROW_NUMBER()</code> 当前行</li><li><code>RANK()</code> 当前行顺序</li><li><code>OVER()</code> 指示如何将 tuple 组合到一个</li></ul><p>嵌套查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> sid <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> sid <span class="hljs-keyword">FROM</span> enrolled);<br></code></pre></td></tr></table></figure><p>有一些关键词：<code>ALL</code>、<code>ANY</code>、<code>IN</code>、<code>EXISTS</code></p><p><code>LATERAL</code>操作符可以让嵌套查询引用在它之前的其他嵌套查询的参数，相当于<code>for</code> 循环</p><p><code>WITH ... AS</code>类似于创建了一张临时的表，是嵌套查询的替代：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WITH</span> cteName <span class="hljs-keyword">AS</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> cteName;<br></code></pre></td></tr></table></figure><h1 id="数据库存储-database-storage">数据库存储 Database Storage</h1><p>DBMS的主要存储位置在非易失性硬盘上，其组件管理在非易失性和易失性存储的数据移动</p><p>磁盘的随机访问速度比顺序访问速度慢，所以一般想要最大化顺序访问</p><p>如果直接使用 <code>mmap</code>，则有以下的问题：</p><ul><li>转移安全</li><li>I/O 停滞</li><li>错误处理</li><li>效率低</li></ul><p>故通常自己管理，而不是交给 OS</p><p><strong>存储管理器</strong>用于管理数据库的文件，通常将文件组织为<strong>页page</strong></p><p>页是固定大小的数据块，每个页都有一个唯一的 id，DBMS 需要把 page id映射到物理位置</p><p>数据库中页的大小通常为 4KB，8KB，16KB 等</p><p>管理磁盘上的页文件的方法：</p><p><strong>堆文件</strong>：以随机顺序存储的页的无序集合，需要维护特殊的也来追踪数据库文件中的数据页（同步），同样记录的每个页的空余槽和空页等元数据</p><figure><img src="/illustration/CMU%2015-445：数据库系统/页目录.webp" alt="页目录"><figcaption aria-hidden="true">页目录</figcaption></figure><p>每个页都有一个 header，包括了页大小、校验和、压缩元数据、Schema信息等，有的系统的页是自我包含的</p><p>页的布局方式：</p><p><strong>面向元组存储 tuple-oriented storage</strong>：</p><figure><img src="/illustration/CMU%2015-445：数据库系统/面向元组存储.webp" alt="面向元组存储"><figcaption aria-hidden="true">面向元组存储</figcaption></figure><p><strong>插槽页 slotted page</strong>：把槽映射到 tuple 的起点偏移</p><figure><img src="/illustration/CMU%2015-445：数据库系统/插槽页.webp" alt="插槽页"><figcaption aria-hidden="true">插槽页</figcaption></figure><p>DBMS 为每个 tuple 分配了一个<strong>记录 id</strong>表示其<strong>物理位置</strong>，注意物理位置可能会改变，所以应用程序不应该依赖于这种id</p><p>使用 header 中的 bitmap 来标记页中的 tuple 的某些属性为 NULL</p><p><strong>日记结构存储 log-structured storage</strong>：维护改变 tuple的记录日志（每条日志代表一个 tuple PUT/DELETE 操作）</p><p>写非常容易，但是为了读给定 id 的 tuple，DBMS 需要维护把 tuple id映射到日志记录的索引</p><figure><img src="/illustration/CMU%2015-445：数据库系统/日志结构存储.webp" alt="日志结构存储"><figcaption aria-hidden="true">日志结构存储</figcaption></figure><p>需要周期性地将页压实来减少空间浪费，因为很多旧的数据没有用了</p><p>压实后，记录的时间顺序已经不重要了，所以可以基于 id给页排序来提高未来的查找效率，叫做 <strong>Sorted StringTables（SSTables）</strong></p><p>合并较大的 log 文件来生成较小的文件：</p><p><img src="/illustration/CMU%2015-445：数据库系统/日记结构压实.webp"></p><p>除此之外，这种方法的缺点还有写入放大</p><p><strong>索引组织存储 index-organize storage</strong>：tuple 基于 key在页中排好序</p><p><img src="/illustration/CMU%2015-445：数据库系统/索引组织存储.webp"></p><p>因为 tuple 就是字节序列，所以 DBMS需要将这些字节解释为属性类型和值，其目录中包括了用于找到 tuple 布局的schema 信息</p><p>tuple 需要字长对齐，方法有</p><ul><li>填充：添加 0</li><li>重新排序：调整顺序（通常仍然需要填充）</li></ul><p>数据的表示通常有：</p><ul><li><code>INTEGER</code>、<code>BIGINT</code>、<code>SMALLINT</code></li><li><code>FLOAT/REAL</code>、<code>NUMERIC/DECIMAL</code></li><li><code>VALCHAR/VARBINARY</code>、<code>TEXT/BLOB</code></li><li><code>TIME/DATE/TIMESTAMP</code>、<code>INTERVAL</code></li></ul><p>对于 NULL 数据类型，最常见的方法是在 header 里面存储一个 bitmap来指明哪些属性是 null</p><p>对于存储一个大于一页的值，使用分离的 <strong>overflow存储页</strong></p><figure><img src="/illustration/CMU%2015-445：数据库系统/溢出页.webp" alt="溢出页"><figcaption aria-hidden="true">溢出页</figcaption></figure><p>有的系统可以在另一个外部文件中存储一个大的值，但是 DBMS不能操作外部文件的内容</p><h1 id="存储模型和数据库压缩-storage-models-database-compression">存储模型和数据库压缩Storage Models &amp; Database Compression</h1><p>数据库的工作负载：</p><ul><li><strong>联机事务处理 On-Line TransactionProcessing（OLTP）</strong>：每次只读/更新一小部分数据的快速操作</li><li><strong>联机分析处理 On-Line AnalyticalProcessing（OLAP）</strong>：每次读许多文件以计算聚合的复杂查询</li><li><strong>杂交事务 + 分析处理</strong>：以上两者的结合</li></ul><figure><img src="/illustration/CMU%2015-445：数据库系统/数据库工作负载.webp" alt="数据库工作负载"><figcaption aria-hidden="true">数据库工作负载</figcaption></figure><p>注意到关系模型并没有指明必须把一个 tuple的所有属性存到一个页中，所以对不同的工作负载可以有不同的布局</p><p><strong>N 元存储模型 N-ary Storage Model(NSM)</strong>：一个 tuple的所有属性连续地储存在一个页中，即“行存储”，利于 OLTP</p><p><strong>解耦存储模型 Decomposition Storage Model(DSM)</strong>：所有tuple 的一个属性连续地存储在一个属性中，即“列储存”，利于 OLAP</p><p>DSM 的 tuple 识别：</p><ul><li>固定长度的偏移量</li><li>潜入 tuple id</li></ul><p>变长数据：<strong>字段压缩 dictionarycompression</strong>，将变成数据转换为固定长度的值</p><p>但是，OLAP基本上不会只访问一张表的一列，所以仍然需要以列布局存储数据以获得存储 +执行的收益</p><p><strong>分割属性 Partition AttributesAcross(PAX)</strong>：在一个数据库页中垂直分割属性，是一种杂交存储模型</p><p>将行水平分割为组，然后竖直将其属性分割为列</p><figure><img src="/illustration/CMU%2015-445：数据库系统/PAX.webp" alt="PAX"><figcaption aria-hidden="true">PAX</figcaption></figure><p>注意到 I/O 通常是 DBMS的瓶颈，可以<strong>压缩</strong>数据以提高数据 I/O的利用率，当然，代价就是提高了 CPU的花费，但对于硬盘上的文件来说，通常是值得的</p><p>压缩的目标：</p><ul><li>固定长度的值</li><li>尽可能在执行时延迟解压</li><li>必须是无损的</li></ul><p>压缩的粒度：块、tuple、属性、列级别</p><p><strong>运行长度编码 run-lengthencoding</strong>：把一列的相同数值压缩到三元组（值，起始位置，数量）中，需要智能排序以获得更好地的压缩率</p><figure><img src="/illustration/CMU%2015-445：数据库系统/运行长度编码.webp" alt="运行长度编码"><figcaption aria-hidden="true">运行长度编码</figcaption></figure><figure><img src="/illustration/CMU%2015-445：数据库系统/运行长度编码2.webp" alt="运行长度编码"><figcaption aria-hidden="true">运行长度编码</figcaption></figure><p><strong>位打包 bit packing</strong>：如果一个 integer属性的大小小于更定的数据类型的范围，可以减少需要表示每个值的位</p><figure><img src="/illustration/CMU%2015-445：数据库系统/位打包.webp" alt="位打包"><figcaption aria-hidden="true">位打包</figcaption></figure><p><strong>大部分编码 mostly encoding</strong>：bit packing中，有时会出现较大数的情况，需要以原始形式存储</p><figure><img src="/illustration/CMU%2015-445：数据库系统/大部分编码.webp" alt="大部分编码"><figcaption aria-hidden="true">大部分编码</figcaption></figure><p><strong>位映射编码 bitmap encoding</strong>：bitmap 中的第 i 位关联tuple 中的第 i 条，只有在基数很低的情况下使用</p><figure><img src="/illustration/CMU%2015-445：数据库系统/位映射编码.webp" alt="位映射编码"><figcaption aria-hidden="true">位映射编码</figcaption></figure><p><strong>delta 编码 deltaencoding</strong>：记录相同列中的值的差，可以同 RLE结合获得更好的压缩率</p><figure><img src="/illustration/CMU%2015-445：数据库系统/delta%20编码.webp" alt="delta 编码"><figcaption aria-hidden="true">delta 编码</figcaption></figure><p><strong>字典压缩 dictionarycompression</strong>：将值转化为固定长度的编码并维护一个从编码到原始数据的映射（字典），也是最常用的方法</p><figure><img src="/illustration/CMU%2015-445：数据库系统/字典压缩.webp" alt="字典压缩"><figcaption aria-hidden="true">字典压缩</figcaption></figure><p>字典结构</p><ul><li>数组</li><li>Hash 表</li><li>B+ 树</li></ul><h1 id="数据库内存-磁盘-io-管理-database-memory-disk-io-management">数据库内存&amp; 磁盘 I/O 管理 Database Memory &amp; Disk I/O Management</h1><ul><li>空间控制：在磁盘的哪里写页，目标是使在磁盘上的页物理上尽可能近</li><li>时间控制：何时将页读入内存，何时写进磁盘，目标是最小化从磁盘上读数据的停滞</li></ul><figure><img src="/illustration/CMU%2015-445：数据库系统/面向磁盘的数据库系统.webp" alt="面向磁盘的数据库系统"><figcaption aria-hidden="true">面向磁盘的数据库系统</figcaption></figure><p><strong>缓冲区组织 buffer pool organization</strong></p><p>内存区域组织为固定大小的页数组，每个数组项叫<strong>帧frame</strong>。当 DBMS 请求页时，一个复制被放到帧中，dirty pages被缓存，不会立刻写回磁盘（写回缓存）</p><p>buffer pool 的元数据：</p><ul><li><strong>页表</strong>跟踪当前内存中的页（通常是固定大小的被 latch保护的 hash 表）</li><li>dirty flag</li><li>pin 计数器：跟踪有多少 works 需要该页保留在内存中，防止被逐出</li><li>访问跟踪信息</li></ul><figure><img src="/illustration/CMU%2015-445：数据库系统/缓冲池的元数据.webp" alt="缓冲池的元数据"><figcaption aria-hidden="true">缓冲池的元数据</figcaption></figure><p><strong>lock</strong></p><ul><li>从其他事务中保护数据库的逻辑内容</li><li>在事务期间维持</li><li>需要能够回滚改变</li></ul><p><strong>latch</strong> 类似于 mutex，是一个较低级的概念</p><ul><li>从其他线程中保护 DBMS 内部数据结构的关键部分</li><li>在操作期间维持</li><li>不需要能够回滚改变</li></ul><p>分配策略</p><ul><li>全局策略</li><li>局部策略</li></ul><p><strong>多重缓冲池 multiple buffer pool</strong>，选择 buffer pool的方法：</p><ul><li>在 record id 中嵌入对象识别符</li><li>对页 id 使用 Hash</li></ul><p><strong>预获取pre-fetching</strong>：对于顺序或索引扫描，可以预先获取页</p><p><strong>扫描共享 scansharing</strong>：允许多重询问附着到一个扫描表的游标上</p><figure><img src="/illustration/CMU%2015-445：数据库系统/扫描共享.webp" alt="扫描共享"><figcaption aria-hidden="true">扫描共享</figcaption></figure><p><strong>缓冲区旁路 buffer poolbypass</strong>：顺序扫描操作不会在缓冲池中存储获取的页</p><p><strong>缓冲区替换策略 buffer replacementpolicies</strong>：决定要驱逐哪个页</p><p><strong>最近最少使用 least-recentlyused</strong>：维护每页最后访问的时间戳，选择最旧的时间戳对应的页逐出</p><figure><img src="/illustration/CMU%2015-445：数据库系统/最近最少使用.webp" alt="最近最少使用"><figcaption aria-hidden="true">最近最少使用</figcaption></figure><p><strong>钟 clock</strong>：不需要额外的时间戳的近似LRU，每页都有一个<strong>引用位</strong>，当被访问时，设为1。把页组织为一个环，有一个指针，当指到 0，则逐出</p><p>注意到以上两种方法都易受顺序洪水影响，即在 OLAP中，通常<strong>最近最多使用</strong>页是最佳的逐出的页</p><p><strong>LRU-K</strong>：通常是 LRU-2</p><p>近似方案：把 LRU 链表分为两——新的和旧的</p><ul><li>新页总是插入旧列表的头部</li><li>当旧列表中的页被访问时，插入到新列表头部</li></ul><p><strong>本地化 localization</strong>：DBMS 基于 query选择逐出的页</p><p><strong>优先提示 priority hints</strong>：DBMS提示缓冲池某页是否重要</p><p><strong>脏页 dirty page</strong>：</p><ul><li><strong>快</strong>速路径：如果某页<strong>不</strong>dirty，则可以直接丢弃它</li><li><strong>慢</strong>速路径：如果某页 dirty，则必须写回磁盘</li></ul><p><strong>后台写 background writing</strong>：周期性地遍历页表写回dirty 页到磁盘</p><p>注意到 OS 会重排合并 I/O 请求以最大化磁盘带宽，但不知道哪个 I/O请求更重要</p><p>大部分 DBMS 会还用直接 I/O 来旁路 OS 缓存以防止多余的页复制等</p><p><strong>fsync 错误</strong></p><h1 id="哈希表-hash-tables">哈希表 Hash Tables</h1><p>常用的 Hash 函数：Facebook XXHash</p><p>静态哈希策略：</p><ul><li><strong>线性探针哈希</strong><ul><li>对于删除操作，在被删除的地方放置一个特殊的“墓碑”</li><li>非唯一的键，一般将重复的键存在哈希表中</li></ul></li><li><strong>布谷鸟哈希</strong><ul><li>多个哈希函数</li></ul></li></ul><p>需要预先了解要储存的元素数量，否则需要重建哈希表</p><p><strong>链式哈希</strong></p><p><strong>布隆过滤器 Bloomfilter</strong>：回答所有权的概率数据结构（位图）</p><ul><li>false negative 不会出现</li><li>false positive 可能出现</li></ul><p><strong>可扩展哈希 extendible hashing</strong>：相当于分裂 bucket而不是无限增加 list 长度的链式哈希</p><p><img src="/illustration/CMU%2015-445：数据库系统/可扩展哈希.webp"></p><p><img src="/illustration/CMU%2015-445：数据库系统/可扩展哈希2.webp"></p><p><strong>线性哈希 linear hashing</strong>：维护跟踪下一个分裂的 bucket的指针，<strong>任何</strong> bucket 溢出时，分裂指针位置的bucket。使用多重哈希找到所给 key 的哈希位置</p><p><img src="/illustration/CMU%2015-445：数据库系统/线性哈希.webp"></p><p><img src="/illustration/CMU%2015-445：数据库系统/线性哈希2.webp"></p><p>如果最高的 bucket 空了，可以移除</p><h1 id="b-树索引-b-tree-indexes">B+ 树索引 B+ Tree Indexes</h1><p>泛化的二叉搜索树</p><p>性质：</p><ul><li>完美平衡</li><li>除了根以外的所有结点至少半满</li><li>每个 k 个键的内部结点有 k+1 个非空子结点</li></ul><p>在实现中，兄弟结点间有指针</p><p>叶结点的值：</p><ul><li>记录 id</li><li>tuple 数据</li></ul><p>B+ 树相比 B-树，区别在与只在叶结点存值，内部结点只用于导航搜索过程</p><p>插入时可能会分裂，删除时可能会合并</p><p>重复键：</p><ul><li>添加记录 id</li><li>溢出叶结点</li></ul><p><strong>聚类索引 clustered index</strong>：表以主键顺序存储</p><p>可变长度键：</p><ul><li>指针</li><li>可变长度结点</li><li>填充</li><li>键映射</li></ul><p>内部键搜索：</p><ul><li>线性</li><li>二分</li><li>插值</li></ul><p>优化：</p><ul><li><strong>前缀压缩 prefixcompression</strong>：相同叶结点中的排好序的键通常有相同的前缀</li><li><strong>重复删除deduplication</strong>：非唯一的索引可能在相同的叶结点中存多份，故只需一个键+ 值列表</li><li><strong>后缀截断 suffixtruncation</strong>：内部结点的键只用于导航，故不需要整个键，只需要前缀</li><li><strong>指针交换 pointer swizzling</strong>：如果一个页被 pin在缓冲池了，则可以直接储存原始指针而不是页 id，省去了查询页表</li><li><strong>大块插入 bulk insert</strong>：建立新 B+树时先给键排好序</li><li><strong>写优化 B+ 树 write-optimized B+tree</strong>：不是立即应用更新，而是在内部结点中存储修改日志，即 Bε-树，当日志存不下时，级联向下更新</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1
        
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://old-driver-zero.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="https://old-driver-zero.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="CMU" scheme="https://old-driver-zero.github.io/tags/CMU/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot</title>
    <link href="https://old-driver-zero.github.io/posts/a541262a.html"/>
    <id>https://old-driver-zero.github.io/posts/a541262a.html</id>
    <published>2024-03-17T04:20:02.000Z</published>
    <updated>2024-04-13T01:56:01.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="maven">Maven</h1><p><a href="https://maven.apache.org/">Maven</a> 可以用于管理 Java项目的依赖</p><p>在 <code>pom.xml</code> 文件中指定了 Maven 坐标，其构成如下：</p><ul><li><code>groupId</code>：通常是域名反写</li><li><code>artifactId</code>：通常是模块名称</li><li><code>version</code>：版本号</li></ul><p>引入依赖：在 <code>&lt;dependencies&gt;</code> 标签下，使用<code>&lt;dependency&gt;</code> 引入标签，并定义 Maven 坐标</p><p>依赖有传递性，可以使用 <code>&lt;exclusion&gt;</code>手动排除依赖的资源</p><p>使用 <code>&lt;scope&gt;</code> 设置其作用范围，通常使用默认的和<code>&lt;test&gt;</code></p><p>Maven 有 3 套独立的生命周期：</p><ul><li><strong>clean</strong></li><li><strong>default</strong>：编译、测试、打包、部署等</li><li><strong>site</strong>：生成报告、发布站点</li></ul><p>可以手动执行其中的若干个生命周期</p><h1 id="请求与响应">请求与响应</h1><p><a href="https://tomcat.apache.org/">Tomcat</a> 是一个轻量级的 web服务器，支持 Servlet 规范</p><p>几种请求参数：</p><p><strong>简单</strong>参数：名字一致，也可以使用一个对象接收多个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">GET http:<span class="hljs-comment">//localhost:8080/simpleParam?name=Tome</span><br><span class="hljs-meta">@RequestMapping(&quot;/simpleParam&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">simpleParam</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>数组</strong>集合：可以直接用数组封装或通过<code>@RequestParam</code> 绑定关系</p><p><strong>日期</strong>参数：使用 <code>@DateTimeFormat</code>转换格式，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/dateParam&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">dateParam</span><span class="hljs-params">(<span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span> LocaoDateTime updateTime)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>json</strong> 参数，使用 <code>@RequestBody</code>封装到参数中</p><p><strong>路径</strong>参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/path/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">pathParam</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>控制器类外面加上 <code>@RestController</code> 注解，实现一个 RESTful服务器，可以自动返回一个 json 对象</p><p>分成三层架构：</p><ul><li><strong>controller</strong>：接受前端的请求并响应数据</li><li><strong>service</strong>：处理具体的业务逻辑</li><li><strong>dao</strong>：负责数据访问操作，即增删改查</li></ul><p>为了实现<strong>高内聚低耦合</strong>，spring 使用到了</p><ul><li><strong>控制反转 inversion ofcontrol（IOC）</strong>：对象的创建控制权由程序自身转移到容器</li><li><strong>依赖注入 dependencyinjection（DI）</strong>：容器为程序提供运行时所依赖的资源</li><li><strong>bean</strong>：IOC 容器中创建、管理的对象</li></ul><p>要把某个对象交给 IOC 容器管理，需要加上以下注解之一：</p><ul><li><code>@Controller</code>：控制器</li><li><code>@Service</code>：业务类</li><li><code>@Repository</code>：数据访问类</li></ul><p>以上三者和 <code>@Component</code>没有什么区别，只是为了区分而取了不同的名字</p><p>可以通过 <code>value</code> 属性知道 bean的名字，如果没有，则默认为类<strong>首字母小写</strong></p><p>想要被组件扫描到需要 <code>@ComponentScan</code>，而<code>@SpringBootApplication</code> 中默认扫描的是所在类的包及子包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootHelloWorld</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(SpringBootHelloWorld.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 bean 对象时使用 <code>@Resource</code>注解指定要使用注入哪一个实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource(name = &quot;empServiceB&quot;)</span><br><span class="hljs-keyword">private</span> EmpService empService;<br></code></pre></td></tr></table></figure><h1 id="mysql">MySQL</h1><p>登录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql -u用户名 -p密码 [-h服务器IP地址 -P端口号]<br></code></pre></td></tr></table></figure><p>查询所有数据库：<code>show databases;</code></p><p>查询当前数据库：<code>select database();</code></p><p>使用数据库：<code>use 数据库名;</code></p><p>创建数据库：<code>create database 数据库名;</code></p><p>删除数据库：<code>drop database 数据库名;</code></p><p>其中的 <code>database</code> 也可以替换为 <code>schema</code></p><p>一些数据类型：<code>char</code>、<code>varchar</code>、<code>text</code>、<code>int</code>、<code>double</code>、<code>date</code>、<code>datetime</code>等</p><p><code>comment 注释</code></p><p>修改表：<code>alter table 表名</code></p><ul><li>添加：<code>add</code></li><li>修改类型：<code>modify 字段名 新数据类型</code></li><li>修改字段名和类型：<code>change 旧字段名 新字段名 类型</code></li><li>删除：<code>drop column 字段名</code></li><li>修改表明：<code>rename table 表名 to 新表名</code></li></ul><p>添加数据：<code>insert into 表名（字段1，字段2） values （值1，值2);</code></p><p>更新数据：<code>update 表名 set 字段名1 = 值1 [where 条件]</code></p><p>删除数据：<code>delete from 表名</code></p><h1 id="mybatis">MyBatis</h1><p>需要引入的依赖有 <code>MyBatis</code> 和响应的数据库驱动（如<code>MySQL Driver</code>）</p><p>然后配置用户信息，如：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/mybatis</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">1234</span><br></code></pre></td></tr></table></figure><p>定义对象模型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure><p>并定义 <code>Mapper</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <span class="hljs-meta">@Select(&quot;select * from user&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">list</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>JDBC 是使用 Java 语言操作关系型数据库的一套API，比较原始，所以才要使用 MyBatis 简化</p><p>数据库连接池是一个容器，负责分配、管理数据库连接，产品有Druid、Hikari 等</p><p>Lombok 可以通过注解的形式自动生成构造器，如</p><table><colgroup><col style="width: 25%" /><col style="width: 74%" /></colgroup><thead><tr class="header"><th>注解</th><th>作用</th></tr></thead><tbody><tr class="odd"><td><code>@Data</code></td><td><code>@Getter</code> + <code>@Setter</code> + <code>@ToString</code>+ <code>@EqualsAndHashCode</code></td></tr><tr class="even"><td><code>NoArgsConstructor</code></td><td>无参构造函数</td></tr><tr class="odd"><td><code>AllArgsConstructor</code></td><td>有各参数的构造函数</td></tr></tbody></table><p>一个使用参数删除的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Delete(&quot;delete from emp where id = #&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Integer id)</span>;<br></code></pre></td></tr></table></figure><p>注意如果使用的是 <code>$&#123;...&#125;</code>，则是直接将参数拼接在 SQL语句中</p><p>如果想要新增数据并获取返回的逐渐，则加上注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Options(keyProperty = &quot;id&quot;, useGeneratedKeys = true)</span><br></code></pre></td></tr></table></figure><p>因为数据库中用下划线分割，代码中用驼峰命名法，所以需要打开自动转换的开关：<code>mybatis.configuration.map-underscore-to-camel-case=true</code></p><p>XML 映射文件与 Mapper 接口同包同名，支持动态查询，</p><p>如 <code>if</code>（<code>where</code> 标签可以自动处理掉多余的<code>and</code> 等）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span><br>    select id, username from emp<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>            name like concat(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;)<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender != null&quot;</span>&gt;</span><br>            and gender = #&#123;gender&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>同理，还有 <code>&lt;set&gt;</code> 标签，用于 <code>update</code>语句中</p><p>一个使用 <code>&lt;foreach&gt;</code> 循环生成的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteByIds&quot;</span>&gt;</span><br>delete from emp where id in<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">seperator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> &gt;</span><br>        #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><p>不少 sql 片段有重用，可以使用 <code>&lt;sql id="名字"&gt;</code>并使用 <code>&lt;include refid="名字"&gt;</code> 来引用</p><h1 id="登录">登录</h1><p>这里使用 JWT 令牌校验，依赖为 <code>jjwt</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">genjwt</span><span class="hljs-params">()</span>&#123;<br>    Map&lt;String,Object&gt; claims =<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&gt;();<br>    claims.put(<span class="hljs-string">&quot;id&quot;</span> ,<span class="hljs-number">1</span>);<br>    claims.put(<span class="hljs-string">&quot;username&quot;</span> , <span class="hljs-string">&quot;Tom&quot;</span> );<br>    <span class="hljs-type">String</span> <span class="hljs-variable">jwt</span> <span class="hljs-operator">=</span> Jwts.builder()<br>        .setClaims(claims) <span class="hljs-comment">// 自定义内容（载荷）</span><br>        .signWith(SignatureAlgorithm.HS256, <span class="hljs-string">&quot;itheima&quot;</span>) <span class="hljs-comment">// 签名算法</span><br>        .setExpiration(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(System.currentTimeMillis() + <span class="hljs-number">12</span>*<span class="hljs-number">3600</span>*<span class="hljs-number">1000</span>)) <span class="hljs-comment">// 有效期</span><br>        .compact();<br>    System.out.println(jwt);<br>&#125;<br></code></pre></td></tr></table></figure><p>解析令牌：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parsejwt</span><span class="hljs-params">()</span><span class="hljs-params">(</span><br><span class="hljs-params">    Claims claims =Jwts.parser()</span><br>        .setSigningKey(<span class="hljs-string">&quot;itheima&quot;</span>) <span class="hljs-comment">// 指定签名秘钥</span><br>.parseClaimsjws(<span class="hljs-string">&quot;eyJhbGciOijIUzI1Nij9.eyJpZCI6MSwiZXhwljoxNjU50Tk1NTE3LCJ1c2VybmFtZSI6IlRvbSJ9.EUTfeqPkGslekdKBezcWCe7a7xbcllwB1MXllccTMwo&quot;</span>) <span class="hljs-comment">// 解析令牌</span><br>        .getBody();<br>System.out.printin(claims);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>拦截器 interceptor</strong> 用于拦截错误请求</p><p>首先定义拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Override</span> <span class="hljs-comment">// 目标资源方法执行前执行，放回true：放行，返回false：不放行</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    System.out.println(<span class="hljs-string">&quot;preHandle ...&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-meta">@Override</span> <span class="hljs-comment">// 目标资源方法执行后执行</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, Object handler, ModelAndView modelAndView)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;postHandle ...&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span> <span class="hljs-comment">// 视图渲染完毕后执行，最后执行</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, Object handler, Exception ex)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;afterCompletion...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后注册拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoginCheckInterceptor loginCheckInterceptor;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(loginCheckInterceptor).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于异常处理，定义一个全局异常处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandle</span> &#123;<br>    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span>;<br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">ex</span><span class="hljs-params">(Exception ex)</span> &#123;<br>        ex.printStackTrace();<br>        <span class="hljs-keyword">return</span> Result.error(<span class="hljs-string">&quot;操作无效&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="杂项">杂项</h1><p><strong>分页查询：</strong></p><p>引入依赖：<code>pagehelper-spring-boot-starter</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">PageHelper.startPage(pageNum, pageSize);<br>List&lt;Emp&gt; list = empMapper.list();<br>Page&lt;Emp&gt; page = (Page&lt;Emp&gt;)list();<br></code></pre></td></tr></table></figure><p>也可以直接在 SQL 语句中使用 <code>limit</code> 实现</p><p><strong>参数配置化：</strong></p><p>外部服务的配置信息可以定义在 <code>application.yml</code>中，然后在代码中引用，如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">aliyun:</span><br><span class="hljs-attr">oss:</span><br><span class="hljs-attr">endpoint:</span> <span class="hljs-string">https://oss-cn-hangzhou.aliyuncs.com</span><br></code></pre></td></tr></table></figure><p>然后获取该配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.endpoint&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String endpoint;<br></code></pre></td></tr></table></figure><p>当然，因为有共同的前缀 <code>aliyun.oss</code>，可以使用<code>@ConfigurationProperties</code> 合并：</p><p>引入依赖：<code>spring-boot-configuration-processor</code>，然后在类前面加上注解<code>@ConfigurationProperties(prefix = "aliyun.oss")</code>保持变量和配置名称相同即可自动配置</p><h1 id="文件上传">文件上传</h1><p>获取的是一个<code>MultipartFile</code>，同时因为可能出现文件名重复的问题，要使用一个随机的<code>UUID</code> 给文件命名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UploadController</span> &#123;<br>    <span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile image)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 获取原始文件名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> image.getOriginalFilename();<br>        <span class="hljs-comment">// 构建新的文件名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">newFilename</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString()<br>            + originalFilename.substring(originalFilename.lastindexOf(<span class="hljs-string">&quot;.&quot;</span>));<br>        <span class="hljs-comment">// 将文件保存在服务器端 E:/images/ 目录下</span><br>        image.transferTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:/images/&quot;</span> + newFilename));<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以在 <code>application.yml</code> 中修改上传文件大小的限制：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br><span class="hljs-attr">servlet:</span><br><span class="hljs-attr">multipart:</span><br><span class="hljs-attr">max-file-size:</span> <span class="hljs-string">10MB</span>  <span class="hljs-comment"># 单个文件上传大小限制</span><br><span class="hljs-attr">max-request-size:</span> <span class="hljs-string">100MB</span> <span class="hljs-comment"># 多个文件上传大小限制</span><br></code></pre></td></tr></table></figure><h1 id="事务管理">事务管理</h1><p><strong>事务</strong>是一组操作的集合，这些操作要么<strong>同时成功</strong>，要么<strong>同时失败</strong></p><ul><li>开启事务</li><li>提交事务</li><li>回滚事务</li></ul><p>开启事务：在 <code>service</code> 层的方法上、类上、接口上添加注解<code>@Transactional</code></p><p>默认情况下，只有 <code>RuntimeException</code>才回滚异常，可以手动配置出现何种异常类型时回滚事务：<code>@Transactional(rollbackFor = Exception.class)</code></p><p>事务传播行为：当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制</p><ul><li><code>REQUIRED</code>：默认值，有则加入，无则创建新事物</li><li><code>REQUIRES_NEW</code>：无论有无，总是创建新事物</li></ul><p>还有很多其他的属性，设置方法：<code>@Transactional(propagation = Propagation.REQUIRES_NEW)</code></p><h1 id="aop">AOP</h1><p><strong>AOP (Aspect Oriented Programming) 面向切面编程</strong></p><p>导入依赖：<code>spring-boot-starter-aop</code></p><p>一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeAspect</span> &#123;<br>    <span class="hljs-meta">@Around(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">recordTime</span><span class="hljs-params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> proceedingJoinPoint.proceed(); <span class="hljs-comment">// 调用原始方法运行</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        log.info(proceedingJoinPoint.getSignature() + <span class="hljs-string">&quot;执行耗时：&#123;&#125;ms&quot;</span>, end - begin);<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>核心概念：</p><ul><li><strong>连接点 JoinPoint</strong>：可以被 AOP 控制的方法</li><li><strong>通知 Advice</strong>：共性功能</li><li><strong>切入点 PointCut</strong>：匹配连接点的条件</li><li><strong>切面 Aspect</strong>：描述通知与切入点的对应关系</li><li><strong>目标对象 Target</strong>：通知所应用的对象</li></ul><p>通知类型：</p><ul><li><code>@Around</code>：在前、后都执行</li><li><code>@Before</code>：前</li><li><code>@After</code>：后</li><li><code>@AfterReturning</code>：返回后通知，有异常不会执行</li><li><code>@AfterThrowing</code>：异常后通知</li></ul><p>注意 <code>@Around</code> 需要自己调用<code>proceedingJoinPoint.proceed()</code> 来让原始方法运行</p><p>通知顺序：用 <code>@Order(数字)</code> 来控制顺序</p><ul><li>前：数字小的先执行</li><li>后：数字小的后执行</li></ul><p>切入点表达式：</p><p><code>execution</code>：根据方法的签名匹配</p><ul><li>格式为<code>execution(访问修饰符? 返回值 包名.类名.?方法名(方法参数) throws 异常?)</code></li><li><code>*</code> 单个独立的任意符号</li><li><code>..</code> 多个连续的任意符号</li></ul><p><code>@annotation</code>：根据注解匹配</p><p>先自定义一个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Mylog &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在需要目标对象前加上 <code>@Mylog</code> 即可</p><p>设置通知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(&quot;@annotation(com.itheima.aop.Mylog)&quot;)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pt</span><span class="hljs-params">()</span> &#123; &#125;<br><br><span class="hljs-meta">@Before(&quot;pt()&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;<br>    log.info(<span class="hljs-string">&quot;MyAspect&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>连接点可以获取方法执行时的目标类名、方法名等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(* com.*(..))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> joinPoint.getTarget().getClass().getName(); <span class="hljs-comment">// 获取目标类名</span><br>    <span class="hljs-type">Signature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> joinPoint.getSignature(); <span class="hljs-comment">// 获取目标方法签名</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName(); <span class="hljs-comment">// 获取目标方法名</span><br>    Object[] args = joinPoint.getArgs(); <span class="hljs-comment">// 获取目标方法运行参数</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;maven&quot;&gt;Maven&lt;/h1&gt;
&lt;p&gt;&lt;a
        
      
    
    </summary>
    
    
      <category term="工具" scheme="https://old-driver-zero.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="https://old-driver-zero.github.io/tags/Java/"/>
    
      <category term="web" scheme="https://old-driver-zero.github.io/tags/web/"/>
    
      <category term="Spring Boot" scheme="https://old-driver-zero.github.io/tags/Spring-Boot/"/>
    
      <category term="数据库" scheme="https://old-driver-zero.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>这一切值得吗</title>
    <link href="https://old-driver-zero.github.io/posts/828c2ccd.html"/>
    <id>https://old-driver-zero.github.io/posts/828c2ccd.html</id>
    <published>2024-03-15T01:00:00.000Z</published>
    <updated>2024-04-17T00:34:06.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="城市没有消亡但这一切值得吗">城市没有消亡，但这一切值得吗？</h1><p>这是这款游戏引起争议的很重要的一点，人们纷纷给它贴上了“白左”的标签。的确，末日到来了，老子辛辛苦苦把这么多人救了下来，居然还这样居高临下地问我值不值得，难怪被喷得体无完肤。</p><p>但是，当我真正地深入了解这款游戏之后，才发现这完全是很多不良媒体的断章取义导致的。上述所谓的“越界”结局并不是一定会触发的，而且“越界”的条件也不是“童工”、“木屑餐”、“加班”等“自由民主”的西方“人权”口号，而是选择成为了一个独裁者或新教皇。事实上，这些被称为“越界法典”的法典并不会增加生产效率，其目的只是维护自己的统治。要知道，当不满拉满或者希望归零时失败的是玩家，是玩家被赶了出去，然后会有一个新的人被选出来成为新的领导者（就是“冬日之家”中玩家扮演的角色），所以说，玩家失败了，城市就会消亡吗？这并不一定。</p><p>不过游戏做的也不好。越界法典和普通法典没有什么不同，导致很多玩家都以为这个和科技树一样一直点到头就行了，谁知道有些法典是不能点的。如果都像“最后的秋天”中的法典一样写着令人毛骨悚然的“每天都有一个人被处死”，大概就不会有这么多人毫不犹豫地点开这个法典了。还有游戏的剧情和设定没有什么变数，总是出现固定的流程，确实恶心人。</p><h1 id="刁民还是人民">刁民还是人民？</h1><p>这款游戏又被称为《刁民模拟器》，理由是都世界末日了，这些刁民还要喝酒、吃肉、要住房、不加班，一个个就像大爷一样要玩家伺候。</p><p>这就是所谓的“站着说话不腰疼”了。在零下几十度的天气，你还能打地铺？夜间更是寒冷，还能正常工作？至于所谓的8 小时工作制根本就是不存在的（除了最后的秋天），起步就是 10小时工作时长，甚至还能一天工作 14小时。至于吃饭问题，“刁民们”也不是一天不吃饭就会饿死的<del>不过居然敢在工作时间吃饭，不会下班之后再去吃吗？</del>最后是末日中的“希望”和“不满”问题，或许大多是被《流浪地球》等电影中人类众志成城的剧情给洗脑了，事实上即使是在集体主义中，没有了个人的“希望”与“不满”，还是会有集体的“希望”和“不满”。</p><p>再来看看他们都干了些什么。先不提那些抱着几根木头就能在零下几十度的低温下到处乱跑的侦查队，这是绝对的神；也不提那些每天夜里都能带回来大量食物的猎人，这些都是超人。就谈谈被在“暖和”的工作站工作的人和驾驶着机器的人吧。尽管他们总是怨声载道，却从未闹出罢工和偷懒的事情，总是能够完成指挥官交给他们的任务，甚至还利用晚上休息的时间建房子。所以说，这款游戏反对的是利用“末日”为借口为自己谋取利益的人，而不是所谓的反对牺牲个人的利益来换取人类的生存。</p><p>当矿井发生事故时，有人挺身而出，解决了矿井的问题，却再也没有回来。回来的是希望，当希望条因他们的牺牲而上升时，感动的不止是游戏中的NPC。当有人主动留下来维护损坏的能量塔时，“刁民”和“英雄”本没有区别。</p><h1 id="城市消亡了吗">城市消亡了吗？</h1><blockquote><p>我们拯救了所有的种子库，但是更重要的是，我们拯救了新曼彻斯特。我们殊死一搏，拯救了我们的人性，让那成为我们的遗产。</p><p>——方舟</p></blockquote><p>《方舟》中的那些科学家让我敬佩，他们保全的种子库可以说是为未来保留了希望。但是在完美结局中，他们表示<strong>更重要的是</strong>拯救了新曼彻斯特，拯救了我们的<strong>人性</strong>，他们并没有见死不救，也不是以“有更重要的任务在身”而推脱，而是勇于奋力一搏，留下来末日中的人性这一最宝贵的遗产。</p><blockquote><p>最大的威胁，并不是暴风雪，而是纷争</p><p>——帝国的边界</p></blockquote><p>《帝国的边界》中的游戏性是我认为最差的，但是其意图传达的道理却是我觉得最好的。这一关卡的最优解就是和各前哨站搞好关系，互通有无，然后齐心协力拯救新伦敦。面对困难，只有团结一致，才能取得胜利。</p><p>还有《难民》完美结局中，平民和贵族实现了阶级平等，但是 Craven大人在主动离开之前给指挥官留下的检验是——权力会腐化。之前看过一个问题，说是P社玩家总是能够扮演千古一帝，实现绝地反击，是因为在游戏中他们总是能够心无旁骛地为了实现游戏的目标而行动，所以必然会扮演一个“明君”。但是事实上，权力大的人面临着太多的诱惑，所以权力会腐化，屠龙者终成恶龙。</p><p>这里牵扯到一个有意思的话题——都知道屠龙容易，防止屠龙者变成恶龙难，那有没有什么好的方法防止这件事发生呢？如果自己是屠龙者，应该怎么做？我想，屠龙者应该真正地了解自身，知道自己的能力范围究竟如何，超出自己能力范围的馈赠不可接受，因为终有一天会为此付出代价的。</p><blockquote><p>这一次，我想，但是我们并没有越界。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1
        
      
    
    </summary>
    
    
      <category term="游戏人生" scheme="https://old-driver-zero.github.io/categories/%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="冰汽时代" scheme="https://old-driver-zero.github.io/tags/%E5%86%B0%E6%B1%BD%E6%97%B6%E4%BB%A3/"/>
    
      <category term="末日求生" scheme="https://old-driver-zero.github.io/tags/%E6%9C%AB%E6%97%A5%E6%B1%82%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>人类的赞歌就是勇气的赞歌</title>
    <link href="https://old-driver-zero.github.io/posts/353e70c9.html"/>
    <id>https://old-driver-zero.github.io/posts/353e70c9.html</id>
    <published>2024-03-06T00:17:22.000Z</published>
    <updated>2024-03-07T00:17:22.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="下去四个疯了五个">下去四个，疯了五个</h1><p>早就听说过这款游戏的大名，同时也早就准备好了不当人的准备，但当我看到辛辛苦苦培养出的高级英雄就这样被全灭了的时候，还是有种想要重开的准备。当然，相比这部游戏的世界观，这还不算残酷，毕竟是克苏鲁世界。</p><p>这游戏入门的第一个标准就是要不做人，那些英雄并不是我的伙伴，只是一个个工具人而已，只有高级的建筑和饰品才是我最重要的宝贝。当然，他们也不是什么好东西，有杀人的强盗，有光明神偷十字军，还有盗墓贼等等，除了麻风以外都是无可救药的罪犯。当我要指望他们绝地反击的时候，总是miss，或者是暴击 0 +流血，没太大的能力还总是高傲地不愿意下低级本提携后辈。</p><h1 id="人类的赞歌">人类的赞歌</h1><p>虽然嘴上这么说，但当东征成功的麻风吟诵起诗歌来时，当圣矛刺穿邪恶的后配敌人时，当三<del>四</del>个角色绝望中一个人爆美德逆转了战局时，我不由得感叹——人类的赞歌就是勇气的赞歌。畏惧、自私都不是他们的错，他们以普通的人类之躯，却挺身对抗古神，这一切无不体现了他们的伟大，还有人类的伟大。面对死亡，有人大无畏地说“不洁的邪恶，我要和你同归于尽”，有人英雄般地说“饶了其他人，我已经准备好了”，还有人大喊“人人为我，我为人人”，无不让人感动落泪。</p><h1 id="在老路上我们寻得了救赎">在老路上，我们寻得了救赎</h1><p>这个游戏中绝大多数人都有不堪回首的过去，或者说是困扰他们的噩梦，也并非所有人最终都能被称为“完美的英雄”，可正是这些污点才让他们的形象更加真实而立体<del>指畏光的光明战士，多情+重口味</del>。正如老路双雄的成就所言：在老路上，我们寻得了救赎。</p><h2 id="老路双雄十字军-强盗">老路双雄——十字军 &amp; 强盗</h2><blockquote><p>不洁的邪恶，我要和你同归于尽</p></blockquote><p>雷老大，一个让人又爱又恨的角色，我第一个去的怪癖就是他的盗窃癖。他的故事并没有什么特别的，或许是为了信仰，或许是为了生存，他带着妻儿的期望参军，离家万里，却养成了偷偷摸摸的怪癖，双手沾满了鲜血。他已不再是当年的那人意气风发的丈夫和父亲了，没脸去和她们团聚了。来到哈姆雷特小镇，或许是他对自己的自我放逐。圣矛能刺穿一切的邪恶，却无法击败他内心的邪秽。</p><blockquote><p>没有退路了。哼，让我们开干吧。</p></blockquote><p>迪马斯，“反应迅速”是他的神级怪癖，却造成了他不堪回首的往事——错杀了一对母女。他与一般的强盗是不同的，“不杀女人和小孩”与其说是他坚守的信念，到不如说是他一直自我安慰的借口。如今希望破灭了。</p><h2 id="诗人剑客国王麻风">诗人、剑客、国王、麻风</h2><blockquote><p>秋前盛夏，凌晨腾雾</p><p>林中落雨，花瓣飘落</p><p>血泥相间，潮起潮落</p></blockquote><p>当麻风开始吟诵起诗歌来时，一切都会好起来的。</p><p>麻风是我在整个游戏中最喜欢的角色，不光是因为他一击超高伤害的爽感<del>界徐盛人称“小麻风”</del>，还是被他暴击时吟诵诗歌的才华吸引，更是在了解了他的背景故事后为他的英雄气概而动容。他的成就远远超越了他的历史原型——麻风王鲍德温，他爱民，维护了国家的稳定，即使是在生命的最后也展现出其王者的气概：</p><blockquote><p>饶了其他人，我已经准备好了</p></blockquote><p>他的两件装备的名字是对他的最好评价：</p><blockquote><p>残破其刃，坚毅其心</p></blockquote><h2 id="破盾者-咒缚者">破盾者 &amp; 咒缚者</h2><blockquote><p>又一次梦魇，是我最后一次起舞时再合适不过的观众</p></blockquote><p>与弩手同样有灾难的经历，但破盾相当坚强，反击奴隶主，斩断自己的一条手臂，蛇成了她的梦魇，几乎每次睡觉都会梦到蛇来袭击。愿你以后不再做噩梦。</p><blockquote><p>不管等着我的是什么，它都不会比我忍受过的更糟糕。</p></blockquote><p>狼人的经历同样悲惨，作为实验的产物，他只有一个破损的人生，却依然能够处之泰然</p><h2 id="修女-瘟疫医生-弩手">修女 &amp; 瘟疫医生 &amp; 弩手</h2><blockquote><p>不要选我，我是个博学的学者——瘟疫医生</p><p>这……这太可怕了！不！！！！——修女</p><p>不，不要！我想活下去！</p></blockquote><p>相比之下，这几个人的遗言实在是算不得英雄，毕竟他们的经历也并没有什么大不了的，对知识的渴望、对爱情的渴望、对生存的渴望，这不都是些普通人吗？他们能够站在这里，就已经是英雄了</p><h2 id="训犬师">训犬师</h2><blockquote><p>冷静，姑娘。如果叫到了我们，我们回应就是。</p></blockquote><p>狗哥也是真男人，他作为一个警员，追捕犯人，最终发现警长也参与其中。但他信仰崩塌了吗？“我会追寻罪恶，直到天涯海角”</p><h2 id="古董商人-神秘学者">古董商人 &amp; 神秘学者</h2><blockquote><p>所以我是最后的古董，也没有东西值得去到处收集了……</p></blockquote><p>古董商人在游戏中是纯工具人，在剧情中也是一个纯恶人。按理说这种人一定要有的一个特质就是贪婪，但在他临终之时的泰然让我惊讶</p><blockquote><p>终于，要面对我的施虐者了。那么，来吧。</p></blockquote><p>阿三在游戏中绝对是让所有人又爱又恨的英雄，每每到关键时刻总是掉链子，但其能力相对突出，故出场率较高</p><h2 id="小丑-盗墓贼">小丑 &amp; 盗墓贼</h2><blockquote><p>哈哈！这个笑话的主角轮到我了……？</p></blockquote><p>相当符合小丑的台词，诛杀暴君，以一场完美的谢幕离去。相对于其他人满是阴影的生活，小丑的一生颇为潇洒</p><blockquote><p>一个正派的女士不会自愿去受死！</p></blockquote><p>“但我不是一个正派的女士”，是她的潜台词，<del>这就是盗墓的技能黑色幽默吧</del>。有趣的自嘲与勇敢的女士，正如她的自嘲一样，盗墓究竟是好是坏，很难评说。</p><h2 id="蛮族战士-老兵">蛮族战士 &amp; 老兵</h2><blockquote><p>那就送我去地狱吧！啊咔嗷噢噢噢啊——</p></blockquote><p>在族人被灭族时，她选择了逃跑，这成了她一生的折磨，然而这一次，她没有选择再逃避，而是勇敢的面对</p><blockquote><p>我走得问心无愧。我已经付出了我的全部。</p></blockquote><p>他偿还了自己的罪孽，他已经付出了全部来守护他的队友，这一次，他挺身而出</p><h2 id="火枪手">火枪手</h2><blockquote><p>人人为我，我为人人</p></blockquote><p>出自大仲马的《三个火枪手》，虽说只是致敬，但可以看出是真正的无私。不过这位暴躁老姐的经历实在是过于传奇了，在比赛时因为古神的干扰而输掉了比赛，然后就很生气，过来要杀了古神。毕竟是一个免费的DLC，无论是技能还是人物设定都在搞怪</p><h2 id="苦修者">苦修者</h2><blockquote><p>我已经等它很久了！别从我这里夺走这样的机会！！！</p></blockquote><p>苦修是全地牢中最奇葩的一个角色，折磨只会进入狂喜，甚至在二代中还能与死神有来有回。我不懂，但我大受震撼</p><h2 id="赏金猎人">赏金猎人</h2><blockquote><p>……哼。</p></blockquote><p>典型的人狠话不多的角色</p><h1 id="少女地牢">少女地牢</h1><p>什么，原版画风太 18 禁了？那就打上 mod 吧，<del>让游戏成为真正的18+</del></p><p>什么，原版难度太大了？那就打上 mod吧，<del>各种二次元角色带你秒天秒地</del></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1
        
      
    
    </summary>
    
    
      <category term="游戏人生" scheme="https://old-driver-zero.github.io/categories/%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="暗黑地牢" scheme="https://old-driver-zero.github.io/tags/%E6%9A%97%E9%BB%91%E5%9C%B0%E7%89%A2/"/>
    
      <category term="克苏鲁" scheme="https://old-driver-zero.github.io/tags/%E5%85%8B%E8%8B%8F%E9%B2%81/"/>
    
  </entry>
  
  <entry>
    <title>潜行大师康师傅</title>
    <link href="https://old-driver-zero.github.io/posts/7f92999e.html"/>
    <id>https://old-driver-zero.github.io/posts/7f92999e.html</id>
    <published>2024-03-03T00:17:22.000Z</published>
    <updated>2024-04-14T06:10:03.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="infoBox"style="max-width:100%;border-left: 10px solid #808080;"><div class="infoBoxContent"><div class="infoBoxIcon"><div class="center"><div class="floatnone"><img width="118px" height="143px" style="float:left; margin: 5px;" src="/illustration/刺客信条.webp"></div></div></div><div class="infoBoxText" style="color:#778899"><center style="font-size:1.5em;line-height:1;font-family:Times New Roman;font-style:italic;color:#FF0000"><b>A S S A S S I N ’ S</b><br><b>C R E E D</b></center><center><b><span style="font-size:0.9em"><spanstyle="font-family:Times New Roman;font-style:italic"> <strong>Nothingis true, everything is permitted.</strong> </span></span></b><br> <spanstyle="font-size:0.8em">当其他人盲目追寻真相的时候，记住——<strong>万物皆虚。</strong><br />当其他人受到法律或道德束缚的时候，记住——<strong>万事皆允。</strong><br />我们服侍光明却耕耘于黑暗——我们是<strong>刺客</strong></span></center></div></div></div><h1 id="潜行大师">潜行大师</h1><p>玩了这一作之后我终于知道为什么康师傅被称为“潜行大师”了，不是开起无双来是多么容易，而是这一作的潜行太难了。我不就顺手杀了一个守卫嘛，一瞬间就整座城的守卫来围攻我了，害得我只好收起袖剑，拔出我的战斧开无双了。这一作的守卫就不会像二代一样睁一只眼闭一只眼，这样就能明哲保身了嘛。</p><figure><img src="/illustration/刺客信条：康纳/二代小兵.gif" alt="二代小兵" /><figcaption aria-hidden="true">二代小兵</figcaption></figure><h1 id="时代的洪流">时代的洪流</h1><p>从剧情的深刻程度上来说，这一作比前作更优秀。从完美同步的条件来看，康纳毫无疑问是更强的刺客，但他面对的敌人也更加强大。更何况，他几乎没有队友，自己的族人不信任他，他帮助的华盛顿等人背叛了他，阿基里斯已经老了，且实在不够睿智，他的父亲也因为信仰的不同站在他的对立面……</p><blockquote><p>你挥剑像个战士，想法却像个孩子。</p></blockquote><p>尽管康纳的战斧可以以一人之力单挑成百上千个敌人，但他终究只是时代的汪洋中的一叶小舟，尽管奋力破浪，却一次次地被时代的浪潮推走。</p><h1 id="刺客和圣殿骑士">刺客和圣殿骑士</h1><p>如果说在之前的作品中，圣殿骑士总是作为反派出现的话，在这一作中其形象更加丰满。刺客和圣殿骑士并没有什么好坏之分，刺客追求自由，圣殿骑士崇尚秩序，但这两者只是手段，其最终目的都是推动人类的发展。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;div
        
      
    
    </summary>
    
    
      <category term="游戏人生" scheme="https://old-driver-zero.github.io/categories/%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="刺客信条" scheme="https://old-driver-zero.github.io/tags/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A1/"/>
    
  </entry>
  
  <entry>
    <title>为美好的世界献上祝福</title>
    <link href="https://old-driver-zero.github.io/posts/fda4520e.html"/>
    <id>https://old-driver-zero.github.io/posts/fda4520e.html</id>
    <published>2024-02-29T00:17:22.000Z</published>
    <updated>2024-03-07T00:17:22.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div id="aplayer-oSEOhviA"class="aplayer aplayer-tag-marker meting-tag-marker" data-id="456175210"data-server="netease" data-type="song" data-mode="random"data-autoplay="false" data-listmaxheight="340px" data-preload="auto"data-theme="#e3f2f5" data-volume="0.4" data-mutex="true"></div><h1 id="美好世界">美好世界</h1><p>能够让人眼前一亮的异世界作品，如果要深究起整个故事的背景，或许是比较灰暗的，敌人异常地强大。但是这部作品并没有像普通的异世界作品那样集中笔墨于异世界的冒险故事，人设、后宫、背景、搞笑都只是陪衬，目的是突出这种已经被用烂了的冒险桥段。而是别出心裁，着重刻画主人公们在异世界的打打闹闹的生活（搬砖、piaochang），还有异世界的风土人情（红魔族和阿库西斯教团），还有那些善良而有趣的“NPC”（道具店老板），而所谓的“冒险”和对抗魔王只是顺手做的事情。</p><p>正如这两季的 ed中所表现出来的安逸、和谐、平静的田园生活，还有共同奋斗的伙伴和友善的居民，这一切才组成了最令人向往的异世界生活。</p><p>还是那句话，异世界最重要的是“世界”</p><h1 id="explosion">explosion</h1><p>关于惠惠的外传看了，确实很不错，但感觉和正篇还是差了许多。三分逗七分捧，红魔族都是犯傻的天才，但是没有和真这样的吐槽役，乐趣就少了许多。</p><h1 id="总结">总结</h1><p>这支队伍可以算是完美的组合了，<del>有人偷胖次，有人被偷胖次，有人想被偷胖次，还有人没有胖次</del></p><p>最后送出我衷心的祝福：</p><blockquote><p>祝你拥有水之女神阿库娅般的智慧，拥有贵族大小姐拉拉蒂娜·福特·达斯缇妮斯的气质，拥有惠惠般美好的梦想和言谈技巧，拥有悠悠般的社交技术，维兹般的经商头脑，以及红魔族般美丽优雅的名字和厄里斯般曼妙的身材</p></blockquote><p>无论何时何地，请牢记于心：</p><blockquote><p>厄里斯的胸是垫出来的！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;div
        
      
    
    </summary>
    
    
      <category term="ACG杂谈" scheme="https://old-driver-zero.github.io/categories/ACG%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="异世界" scheme="https://old-driver-zero.github.io/tags/%E5%BC%82%E4%B8%96%E7%95%8C/"/>
    
      <category term="搞笑" scheme="https://old-driver-zero.github.io/tags/%E6%90%9E%E7%AC%91/"/>
    
  </entry>
  
  <entry>
    <title>Java</title>
    <link href="https://old-driver-zero.github.io/posts/df2849ec.html"/>
    <id>https://old-driver-zero.github.io/posts/df2849ec.html</id>
    <published>2024-02-26T00:17:22.000Z</published>
    <updated>2024-04-27T00:50:19.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>基于 Bruce Eckel 的 <em>On Java 8</em> 编写</p><h1 id="什么是对象-what-is-an-object">什么是对象 What is an Object?</h1><p>面向对象编程的特点：</p><ul><li>任何东西都是对象</li><li>程序是一堆通过发消息告诉彼此的对象（调用对象的<strong>方法</strong>）</li><li>每个对象有由其它对象组成的内存</li><li>每个对象都有一个类型（<strong>类</strong>是一个<strong>实例</strong>）</li><li>一个特定的类型的所有对象可以收到相同的信息</li></ul><p>也可以说：对象有声明（内部数据）、表现（方法）和身份（唯一的内存地址）</p><p>对象有<strong>接口</strong></p><p>对象通过<strong>方法</strong>提供服务</p><p>隐藏的实现——<strong>封装</strong></p><p>重复利用实现——<strong>继承</strong></p><p><strong>是</strong>和<strong>像</strong>的关系</p><p><strong>多态</strong></p><p><strong>单根继承</strong></p><p>集合</p><p><strong>泛型</strong></p><p>对象的生命周期——有<strong>垃圾收集器</strong></p><h1 id="到处都是对象-objects-everywhere">到处都是对象 ObjectsEverywhere</h1><p>使用<strong>引用</strong>操作对象</p><p>原始类型，特别的，有“类包装”，如 <code>Character</code></p><p>有方便的数组</p><p>注释常见每一行开头有一个 <code>*</code>，尽管是不必要的</p><p>有作用域，无需手动销毁对象</p><p>创建新的数据类型：<code>class</code></p><p>域中的原始成员数据默认值为 0，但局部变量随机</p><p>Java 中防止名称重复的方法是反向使用域名，如域名为<code>MindviewInc.com</code> 中的 <code>foibles</code> utility则包名称为<code>com.mindviewinc.utility.foibles</code>，注意均为小写。可以想见，包名都会很长，所以IDE 很重要</p><p>当使用其他组件时，需要 <code>import</code>，如<code>import java.util.ArrayList</code> 或批量导入<code>import java.util.*</code></p><p><code>static</code>关键字可以修饰域或方法，可以在不创建对象时使用</p><ul><li>不同的实例的 static 域共享相同的内存地址</li><li>static 方法中不能使用非 static 数据或该对象的非 static 方法</li></ul><h1 id="操作符-operators">操作符 Operators</h1><p>类似于 c，有优先级，赋值，简写，自增，关系等。</p><p>注意区分 <code>==</code> 和 <code>.equals()</code>判断是否相等的区别</p><p>逻辑运算符与短路</p><p>字面值，如<code>0x1f</code>（十六进制），<code>0177</code>（八进制）、<code>0b00011</code>（二进制）、<code>200L</code>（<code>long</code>的后缀）、<code>1F</code>（<code>float</code>的后缀）、<code>1D</code>(<code>double</code> 的后缀)</p><p>可以通过 <code>Integer.toBinaryString()</code> 等类似的函数转换</p><p>可以使用下划线分割，使字面值更易读，如 <code>0b0010_1111</code></p><p><code>e</code> 表示以 10 为底的指数</p><p>位运算</p><p>三元运算符</p><p><code>string</code> 支持使用 <code>+</code> 连接</p><p>强制类型转换：<code>(long) i</code></p><p>小于 <code>int</code> 的数据类型在运算时会转换为 <code>int</code>类型</p><p>注意 Java 没有 <code>sizeof()</code>，因为 Java程序运行在虚拟机上，其数据类型大小在各种机器上是一样的</p><h1 id="控制流-control-flow">控制流 Control Flow</h1><p>有 <code>true</code> 和<code>false</code>，但注意数字不能直接当布尔类型使用</p><p>支持 <code>for-in</code> 结构，即<code>for (int i : range(10))</code></p><p><code>switch</code> 结构支持 <code>string</code></p><h1 id="内务工作-housekeeping">内务工作 Housekeeping</h1><p>构造函数与类同名，在实例化后自动调用</p><p>特别的，构造函数不需要 <code>return</code>，尽管在 <code>new</code>的时候返回了一个引用，但不需要手动编写</p><p>没有参数的构造函数叫<strong>零参数构造函数</strong>，注意如果你自定义了一个有参数的构造函数，则系统默认你需要零参数构造函数</p><p>名称相同，但参数不同，则执行的效果不同，这种情况叫做<strong>重载overload</strong>。没有返回值重载，因为无法区分调用的是哪个返回值的函数</p><p>当访问一个实例中的方法时，类似于将这个对象当作参数传递了进去，如<code>a.peel(1) -&gt; Banana.peel(a, 1)</code>，故存在 <code>this</code>关键字，表示对本对象的引用</p><p>可以使用 <code>this</code>在一个构造函数中调用另一个参数的构造函数，但只能调用一个，且必须在开头，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Flower</span> &#123;<br>    Flower(<span class="hljs-type">int</span> petals) &#123;<br>        ...<br>    &#125;<br><br>    Flower(String ss) &#123;<br>        ...<br>    &#125;<br><br>    Flower(String s, <span class="hljs-type">int</span> petals) &#123;<br>        <span class="hljs-built_in">this</span>(petals);<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>垃圾收集可以从栈和静态存储中出发，遍历所有的引用，没有被遍历到的内存空间就是垃圾，要被收集。</p><p>Java起初通过不断增加其管理的空间指针来快速分配空间，当占用达到一定额度时开始清理垃圾。其采用多种方法混合，例如对于垃圾比较多的情况，可以在清理时顺便将所有有用的数据转移到另一个堆中，让空间更紧凑；对于垃圾较少的情况，则只清理垃圾，不移动正常的数据</p><p>JVM 中还有一些加速方法，如<strong>just-in-time（JIT）</strong>编译器可以部分转换程序为机器码，同时随着程序的运行逐渐更改编译的内容来取得更好的效率</p><p>成员域默认初始化为0，可以在定义时就初始化，也可以在构造函数初始化</p><p>创建一个类的对象的过程如下：</p><ol type="1"><li>构造函数实际上是一个 <code>static</code>方法，故当创建一个对象或访问类中的 <code>static</code>方法或域时，会定位 <code>.class</code></li><li>所有的 <code>static</code> 初始化都会运行，且只有 <code>Class</code>对象被装载时运行一次</li><li>当使用 <code>new</code> 时，构造过程在堆上分配对象空间</li><li>该存储会置为 0</li><li>执行在定义域时的初始化</li><li>执行构造函数</li></ol><p>可以使用 <code>static</code> 块来显式静态初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Spoon</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">static</span> &#123; i = <span class="hljs-number">47</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java 中支持数组</p><p>可变参数列表：<code>void printArray(Object... args)</code></p><p>Java 中还支持枚举类型，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Spiciness</span> &#123;<br>    NOT, MILD, MEDIUM, HOT, FLAMTING<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="实现隐藏-implementation-hiding">实现隐藏 ImplementationHiding</h1><p>package 是库的单元</p><p>Java 默认在环境变量 CLASSPATH 指定的目录下查找包，如包<code>foo.bar.baz</code> 在目录 <code>CLASSPATH/foo/bar/baz</code>下，若使用 grage，可为每个项目手动设置 CLASSPATH</p><p>当导入的不同包中有相同名称的对象，若不使用该对象，不会报错，否则会报错，必须显式指定</p><p>包访问权限控制有四种类型：</p><ul><li><code>public</code> 所有人都可以访问</li><li>没有限定符（默认访问），只有在同一个包中的类可以访问该成员</li><li><code>protected</code> 只有子类可以访问</li><li><code>private</code> 其他人无法访问</li></ul><p>一般来说成员的域要设计成 <code>private</code></p><p>对于类，一般来说都不会设计成 private 和 protected</p><p>特别的，可以将构造函数设置为 private 来防止对象的创建，以下设计模式叫Singleton，只允许创建一个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Soup2</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Soup2</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Soup2</span> <span class="hljs-variable">ps1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Soup2</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Soup2 <span class="hljs-title function_">access</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> ps1; &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Lunch</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStatic</span><span class="hljs-params">()</span> &#123; <span class="hljs-type">Soup1</span> <span class="hljs-variable">soup</span> <span class="hljs-operator">=</span> Soup1.makeSoup(); &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSingleton</span><span class="hljs-params">()</span> &#123; Soup2.access().f(); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="复用-reuse">复用 Reuse</h1><p>组合——在一个对象中包括了另一个对象 <strong>has-a</strong></p><p>继承 <strong>is a</strong></p><p>子类构造函数默认先调用了父类的默认构造函数，除非使用<code>super()</code> 显式调用带参数的构造函数（必须是第一条语句）</p><p>Java 中不支持<strong>委派delegation</strong>，即将一个成员变量放到里面（像组合），但与此同时把其所有的方法都暴露在新类中（像继承）</p><p>子类可以覆盖父类的某些成员函数</p><p><strong>向上级类型转换upcasting</strong>：子类的类型可以自动转换为父类的类型</p><p>Java 只支持<strong>单</strong>继承，即只有一个父类</p><p><code>final</code>关键词总的意思是<strong>不可变</strong>，一般是为了设计考虑才会使用</p><ul><li>对于数据，表示常数；特别的，对于一个对象来说，表示的是<strong>引用</strong>不改变</li><li>没有初始化值的 final 域叫做<strong>空白finals</strong>，必须在每个构造函数中初始化</li><li>final 参数：不可改变</li><li>final 方法：子类不可覆盖该方法，注意到所有的 private方法已经隐含了是 final 的方法，即不可 override</li><li>final 类：禁止继承</li></ul><p>当类中的代码第一次要用时，类的代码被装载。即通常是访问了一个 static域或 static 方法时（注意到构造函数也是 static 的）。在装载时，所有的static 对象和 static 代码块以文本顺序初始化</p><h1 id="多态-polymorphism">多态 Polymorphism</h1><p>也称<strong>动态绑定</strong>或<strong>延迟绑定</strong>或<strong>运行时绑定</strong>，即绑定发生在运行时，基于对象的类型</p><p>注意，只有正常的函数调用是多态的，即域和静态方法的访问不是多态的，故一般域要设置为private，以免造成误解</p><p>创建复杂对象的构造函数调用顺序：</p><ol type="1"><li>父类构造函数递归调用</li><li>以声明顺序调用成员初始化</li><li>派生类的构造函数调用</li></ol><p>如果在构造函数中调用了多态的函数，则可能不会得到预期的结果，故构造函数中最好只做初始化的工作</p><p><strong>共变式返回类型 covariant returntype</strong>：派生类中的覆盖的方法可以返回基类的派生类的类型</p><p>有 upcast，当然也有 downcast，但是有时可能有问题，Java 会检查</p><h1 id="接口-interfaces">接口 Interfaces</h1><p>Java 中支持<strong>抽象类 abstract class</strong> 和<strong>接口interface</strong>，这里只介绍接口，因为其抽象程度更高</p><p>接口中的函数声明不写，且只有 public：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PureInterface</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 支持 default，可以不用被 override</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span> &#123; ... &#125;;<br>    <span class="hljs-comment">// 支持静态方法</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(String msg)</span> &#123;<br>        System.out.println(msg);<br>    &#125;<br>    <span class="hljs-comment">// 接口中可以有域，但实际上是静态的</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">RANDOM_INT</span> <span class="hljs-operator">=</span> RAND.nextInt(<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以继承多个<strong>接口</strong></p><p><strong>工厂模型设计模式</strong>：生产适应于接口的对象</p><h1 id="内部类-inner-classes">内部类 Inner Classes</h1><p>在一个类的定义中定义另一个类，可以使用<code>外部类名称.内部类名称</code> 来调用内部类。</p><p>这个内部类可以访问外部类的成员，即保留了对外部类的引用</p><p>使用 <code>外部类名称.this</code> 返回外部类对象的引用</p><p>创建一个内部类对象时，使用 <code>外部类对象.new 内部类名称()</code>创建</p><p>private 内部类可以完全隐藏实现的信息</p><p>内部类可以在任意一个<strong>作用域</strong>中，可以是<strong>匿名</strong>的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Parcel7</span> &#123;<br>    <span class="hljs-keyword">public</span> Contents <span class="hljs-title function_">contents</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Contents</span>() &#123;<br>            <span class="hljs-comment">// 内部类的定义</span><br>            <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">11</span>;<br><span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">value</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> i; &#125;<br>        &#125;; <span class="hljs-comment">// 别忘了 new 语句末尾的 ;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意内部类初始化使用的数据必须是 final 的</p><p>匿名类可以重载构造函数，但是只能重载一个</p><p>如果内部类是 static 的，则被称作<strong>嵌套类 nestedclass</strong>，其意味着：</p><ul><li>不需要外部类对象来创建嵌套类对象</li><li>不能从嵌套类对象访问非静态的外部类对象</li></ul><p>接口也可以有内部类，但是是 static 且 public的，甚至可以实现外部接口</p><p>可以有多层嵌套的内部类，最内层的类可以直接访问最外层的类的成员</p><p>通过内部类，Java 可以间接实现多继承</p><p><strong>闭包 closure</strong>是保持了其被创建的环境的信息的可调用对象，可以通过内部类实现，在实现 GUI功能时很有用</p><p><strong>控制框架 control framework</strong>要响应事件，内部类在这种设计模式中很有用，可以直接在一个控制器类中定义事件操控要控制的对象，灵活而简便</p><p>内部类也可以被继承，但问题在于其拥有一个对外部类的引用，故在继承该内部类的构造函数中，必须传入那个外部类，并调用外部类的构造函数</p><p>内部类不可被覆盖</p><p>除此之外，内部类还可以定义在代码块中，叫做<strong>局部内部类</strong>，</p><p>内部类编译后的名字类似于<code>LocalInnerClass$1LocalCounter.class</code>，即用 <code>$</code>分割外部类和内部类的名称</p><h1 id="集合-collections">集合 Collections</h1><p>定义一个ArrayList：<code>ArrayList&lt;Apple&gt; apples = new ArrayList&lt;&gt;();</code></p><p>批量添加可以使用 <code>Arrays.asList()</code> 或<code>Collections.addAll()</code></p><p>迭代器包括：<code>next()</code>、<code>hasNext()</code>、<code>remove()</code>方法</p><p>支持 for-in</p><h1 id="函数式编程-functional-programming">函数式编程 FunctionalProgramming</h1><p>可以这样思考 OO 和 FP 两种编程方法：</p><p><strong>面向对象编程</strong>抽象<strong>数据</strong>，<strong>函数式编程</strong>抽象<strong>表现</strong></p><p>lambda 表达式“似乎”生成了函数，但在 JVM 中只存在类</p><p>一个 lambda 表达式的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Body</span> &#123; String <span class="hljs-title function_">detailed</span><span class="hljs-params">(String head)</span>; &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaExpressions</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Body</span> <span class="hljs-variable">bod</span> <span class="hljs-operator">=</span> h -&gt; h  + <span class="hljs-string">&quot;No Parens!&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; System.out.println(bod.detailed(<span class="hljs-string">&quot;Hi!&quot;</span>)); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java 中支持<strong>方法引用</strong>，格式为<code>类名或对象名::方法名</code></p><p><strong>未绑定方法引用 unbound methodreference</strong>：引用任意一个方法，但没有关联的对象，故在使用时必须提供对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br>    String <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;X::f()&quot;</span>; &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">TransformX</span> &#123; String <span class="hljs-title function_">transform</span><span class="hljs-params">(X x)</span>; &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnboundMethodReference</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TransformX</span> <span class="hljs-variable">sp</span> <span class="hljs-operator">=</span> X::f;<br><span class="hljs-type">X</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">X</span>();<br>System.out.println(sp.transform(x));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以捕捉构造函数，然后通过引用调用构造函数</p><p>lambda表达式和方法引用有接口，每个接口中只有一个抽象方法，叫<strong>函数式方法</strong></p><p><code>java.util.function</code>中已经定义了足够的目标接口，命名规则如下：</p><ul><li>如果处理对象，这如<code>Function</code>、<code>Consumer</code>、<code>Predicate</code></li><li>如果处理原始参数，则前面为名字，如 <code>LongConsumer</code></li><li>如果返回原始类型，则 <code>ToLongFunction</code></li><li>如果返回和参数相同的类型，则是一个 <code>Operator</code>，如<code>UnaryOperator</code></li><li>如果有两个参数并返回 boolean，则 <code>Predicate</code></li><li>如果有两个不同类型的参数，则名字中有 <code>Bi</code></li></ul><p>一个使用的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> &#123;<br>    Foo f;<br>    Bar(Foo f) &#123;<span class="hljs-built_in">this</span>.f = f; &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">static</span> Function&lt;Foo, Bar&gt; f1 = f -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>(f);<br>    <span class="hljs-type">Bar</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> f1.apply(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>Java 支持高阶函数，即可以生成或消耗一个函数，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">FuncSS</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Function</span>&lt;String, String&gt; &#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProduceFunction</span> &#123;<br>    <span class="hljs-keyword">static</span> FuncSS <span class="hljs-title function_">produce</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> s -&gt; s.toLowerCase(); &#125; <span class="hljs-comment">// 返回一个函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <span class="hljs-type">FuncSS</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> produce(); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数可以组合，使用<code>andThen(argument)</code>、<code>compose(argument)</code>、<code>and(argument)</code>、<code>or(argument)</code>、<code>negate()</code></p><p>一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FunctionComposition</span> &#123;<br>    <span class="hljs-keyword">static</span> Function&lt;String, String&gt; f1 = s -&gt; &#123;<br>        System.out.println(s);<br><span class="hljs-keyword">return</span> s.replace(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>);<br>&#125;,<br>f2 = s -&gt; s.substring(<span class="hljs-number">3</span>),<br>f3 = s -&gt; s.toLowerCase(),<br>    f4 = f1.compose(f2).andThen(f3);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(f4.apply(<span class="hljs-string">&quot;GO AFTER ALL AMBULANCES&quot;</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样支持 Curry，如<code>Function&lt;String, Function&lt;String, String&gt;&gt; sum = a -&gt; b -&gt; a + b;</code></p><h1 id="流-streams">流 Streams</h1><p>流让函数式编程成为可能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(<span class="hljs-number">47</span>).ints(<span class="hljs-number">5</span>, <span class="hljs-number">20</span>).distinct().limit(<span class="hljs-number">7</span>).sorted().forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>创建流：<code>Stream.of()</code>；此外，所有的<code>Collection</code> 都可以使用 <code>stream()</code>方法创建一个流</p><p><code>range()</code> 也返回一个流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(range(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>).sum());<br></code></pre></td></tr></table></figure><p><code>Stream.generate()</code> 和 <code>Supplier&lt;T&gt;</code>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.generate(() -&gt; <span class="hljs-string">&quot;duplicate&quot;</span>).limit(<span class="hljs-number">3</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure><p><code>Stream.iterate()</code>从一个种子开始，把它传递给方法，结果添加到流中并储存为新的第一个参数</p><p>在 Builder 设计模式中，创建一个 builder对象，传递多片构造信息，最后执行 build 动作</p><p><code>.peek()</code> 函数可以不改变流的同时查看流，用于调试</p><p><code>sorted()</code> 用于排序</p><p><code>distinct()</code> 去重</p><p><code>filter(Predicate)</code> 筛选</p><p>对每个元素使用函数：<code>map(Function)</code>、<code>mapToInt()</code></p><p><code>flatMap(Function)</code> 系列做两件事：map并把每个流展开为元素</p><p>支持 Optional，表示空的流，一个使用的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OptionalBasics</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Optional&lt;String&gt; optString)</span> &#123;<br>        <span class="hljs-keyword">if</span>(optString.isPresent())<br>            System.out.println(optString.get());<br><span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">&quot;Nothing inside!&quot;</span>);<br>&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        test(Stream.of(<span class="hljs-string">&quot;Epithets&quot;</span>).findFirst());<br>    test(Stream.&lt;String&gt;empty().findFirst());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解包 Optionals的函数：<code>ifPresent(Consumer)</code>、<code>orElse(otherObject)</code>、<code>orElseGet(Supplier)</code>、<code>orElseThrow(Supplier)</code></p><p>创建 Optional的方法：<code>empty()</code>、<code>of(value)</code>、<code>ofNullable(value)</code></p><p>终止操作符：<code>toArray()</code>、<code>forEach(Consumer)</code>、<code>collect(Collector)</code></p><p>将所有流元素组合起来：<code>reduce(BinaryOperator)</code> 或<code>reduce(identity, BinaryOperator)</code></p><p>还有匹配：<code>allMatch(Predicate)</code>、<code>anyMatch(Predicate)</code>、<code>noneMatch(Predicate)</code></p><p>选择元素：<code>findFirst()</code></p><p>消息：<code>count()</code>、<code>max()</code>、<code>min()</code></p><h1 id="异常-exceptions">异常 Exceptions</h1><p>抛出异常：<code>throw new NullPointerException("t = null")</code></p><p>捕捉异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br><br>&#125; <span class="hljs-keyword">catch</span>(Type1 id1) &#123;<br><br>&#125; <span class="hljs-keyword">catch</span>(Type2 id2) &#123;<br><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>自定义异常类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>指明一个方法会抛出某种异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> TooBig, TooSmall, DivZero &#123;...&#125;<br></code></pre></td></tr></table></figure><h1 id="验证你的代码-validating-your-code">验证你的代码 Validating YourCode</h1><p>单元测试：使用 <a href="https://junit.org/junit5/">JUnit 5</a></p><ul><li><code>@BeforeAll</code>、<code>@AfterAll</code>在所有测试的最前和最后执行</li><li><code>@BeforeEach</code>、<code>@AfterEach</code> 在每个测试……</li><li><code>@Test</code> 定义一个测试</li></ul><p>一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Running testInsert()&quot;</span>);<br>    assertEquals(list.size(), <span class="hljs-number">3</span>);<br>    list.add(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Insert&quot;</span>);<br>    assertEquals(list.size(), <span class="hljs-number">4</span>);<br>    assertEquals(list.get(<span class="hljs-number">1</span>), <span class="hljs-string">&quot;Insert&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>契约式设计 Design by Contract(DbC)</strong>：强调前置条件、后置条件和不变式的检查</p><p>Java 中有 <code>assert</code> 用于实现，<ahref="https://github.com/google/guava">guava</a> 库中也有<code>verify()</code> 实现类似的功能</p><p><a href="https://slf4j.org/">SLF4J</a> 提供了多级的日志输出</p><p><ahref="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/jdb.html">jdb</a>用于调试，或者使用 IDE 自带的图形化方法</p><p><a href="https://github.com/openjdk/jmh">jmh</a>可以用于测试速度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@State(Scope.Thread)</span><br><span class="hljs-meta">@BenchmarkMode(Mode.AverageTime)</span><br><span class="hljs-meta">@OutputTimeUnit(TimeUnit.MICROSECONDS)</span><br><span class="hljs-meta">@Warmup(iterations = 5)</span><br><span class="hljs-meta">@Measurement(iterations = 5)</span><br><span class="hljs-meta">@Fork(1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JMH1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span>[] la;<br>    <span class="hljs-meta">@Param(&#123;</span><br><span class="hljs-meta">        &quot;1&quot;,</span><br><span class="hljs-meta">        &quot;10&quot;,</span><br><span class="hljs-meta">        &quot;100&quot;,</span><br><span class="hljs-meta">        &quot;1000&quot;,</span><br><span class="hljs-meta">        &quot;10000&quot;,</span><br><span class="hljs-meta">        &quot;100000&quot;</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-meta">@Setup</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setup</span><span class="hljs-params">()</span> &#123;<br>        la = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[size];<br>    &#125;<br><br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAll</span><span class="hljs-params">()</span> &#123;<br>        Arrays.setAll(la, n -&gt; n);<br>    &#125;<br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parallelSetAll</span><span class="hljs-params">()</span> &#123;<br>        Arrays.parallelSetAll(la, n -&gt; n);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="文件-files">文件 Files</h1><p><code>get()</code> 方法将 <code>String</code> 序列或 URI 转化为一个<code>Path</code> 对象，该对象有很多方法</p><p>通过在使用 <code>resolve()</code> 方法来向路径结尾添加片段</p><p>使用 <code>Files.readAllLines()</code> 来一次逐行读入整个文件</p><p><code>Files.write()</code> 则写入文件</p><h1 id="字符串-strings">字符串 Strings</h1><p>Java 中字符串是不可变的</p><p>支持和 C 语言类似的 <code>printf()</code>，但一般使用<code>System.out.format()</code>，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.format(<span class="hljs-string">&quot;Row 1: [%d %f]%n&quot;</span>, x, y);<br></code></pre></td></tr></table></figure><p><code>Formatter</code> 类可以处理格式化，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Turtle</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Formatter f;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Turtle</span><span class="hljs-params">(String name, Formatter f)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.f = f;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123; f.format(<span class="hljs-string">&quot;%s The Turtle is at (%d,%d)%n&quot;</span>, name, x, y); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <span class="hljs-type">Turtle</span> <span class="hljs-variable">tommy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Turtle</span>(<span class="hljs-string">&quot;Tommy&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Formatter</span>(System.out)); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>String.format()</code> 返回的是一个 <code>String</code></p><p>使用 <code>Pattern.compile()</code> 编译正则表达式，调用<code>.matcher(String)</code> 生成 <code>Matcher</code>对象，这个对象有多种操作，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Pattern</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Pattern.compile(arg);<br>    <span class="hljs-type">Matcher</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> p.matcher(args[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">while</span>(m.find())<br>        System.out.println( <span class="hljs-string">&quot;Match \&quot;&quot;</span> + m.group() + <span class="hljs-string">&quot;\&quot; at positions &quot;</span> + m.start() + <span class="hljs-string">&quot;-&quot;</span> + (m.end() - <span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Pattern</code> 中也有一个静态方法<code>static boolean matches(String regex, CharSequence input)</code></p><p><code>matches</code> 匹配整个输入，<code>lookingAt()</code>匹配开头，<code>find()</code> 找到多个匹配的位置</p><p><code>compile()</code> 时还可以传入多个 flags</p><p><code>split()</code>、<code>replaceAll() / replaceFirst()</code>都使用正则表达式</p><p><code>reset()</code>可以将现有的 <code>Matcher</code>对象应用于新的字符序列</p><p>输入人类可读的信息可以使用 <code>Scanner</code> 类，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">stdin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(SimpleRead.input);<br>    System.out.println(<span class="hljs-string">&quot;What is your name?&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> stdin.nextLine();<br>    System.out.println(name);<br>    System.out.println( <span class="hljs-string">&quot;How old are you? What is your favorite double?&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> stdin.nextInt();<br>    <span class="hljs-type">double</span> <span class="hljs-variable">favorite</span> <span class="hljs-operator">=</span> stdin.nextDouble();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="反射-reflection">反射 Reflection</h1><p>编译时有时不知道对象信息，需要通过<strong>反射 reflection</strong>在运行时获取到对象信息</p><p>class loader 在创建某个类的对象时动态地将类装载到 JVM 中</p><p>如果你已经有了对某个类的对象的引用，则可以使用<code>getClass()</code> 获得对类的引用，还有 <code>getInterface()</code>获得其接口等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ToyTest</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printInfo</span><span class="hljs-params">(Class cc)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Class name: &quot;</span> + cc.getName() + <span class="hljs-string">&quot; is interface? [&quot;</span> + cc.isInterface() + <span class="hljs-string">&quot;]&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Simple name: &quot;</span> + cc.getSimpleName());<br>        System.out.println( <span class="hljs-string">&quot;Canonical name : &quot;</span> + cc.getCanonicalName());<br>    &#125;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;deprecation&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            c = Class.forName(<span class="hljs-string">&quot;reflection.toys.FancyToy&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span>(ClassNotFoundException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Can&#x27;t find FancyToy&quot;</span>);<br>            System.exit(<span class="hljs-number">1</span>);<br>        &#125;<br>        printInfo(c);<br>        <span class="hljs-keyword">for</span>(Class face : c.getInterfaces())<br>            printInfo(face);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> c.getSuperclass();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">// Requires public zero-argument constructor:</span><br>            obj = up.newInstance();<br>        &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Cannot instantiate&quot;</span>);<br>        &#125;<br>        printInfo(obj.getClass());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>产生对 Class 对象的引用还有一种方法：class 字面值，如<code>FancyToy.class</code>，特别的，对于原始类型，有 <code>TYPE</code>域，如 <code>Integer.TYPE</code></p><p>准备待使用的类：</p><ol type="1"><li>装载，找到字节码并创建一个 Class 对象</li><li>链接，为 static 域分配空间，处理对其他类的引用</li><li>初始化，如果有基类，则初始化，执行 static初始化（初始化推迟到第一个对 static 方法的引用）</li></ol><p>还有一种反射形式，<code>instanceof</code>告诉你某个对象是否是一个特定类型的实例，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> Dog)<br>    ((Dog)x).bark();<br></code></pre></td></tr></table></figure><p><code>.isInstance()</code> 方法则可以动态地测试一个对象的类型</p><p>工厂方法可以被多态地调用，并创建合适类型的对象，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Part</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Supplier</span>&lt;Part&gt; &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getClass().getSimpleName();<br>    &#125;<br>    <span class="hljs-keyword">static</span> List&lt;Supplier&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Part</span>&gt;&gt; prototypes = Arrays.asList(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">FuelFilter</span>(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AirFilter</span>(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CabinAirFilter</span>(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">OilFilter</span>(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">FanBelt</span>(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">PowerSteeringBelt</span>(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">GeneratorBelt</span>()<br>    );<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Random</span> <span class="hljs-variable">rand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(<span class="hljs-number">47</span>);<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Part <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> rand.nextInt(prototypes.size());<br>       <span class="hljs-keyword">return</span> prototypes.get(n).get();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Filter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Part</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FuelFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> FuelFilter <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FuelFilter</span>(); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>instanceof</code> 返回真，如果是一个类或这个类的子类</p><p><code>.getMethods()</code> 和 <code>.getConstructors()</code>返回方法和构造函数的数组</p><p><strong>代理 proxy</strong>是在对象之间插入一个额外的操作的对象，Java中有<strong>动态</strong>代理，即创建代理对象和处理调用代理方法都是动态的，所有对动态代理的调用都重定向到invocation handler 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.*;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicProxyHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> Object proxied;<br>    DynamicProxyHandler(Object proxied) &#123;<br>        <span class="hljs-built_in">this</span>.proxied = proxied;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span><br>    <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println( <span class="hljs-string">&quot;**** proxy: &quot;</span> + proxy.getClass() + <span class="hljs-string">&quot;, method: &quot;</span> + method + <span class="hljs-string">&quot;, args: &quot;</span> + args);<br>        <span class="hljs-keyword">if</span>(args != <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">for</span>(Object arg : args)<br>                System.out.println(<span class="hljs-string">&quot; &quot;</span> + arg);<br>        <span class="hljs-keyword">return</span> method.invoke(proxied, args);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleDynamicProxy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consumer</span><span class="hljs-params">(Interface iface)</span> &#123;<br>        iface.doSomething();<br>        iface.somethingElse(<span class="hljs-string">&quot;bonobo&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">RealObject</span> <span class="hljs-variable">real</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealObject</span>();<br>        consumer(real);<br>        <span class="hljs-comment">// Insert a proxy and call again:</span><br>        <span class="hljs-type">Interface</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (Interface)Proxy.newProxyInstance(<br>            Interface.class.getClassLoader(),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123; Interface.class &#125;,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">DynamicProxyHandler</span>(real));<br>        consumer(proxy);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们之前学习了<code>Optional</code>，但通常不好在所有地方都使用这个，而是应该在<strong>接近数据</strong>的地方使用，</p><p>反射也带来了一些安全问题，如果有了源代码，就可以在外部调用<code>private</code> 方法，添加自己的方法等</p><h1 id="泛型-generics">泛型 Generics</h1><p>一个泛型类的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tuple2</span>&lt;A, B&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> A a1;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> B a2;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tuple2</span><span class="hljs-params">(A a, B b)</span> &#123; a1 = a; a2 = b; &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">rep</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> a1 + <span class="hljs-string">&quot;, &quot;</span> + a2; &#125;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;(&quot;</span> + rep() + <span class="hljs-string">&quot;)&quot;</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，接口也可以是泛型的，如 <code>Supplier&lt;T&gt;</code></p><p>静态方法也可以是泛型的，参数也可以是泛型的，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SafeVarargs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title function_">makeList</span><span class="hljs-params">(T... args)</span> &#123;<br>    List&lt;T&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(T item : args)<br>    result.add(item);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>在泛型的内部，泛型参数的类型被擦去了，即在运行时，<code>List&lt;String&gt;</code>和 <code>List&lt;Integer&gt;</code> 都变成了 <code>List</code></p><p>这种设计是历史遗留问题，因为这样就可以兼容泛型和非泛型的库了</p><p>可以对泛型设一些界限，如<code>&lt;T extends HasColor&gt;</code>、<code>&lt;T super Red&gt;</code></p><p><strong>wildcard</strong>，如 <code>&lt;? extends Fruit&gt;</code> 和<code>&lt;? super Myclass&gt;</code></p><p>甚至还有无界限的版本 <code>&lt;?&gt;</code></p><h1 id="数组-arrays">数组 Arrays</h1><p><code>Arrays.toString()</code> 将数组转化为一个可读的字符串</p><p>初始化有多种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">BerylliunmSphere[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BerylliunmSphere</span>[<span class="hljs-number">5</span>];<br>BerylliunmSphere[] b = &#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">BerylliunmSpher</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">BerylliunmSphere</span>()&#125;;<br>BerylliunmSphere[] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BerylliunmSphere</span>[] &#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">BerylliunmSphere</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">BerylliunmSphere</span>()&#125;<br></code></pre></td></tr></table></figure><p>默认初始值为 <code>null</code> 或 <code>0</code></p><p>Java 中可以返回数组</p><p><code>Arrays.deepToString()</code> 可以将多维数组转化为字符串</p><p><code>Arrays.fill()</code> 用某个值填充某个数组</p><p><code>Arrays.setAll(long[] a, intToLongFunction gen)</code>等的第二个参数接受一个 <code>index</code> 并生成填充数组该位的值</p><p>此外，<code>Arrays</code> 中还有一些有用的方法，如<code>asList()</code>、<code>copyOf()</code>、<code>copyOfRange()</code>、<code>equals()</code>、<code>deepEquals()</code>、<code>stream()</code>、<code>sort()</code>、<code>binarySearch()</code>等</p><h1 id="枚举-enumerations">枚举 Enumerations</h1><p>一个简单的枚举：<code>enum Shrubbery &#123; GROUND, CRAWLING, HANGING &#125;</code></p><ul><li><code>.ordinal()</code> 从 0 开始依声明顺序给每个 enum 编号的int</li><li><code>Enum.valueOf(Shrubbery.class, s)</code> 产生 <code>s</code>名字对应的实例</li></ul><p>使用 <code>static</code>导入把实例标识符导入到本地命名空间中，故不需要再加限定</p><p><code>enum</code>和普通的类没太大的区别，可以添加构造函数和方法等</p><p>实质上所有的 <code>enum</code> 类型都继承于 <code>Enum</code></p><p><code>EnumSet</code> 在元素基数较小时，可以替代<code>HashSet</code>，其内部使用 64 位二进制实现，速度更快：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">EnumSet&lt;AlarmPoints&gt; points = EnumSet.noneOf(AlarmPoints.class);<br></code></pre></td></tr></table></figure><p><code>EnumMap</code> 同理</p><h1 id="注解-annotations">注解 Annotations</h1><p><code>@Deprecated</code>生成编译器警告，<code>@SuppressWarnings</code>关闭不合适的编译器警告，<code>@FunctionalInterface</code>这是一个函数接口</p><p>自定义注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> UseCase &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">id</span><span class="hljs-params">()</span>;<br>    String <span class="hljs-title function_">description</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;no description&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@Target</code> 定义了何处应用这个注解</li><li><code>@Retention</code> 定义了注解在源代码<code>SOURCE</code>、类文件 <code>CLASS</code> 还是运行时<code>RUNTIME</code></li></ul><p>没有任何元素的注解，如 <code>@Test</code>，叫做<strong>标记注解marker annotation</strong></p><p>使用注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PasswordUtils</span> &#123;<br>    <span class="hljs-meta">@UseCase(id = 47, description = &quot;password&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validatePassword</span><span class="hljs-params">(String passwd)</span> &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-meta">@UseCase(id = 48)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">encryptPassword</span><span class="hljs-params">(String passwd)</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="javadoc">Javadoc</h1><p>格式：<code>/** */</code></p><p>两种使用方法：内嵌 HTML 或使用 doc tag</p><p>有三种类型的注释：类、域、方法</p><p>默认不会输出 <code>private</code> 和包访问的成员</p><p>常用的 HTML：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;ol&gt;</span><br><span class="hljs-comment"> * &lt;li&gt; one</span><br><span class="hljs-comment"> * &lt;li&gt; two</span><br><span class="hljs-comment"> * &lt;/ol&gt;</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>标签：</p><ul><li><code>@see</code> 参考其他类中的文档，如 <code>@see 类名</code> 或<code>@see 完全类名#方法名</code></li><li><code>&#123;@link 包名.类名#方法 标签&#125;</code> 类似于<code>@see</code>，但是是内联的，且可以自定义标签</li><li><code>&#123;@docRoot&#125;</code> 创建文档根目录的相对路径</li><li><code>&#123;@inheritDoc&#125;</code> 从最近的基类中继承文档</li><li><code>@version</code>、<code>@author</code>、<code>@since</code></li><li><code>@param</code>、<code>@return</code>、<code>@throws</code></li></ul><h1 id="io-流-io-streams">I/O 流 I/O Streams</h1><p>输入流 <code>InputStream</code> 的类型：</p><table><colgroup><col style="width: 26%" /><col style="width: 36%" /><col style="width: 37%" /></colgroup><thead><tr class="header"><th>类</th><th>功能</th><th>构造参数</th></tr></thead><tbody><tr class="odd"><td><code>ByteArrayInputStream</code></td><td>允许内存中的 buffer 充当输入流</td><td>提取字节的 buffer</td></tr><tr class="even"><td><code>FileInputStream</code></td><td>从文件中读</td><td>一个代表文件名的字符串或 <code>File</code></td></tr><tr class="odd"><td><code>PipedInputStream</code></td><td>从一端输入，另一端出来</td><td><code>PipedOutputStream</code></td></tr></tbody></table><p>输入的同理，不再赘述</p><p>以上所有的流都必须连接到一个 <code>FilterInputStream</code>来提供更多的接口</p><p><code>FilterInputStream</code> 的类型：</p><table><thead><tr class="header"><th>类</th><th>功能</th></tr></thead><tbody><tr class="odd"><td><code>DataInputStream</code></td><td>从一个流中读原始类型数据</td></tr><tr class="even"><td><code>BufferedInputStream</code></td><td>使用了一个 buffer 读</td></tr></tbody></table><p>对于输出，特别的，有<code>PrintStream</code>，其产生格式化的输出，应该是<code>OutputStream</code> 的最终包装</p><p><code>Reader</code> 和 <code>Writer</code> 相当于<code>InputStream</code> 和 <code>OutputStream</code>的改名，区别不大</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;基于 Bruce Eckel 的 &lt;em&gt;On Java 8&lt;/em&gt;
        
      
    
    </summary>
    
    
      <category term="工具" scheme="https://old-driver-zero.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="https://old-driver-zero.github.io/tags/Java/"/>
    
      <category term="面向对象编程" scheme="https://old-driver-zero.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>全栈公开课（第二部分）</title>
    <link href="https://old-driver-zero.github.io/posts/e5d89884.html"/>
    <id>https://old-driver-zero.github.io/posts/e5d89884.html</id>
    <published>2024-01-03T00:17:22.000Z</published>
    <updated>2024-04-14T01:47:51.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1id="react-router自定义-hook利用-css-和-webpack-给-app-添加样式">Reactrouter、自定义 hook，利用 CSS 和 webpack 给 app 添加样式</h1><h2 id="react-router">React-router</h2><p>使用 <a href="https://reactrouter.com/">React Router</a>库生成导航栏：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">BrowserRouter</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Router</span>, <span class="hljs-title class_">Routes</span>, <span class="hljs-title class_">Route</span>, <span class="hljs-title class_">Link</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> padding = &#123;<br>    <span class="hljs-attr">padding</span>: <span class="hljs-number">5</span>,<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Router</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;padding&#125;</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&#x27;/&#x27;</span>&gt;</span></span><br><span class="language-xml">          home</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;padding&#125;</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&#x27;/notes&#x27;</span>&gt;</span></span><br><span class="language-xml">          notes</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;padding&#125;</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&#x27;/users&#x27;</span>&gt;</span></span><br><span class="language-xml">          users</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&#x27;/notes&#x27;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Notes</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&#x27;/users&#x27;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Users</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&#x27;/&#x27;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Home</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>Note app, Department of Computer Science 2022<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Router</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以添加参数路由：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">Route</span> path=<span class="hljs-string">&#x27;/notes/:id&#x27;</span> element=&#123;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Note</span> <span class="hljs-attr">notes</span>=<span class="hljs-string">&#123;notes&#125;</span> /&gt;</span></span>&#125; /&gt;<br></code></pre></td></tr></table></figure><p>使用 <code>useNavigate()</code> 和 <code>navigate('/')</code>可以手动导航</p><p>如果一个用户没有登录，则会被重定向到登录页面：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">Route</span><br>  path=<span class="hljs-string">&#x27;/users&#x27;</span><br>  element=&#123;user ? <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Users</span> /&gt;</span></span> : <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Navigate</span> <span class="hljs-attr">replace</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&#x27;/login&#x27;</span> /&gt;</span></span>&#125;<br>/&gt;<br></code></pre></td></tr></table></figure><p><ahref="https://reactrouter.com/en/main/hooks/use-match">useMatch</a>钩子可以计算出所需 id：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> match = <span class="hljs-title function_">useMatch</span>(<span class="hljs-string">&#x27;/notes/:id&#x27;</span>);<br><span class="hljs-keyword">const</span> note = match<br>  ? notes.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">note</span>) =&gt;</span> note.<span class="hljs-property">id</span> === <span class="hljs-title class_">Number</span>(match.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>))<br>  : <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><h2 id="自定义-hooks">自定义 hooks</h2><p>我们也可以自定义钩子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">useField</span> = (<span class="hljs-params">type</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onChange</span> = (<span class="hljs-params">event</span>) =&gt; &#123;<br>    <span class="hljs-title function_">setValue</span>(event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> &#123; type, value, onChange &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="样式进阶">样式进阶</h2><p>先介绍 <a href="https://getbootstrap.com/">Bootstrap</a>，使用 <ahref="https://react-bootstrap.github.io/">react-bootstrap</a>软件包，并在 <code>index.html</code> 的 <code>head</code> 中加载CSS：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span></span><br><span class="hljs-tag">    <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">integrity</span>=<span class="hljs-string">&quot;sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">&quot;anonymous&quot;</span></span><br><span class="hljs-tag">  /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><p>应用的所有内容在容器中渲染，给应用的根 div 元素加上 container类属性</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;container&#x27;</span>&gt;</span>// ...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>有<ahref="https://react-bootstrap.github.io/docs/components/table/">表格</a>，<ahref="https://getbootstrap.com/docs/4.1/components/forms/">表单</a>，<ahref="https://getbootstrap.com/docs/4.1/components/alerts/">通知</a>，<ahref="https://getbootstrap.com/docs/4.1/components/navbar/">导航栏</a>等</p><p>接下来是 <a href="https://mui.com/">MaterialUI</a> React库，要安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install @mui/material @emotion/react @emotion/styled<br></code></pre></td></tr></table></figure><p><code>index.html</code> 中添加：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span></span><br><span class="hljs-tag">    <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&amp;display=swap&quot;</span></span><br><span class="hljs-tag">  /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><p>渲染方式是：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Container</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@mui/material&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Container</span>&gt;</span>// ...<span class="hljs-tag">&lt;/<span class="hljs-name">Container</span>&gt;</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>同样有<ahref="https://mui.com/material-ui/react-table/#simple-table">表格</a>，<ahref="https://mui.com/material-ui/react-text-field/">文本框</a>，<ahref="https://mui.com/material-ui/api/button/">按钮</a>，<ahref="https://mui.com/material-ui/react-alert/">Alert</a>，<ahref="https://mui.com/material-ui/react-app-bar/">AppBar</a></p><p>还可以使用 <a href="https://www.styled-components.com/">styledcomponents</a> 库提供的方式定义样式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> styled <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;styled-components&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Input</span> = styled.<span class="hljs-property">input</span><span class="hljs-string">`</span><br><span class="hljs-string">  margin: 0.25em;</span><br><span class="hljs-string">`</span>;<br></code></pre></td></tr></table></figure><p>然后正常使用即可</p><h2 id="webpack">Webpack</h2><p><a href="https://webpack.js.org/">webpack</a> 可用于创建 app</p><p>一个 <code>webpack.config.js</code> 文件的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-keyword">const</span> config = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;build&#x27;</span>),<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;main.js&#x27;</span>,<br>  &#125;,<br>&#125;;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = config;<br></code></pre></td></tr></table></figure><p>可以使用 loaders 来通知 webpack 在捆绑前需要处理的文件，例如将<code>.jsx</code> 文件转化为普通的 <code>.js</code> 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,<br>        <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>        <span class="hljs-attr">options</span>: &#123;<br>            <span class="hljs-attr">presets</span>: [<span class="hljs-string">&#x27;@babel/preset-react&#x27;</span>],<br>        &#125;,<br>      &#125;,<br>    ],<br>&#125;,<br></code></pre></td></tr></table></figure><p>还需要安装并引入 <ahref="https://www.npmjs.com/package/core-js">core-js</a> 和 <ahref="https://www.npmjs.com/package/regenerator-runtime">regenerator-runtime</a></p><p>当使用 CSS 时，我们必须使用 <ahref="https://webpack.js.org/loaders/css-loader/">css</a> 和 <ahref="https://webpack.js.org/loaders/style-loader/">style</a>加载器。</p><p><a href="https://webpack.js.org/configuration/devtool/">sourcemap</a> 有助于我们看到源代码</p><h2 id="各种各样的-class-components">各种各样的 Class components</h2><p>React 元素构成了一个虚拟 DOM</p><p><code>npm-check-updates</code> 可以用来检查依赖的更新</p><h1 id="graphql">GraphQL</h1><h2 id="graphql-服务器">GraphQL 服务器</h2><p>REST 是基于资源的，对资源的所有操作通过对其 URL 的 HTTP请求完成。</p><p>但是 GraphQL 的所有查询都被发送到一个地址，类型是 POST</p><p>一个定义的模式的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>!<br>  <span class="hljs-attr">phone</span>: <span class="hljs-title class_">String</span><br>  <span class="hljs-attr">street</span>: <span class="hljs-title class_">String</span>!<br>  <span class="hljs-attr">city</span>: <span class="hljs-title class_">String</span>!<br>  <span class="hljs-attr">id</span>: <span class="hljs-variable constant_">ID</span>!<br>&#125;<br><br>type <span class="hljs-title class_">Query</span> &#123;<br>  <span class="hljs-attr">personCount</span>: <span class="hljs-title class_">Int</span>!<br>  <span class="hljs-attr">allPersons</span>: [<span class="hljs-title class_">Person</span>!]!<br>  <span class="hljs-title function_">findPerson</span>(<span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>!): <span class="hljs-title class_">Person</span><br>&#125;<br></code></pre></td></tr></table></figure><p>查询：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">query &#123;<br>  allPersons &#123;<br>    name<br>    phone<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;allPersons&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Arto Hellas&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;phone&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;040-123543&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Matti Luukkainen&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;phone&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;040-432342&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Venla Ruuska&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;phone&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>也可以带有参数</p><p>实现服务器使用 <ahref="https://www.apollographql.com/docs/apollo-server/">ApolloServer</a></p><p>定义模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">ApolloServer</span>, gql &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;apollo-server&#x27;</span>);<br><br><span class="hljs-keyword">const</span> typeDefs = gql`<span class="language-graphql"></span><br><span class="language-graphql">  <span class="hljs-keyword">type</span> Person <span class="hljs-punctuation">&#123;</span></span><br><span class="language-graphql">    <span class="hljs-symbol">name</span><span class="hljs-punctuation">:</span> String<span class="hljs-punctuation">!</span></span><br><span class="language-graphql">    <span class="hljs-symbol">phone</span><span class="hljs-punctuation">:</span> String</span><br><span class="language-graphql">    <span class="hljs-symbol">street</span><span class="hljs-punctuation">:</span> String<span class="hljs-punctuation">!</span></span><br><span class="language-graphql">    <span class="hljs-symbol">city</span><span class="hljs-punctuation">:</span> String<span class="hljs-punctuation">!</span></span><br><span class="language-graphql">    <span class="hljs-symbol">id</span><span class="hljs-punctuation">:</span> ID<span class="hljs-punctuation">!</span></span><br><span class="language-graphql">  <span class="hljs-punctuation">&#125;</span></span><br><span class="language-graphql"></span><br><span class="language-graphql">  <span class="hljs-keyword">type</span> <span class="hljs-keyword">Query</span> <span class="hljs-punctuation">&#123;</span></span><br><span class="language-graphql">    <span class="hljs-symbol">personCount</span><span class="hljs-punctuation">:</span> Int<span class="hljs-punctuation">!</span></span><br><span class="language-graphql">    <span class="hljs-symbol">allPersons</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>Person<span class="hljs-punctuation">!</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">!</span></span><br><span class="language-graphql">    findPerson<span class="hljs-punctuation">(</span><span class="hljs-symbol">name</span><span class="hljs-punctuation">:</span> String<span class="hljs-punctuation">!</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">:</span> Person</span><br><span class="language-graphql">  <span class="hljs-punctuation">&#125;</span></span><br><span class="language-graphql">`</span>;<br><br><span class="hljs-keyword">const</span> resolvers = &#123;<br>  <span class="hljs-title class_">Query</span>: &#123;<br>    <span class="hljs-attr">personCount</span>: <span class="hljs-function">() =&gt;</span> persons.<span class="hljs-property">length</span>,<br>    <span class="hljs-attr">allPersons</span>: <span class="hljs-function">() =&gt;</span> persons,<br>    <span class="hljs-attr">findPerson</span>: <span class="hljs-function">(<span class="hljs-params">root, args</span>) =&gt;</span> persons.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> p.<span class="hljs-property">name</span> === args.<span class="hljs-property">name</span>),<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApolloServer</span>(&#123;<br>  typeDefs,<br>  resolvers,<br>&#125;);<br><br>server.<span class="hljs-title function_">listen</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">&#123; url &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Server ready at <span class="hljs-subst">$&#123;url&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>对象之间也可以组合，如模式为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">Address</span> &#123;<br>  <span class="hljs-attr">street</span>: <span class="hljs-title class_">String</span>!<br>  <span class="hljs-attr">city</span>: <span class="hljs-title class_">String</span>!<br>&#125;<br><br>type <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>!<br>  <span class="hljs-attr">address</span>: <span class="hljs-title class_">Address</span>!<br>  <span class="hljs-attr">id</span>: <span class="hljs-variable constant_">ID</span>!<br>&#125;<br></code></pre></td></tr></table></figure><p>所有引起变化的操作通过 mutation 完成，如添加一个新人：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">Mutation</span> &#123;<br>  <span class="hljs-title function_">addPerson</span>(<br>    <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>!<br>    <span class="hljs-attr">phone</span>: <span class="hljs-title class_">String</span><br>    <span class="hljs-attr">street</span>: <span class="hljs-title class_">String</span>!<br>    <span class="hljs-attr">city</span>: <span class="hljs-title class_">String</span>!<br>  ): <span class="hljs-title class_">Person</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用 Apollo 的错误处理机制，如抛出<code>throw new UserInputError('Name must be unique', &#123;invalidArgs: args.name, &#125;)</code></p><p>GraphQL 支持枚举类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">enum <span class="hljs-title class_">YesNo</span> &#123;<br>  <span class="hljs-variable constant_">YES</span><br>  <span class="hljs-variable constant_">NO</span><br>&#125;<br><br>type <span class="hljs-title class_">Query</span> &#123;<br>  <span class="hljs-attr">personCount</span>: <span class="hljs-title class_">Int</span>!<br><br>  <span class="hljs-title function_">allPersons</span>(<span class="hljs-attr">phone</span>: <span class="hljs-title class_">YesNo</span>): [<span class="hljs-title class_">Person</span>!]!<br>  <span class="hljs-title function_">findPerson</span>(<span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>!): <span class="hljs-title class_">Person</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="react-与-graphql">React 与 GraphQL</h2><p>客户端使用 <code>ApolloProvider</code> 包装 APP 组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span>;<br><br><span class="hljs-keyword">import</span> &#123;<br>  <span class="hljs-title class_">ApolloClient</span>,<br>  <span class="hljs-title class_">ApolloProvider</span>,<br>  <span class="hljs-title class_">HttpLink</span>,<br>  <span class="hljs-title class_">InMemoryCache</span>,<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@apollo/client&#x27;</span>;<br><br><span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApolloClient</span>(&#123;<br>  <span class="hljs-attr">cache</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">InMemoryCache</span>(),<br>  <span class="hljs-attr">link</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpLink</span>(&#123;<br>    <span class="hljs-attr">uri</span>: <span class="hljs-string">&#x27;http://localhost:4000&#x27;</span>,<br>  &#125;),<br>&#125;);<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ApolloProvider</span> <span class="hljs-attr">client</span>=<span class="hljs-string">&#123;client&#125;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ApolloProvider</span>&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p>查询可以使用 <code>useQuery</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; gql, useQuery &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@apollo/client&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ALL_PERSONS</span> = gql`<span class="language-graphql"></span><br><span class="language-graphql">  <span class="hljs-keyword">query</span> <span class="hljs-punctuation">&#123;</span></span><br><span class="language-graphql">    allPersons <span class="hljs-punctuation">&#123;</span></span><br><span class="language-graphql">      name</span><br><span class="language-graphql">      phone</span><br><span class="language-graphql">      id</span><br><span class="language-graphql">    <span class="hljs-punctuation">&#125;</span></span><br><span class="language-graphql">  <span class="hljs-punctuation">&#125;</span></span><br><span class="language-graphql">`</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">useQuery</span>(<span class="hljs-variable constant_">ALL_PERSONS</span>);<br><br>  <span class="hljs-keyword">if</span> (result.<span class="hljs-property">loading</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;result.data.allPersons.map((p) =&gt; p.name).join(&#x27;, &#x27;)&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果是一个带参数的查询，可以：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FIND_PERSON</span> = gql`<span class="language-graphql"></span><br><span class="language-graphql">  <span class="hljs-keyword">query</span> findPersonByName<span class="hljs-punctuation">(</span><span class="hljs-variable">$nameToSearch</span>: String<span class="hljs-punctuation">!</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">&#123;</span></span><br><span class="language-graphql">    findPerson<span class="hljs-punctuation">(</span><span class="hljs-symbol">name</span><span class="hljs-punctuation">:</span> <span class="hljs-variable">$nameToSearch</span>) <span class="hljs-punctuation">&#123;</span></span><br><span class="language-graphql">      name</span><br><span class="language-graphql">      phone</span><br><span class="language-graphql">      id</span><br><span class="language-graphql">      address <span class="hljs-punctuation">&#123;</span></span><br><span class="language-graphql">        street</span><br><span class="language-graphql">        city</span><br><span class="language-graphql">      <span class="hljs-punctuation">&#125;</span></span><br><span class="language-graphql">    <span class="hljs-punctuation">&#125;</span></span><br><span class="language-graphql">  <span class="hljs-punctuation">&#125;</span></span><br><span class="language-graphql">`</span>;<br><br><span class="hljs-keyword">const</span> [nameToSearch, setNameToSearch] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">useQuery</span>(<span class="hljs-variable constant_">FIND_PERSON</span>, &#123;<br>  <span class="hljs-attr">variables</span>: &#123; nameToSearch &#125;,<br>  <span class="hljs-attr">skip</span>: !nameToSearch,<br>&#125;);<br><br><span class="hljs-keyword">if</span> (nameToSearch &amp;&amp; result.<span class="hljs-property">data</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">person</span>=<span class="hljs-string">&#123;result.data.findPerson&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onClose</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setNameToSearch(null)&#125;</span><br><span class="language-xml">    /&gt;</span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>更新缓存有几种方法，第一种是 poll 服务器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">useQuery</span>(<span class="hljs-variable constant_">ALL_PERSONS</span>, &#123; <span class="hljs-attr">pollInterval</span>: <span class="hljs-number">2000</span> &#125;);<br></code></pre></td></tr></table></figure><p>缺点在于无意义的网络流量</p><p>第二种是使用 <code>refetchQueries</code>定义，每当创建一个新的人，就重新进行获取所有人员的查询：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [ createPerson ] = <span class="hljs-title function_">useMutation</span>(<span class="hljs-variable constant_">CREATE_PERSON</span>, &#123;<br><span class="hljs-attr">refetchQueries</span>: [ &#123; <span class="hljs-attr">query</span>: <span class="hljs-variable constant_">ALL_PERSONS</span> &#125;, &#123; <span class="hljs-attr">query</span>: <span class="hljs-variable constant_">OTHER_QUERY</span> &#125;, &#123; <span class="hljs-attr">query</span>: ... &#125; ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>缺点在于另一个用户更新的数据不会立刻反应给其他用户</p><p>可以定义错误处理函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">PersonForm</span> = (<span class="hljs-params">&#123; setError &#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [createPerson] = <span class="hljs-title function_">useMutation</span>(<span class="hljs-variable constant_">CREATE_PERSON</span>, &#123;<br>    <span class="hljs-attr">refetchQueries</span>: [&#123; <span class="hljs-attr">query</span>: <span class="hljs-variable constant_">ALL_PERSONS</span> &#125;],<br>    <span class="hljs-attr">onError</span>: <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">setError</span>(error.<span class="hljs-property">graphQLErrors</span>[<span class="hljs-number">0</span>].<span class="hljs-property">message</span>);<br>    &#125;,<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="数据库与用户管理">数据库与用户管理</h2><p>用户管理的模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-attr">username</span>: <span class="hljs-title class_">String</span>!<br>  <span class="hljs-attr">friends</span>: [<span class="hljs-title class_">Person</span>!]!<br>  <span class="hljs-attr">id</span>: <span class="hljs-variable constant_">ID</span>!<br>&#125;<br><br>type <span class="hljs-title class_">Token</span> &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-title class_">String</span>!<br>&#125;<br><br>type <span class="hljs-title class_">Query</span> &#123;<br>  <span class="hljs-attr">me</span>: <span class="hljs-title class_">User</span><br>&#125;<br><br>type <span class="hljs-title class_">Mutation</span> &#123;<br>  <span class="hljs-title function_">createUser</span>(<br>    <span class="hljs-attr">username</span>: <span class="hljs-title class_">String</span>!<br>  ): <span class="hljs-title class_">User</span><br>  <span class="hljs-title function_">login</span>(<br>    <span class="hljs-attr">username</span>: <span class="hljs-title class_">String</span>!<br>    <span class="hljs-attr">password</span>: <span class="hljs-title class_">String</span>!<br>  ): <span class="hljs-title class_">Token</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jsonwebtoken&#x27;</span>)<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">JWT_SECRET</span> = <span class="hljs-string">&#x27;NEED_HERE_A_SECRET_KEY&#x27;</span><br><br><span class="hljs-title class_">Mutation</span>: &#123;<br>  <span class="hljs-attr">createUser</span>: <span class="hljs-keyword">async</span> (root, args) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(&#123; <span class="hljs-attr">username</span>: args.<span class="hljs-property">username</span> &#125;)<br><br>    <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">save</span>()<br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserInputError</span>(error.<span class="hljs-property">message</span>, &#123;<br>          <span class="hljs-attr">invalidArgs</span>: args,<br>        &#125;)<br>      &#125;)<br>  &#125;,<br>  <span class="hljs-attr">login</span>: <span class="hljs-keyword">async</span> (root, args) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title class_">User</span>.<span class="hljs-title function_">findOne</span>(&#123; <span class="hljs-attr">username</span>: args.<span class="hljs-property">username</span> &#125;)<br><br>    <span class="hljs-keyword">if</span> ( !user || args.<span class="hljs-property">password</span> !== <span class="hljs-string">&#x27;secret&#x27;</span> ) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserInputError</span>(<span class="hljs-string">&quot;wrong credentials&quot;</span>) &#125;<br><br>    <span class="hljs-keyword">const</span> userForToken = &#123;<br>      <span class="hljs-attr">username</span>: user.<span class="hljs-property">username</span>,<br>      <span class="hljs-attr">id</span>: user.<span class="hljs-property">_id</span>,<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: jwt.<span class="hljs-title function_">sign</span>(userForToken, <span class="hljs-variable constant_">JWT_SECRET</span>) &#125;<br>  &#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><p>在构造函数调用中添加第三个参数 <code>context</code> 来扩展<code>server</code> 对象的定义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApolloServer</span>(&#123;<br>  typeDefs,<br>  resolvers,<br><br>  <span class="hljs-attr">context</span>: <span class="hljs-keyword">async</span> (&#123; req &#125;) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> auth = req ? req.<span class="hljs-property">headers</span>.<span class="hljs-property">authorization</span> : <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (auth &amp;&amp; auth.<span class="hljs-title function_">toLowerCase</span>().<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;bearer &#x27;</span>)) &#123;<br>      <span class="hljs-keyword">const</span> decodedToken = jwt.<span class="hljs-title function_">verify</span>(auth.<span class="hljs-title function_">substring</span>(<span class="hljs-number">7</span>), <span class="hljs-variable constant_">JWT_SECRET</span>);<br>      <span class="hljs-keyword">const</span> currentUser = <span class="hljs-keyword">await</span> <span class="hljs-title class_">User</span>.<span class="hljs-title function_">findById</span>(decodedToken.<span class="hljs-property">id</span>).<span class="hljs-title function_">populate</span>(<br>        <span class="hljs-string">&#x27;friends&#x27;</span><br>      );<br>      <span class="hljs-keyword">return</span> &#123; currentUser &#125;;<br>    &#125;<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="登录与更新缓存">登录与更新缓存</h2><p>向 header 中添加令牌：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; setContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@apollo/client/link/context&#x27;</span>;<br><br><span class="hljs-keyword">const</span> authLink = <span class="hljs-title function_">setContext</span>(<span class="hljs-function">(<span class="hljs-params">_, &#123; headers &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> token = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;phonenumbers-user-token&#x27;</span>);<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">headers</span>: &#123;<br>      ...headers,<br>      <span class="hljs-attr">authorization</span>: token ? <span class="hljs-string">`bearer <span class="hljs-subst">$&#123;token&#125;</span>`</span> : <span class="hljs-literal">null</span>,<br>    &#125;,<br>  &#125;;<br>&#125;);<br><br><span class="hljs-keyword">const</span> httpLink = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpLink</span>(&#123; <span class="hljs-attr">uri</span>: <span class="hljs-string">&#x27;http://localhost:4000&#x27;</span> &#125;);<br><br><span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApolloClient</span>(&#123;<br>  <span class="hljs-attr">cache</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">InMemoryCache</span>(),<br>  <span class="hljs-attr">link</span>: authLink.<span class="hljs-title function_">concat</span>(httpLink),<br>&#125;);<br></code></pre></td></tr></table></figure><p>还有一种手动更新缓存的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [createPerson] = <span class="hljs-title function_">useMutation</span>(<span class="hljs-variable constant_">CREATE_PERSON</span>, &#123;<br>  <span class="hljs-attr">update</span>: <span class="hljs-function">(<span class="hljs-params">cache, response</span>) =&gt;</span> &#123;<br>    cache.<span class="hljs-title function_">updateQuery</span>(&#123; <span class="hljs-attr">query</span>: <span class="hljs-variable constant_">ALL_PERSONS</span> &#125;, <span class="hljs-function">(<span class="hljs-params">&#123; allPersons &#125;</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">allPersons</span>: allPersons.<span class="hljs-title function_">concat</span>(response.<span class="hljs-property">data</span>.<span class="hljs-property">addPerson</span>),<br>      &#125;;<br>    &#125;);<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="fragments-与-subscriptions">Fragments 与 subscriptions</h2><p>两个查询必须定义完全相同的字段时，可以通过 fragment 来简化，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PERSON_DETAILS</span> = gql`<span class="language-graphql"></span><br><span class="language-graphql">  <span class="hljs-keyword">fragment</span> PersonDetails <span class="hljs-keyword">on</span> Person <span class="hljs-punctuation">&#123;</span></span><br><span class="language-graphql">    id</span><br><span class="language-graphql">    name</span><br><span class="language-graphql">    phone</span><br><span class="language-graphql">    address <span class="hljs-punctuation">&#123;</span></span><br><span class="language-graphql">      street</span><br><span class="language-graphql">      city</span><br><span class="language-graphql">    <span class="hljs-punctuation">&#125;</span></span><br><span class="language-graphql">  <span class="hljs-punctuation">&#125;</span></span><br><span class="language-graphql">`</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FIND_PERSON</span> = gql`<span class="language-graphql"></span><br><span class="language-graphql">  <span class="hljs-keyword">query</span> findPersonByName<span class="hljs-punctuation">(</span><span class="hljs-variable">$nameToSearch</span>: String<span class="hljs-punctuation">!</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">&#123;</span></span><br><span class="language-graphql">    findPerson<span class="hljs-punctuation">(</span><span class="hljs-symbol">name</span><span class="hljs-punctuation">:</span> <span class="hljs-variable">$nameToSearch</span>) <span class="hljs-punctuation">&#123;</span></span><br><span class="language-graphql">      <span class="hljs-punctuation">...</span>PersonDetails</span><br><span class="language-graphql">    <span class="hljs-punctuation">&#125;</span></span><br><span class="language-graphql">  <span class="hljs-punctuation">&#125;</span></span><br><span class="language-graphql">  </span><span class="hljs-subst">$&#123;PERSON_DETAILS&#125;</span><span class="language-graphql"></span><br><span class="language-graphql">`</span>;<br></code></pre></td></tr></table></figure><p>Apollo 使用 <ahref="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">WebSockets</a>进行服务器用户的通信</p><p>用 <ahref="https://www.apollographql.com/docs/apollo-server/integrations/middleware/#apollo-server-express">ApolloServer Express</a> 替换 Apollo 服务器</p><h1 id="typescript">TypeScript</h1><h2 id="背景与介绍">背景与介绍</h2><p>TypeScript 可以被编译为JavaScript，是它的一个超集，由语言、编译器、语言服务三部分组成</p><p>一个例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> birthdayGreeter = (<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`Happy birthday <span class="hljs-subst">$&#123;name&#125;</span>, you are now <span class="hljs-subst">$&#123;age&#125;</span> years old!`</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中函数的返回值可以不写，能够自动推断出来</p><p>支持 callback：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">CallsFunction</span> = <span class="hljs-function">(<span class="hljs-params">callback: (result: <span class="hljs-built_in">string</span>) =&gt; <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">func</span>: <span class="hljs-title class_">CallsFunction</span> = <span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">cb</span>(<span class="hljs-string">&#x27;done&#x27;</span>);<br>  <span class="hljs-title function_">cb</span>(<span class="hljs-number">1</span>);<br>&#125;;<br><br><span class="hljs-title function_">func</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="typescript-的一小步">TypeScript 的一小步</h2><p>需要安装的包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install --save-dev ts-node typescript<br></code></pre></td></tr></table></figure><p>可以自定义类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Operation</span> = <span class="hljs-string">&#x27;multiply&#x27;</span> | <span class="hljs-string">&#x27;add&#x27;</span> | <span class="hljs-string">&#x27;divide&#x27;</span>;<br></code></pre></td></tr></table></figure><p>也可以通过定义接口来定义类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MultiplyValues</span> &#123;<br>  <span class="hljs-attr">value1</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">value2</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>npm 包通常有对应的 typescript 版本，名称为<code>@types/&#123;npm_package&#125;</code>，且总是应该安装在<code>devDependencies</code> 中，并仍需要安装相应的 JavaScript 版本</p><p><code>tsconfig.json</code> 文件中包含了 TypeScript 的核心配置</p><h2 id="typescript-版的-express-应用">TypeScript 版的 express 应用</h2><p>使用 <code>tsc</code>生成 <code>tsconfig.json</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm run tsc -- --init<br></code></pre></td></tr></table></figure><p><code>nodemon</code> 的 TypeScript 替代品为<code>ts-node-dev</code></p><p>关键字 <code>as</code> 断言变量类型</p><p>可以通过在类型声明中添加 <code>?</code>，将字段的类型设置为optional</p><p>注意节点模块的加载顺序：<code>["js", "json", "node", "ts", "tsx"]</code>，最好的方法是避免重名</p><p><code>Pick</code> 实用类型允许选择想使用的现有类型的哪些字段：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> getNonSensitiveEntries = (): <span class="hljs-title class_">Pick</span>&lt;<br>  <span class="hljs-title class_">DiaryEntry</span>,<br>  <span class="hljs-string">&#x27;id&#x27;</span> | <span class="hljs-string">&#x27;date&#x27;</span> | <span class="hljs-string">&#x27;weather&#x27;</span> | <span class="hljs-string">&#x27;visibility&#x27;</span><br>&gt;[] =&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure><p><code>Omit</code> 可以用来声明要排除哪些字段：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">NonSensitiveDiaryEntry</span> = <span class="hljs-title class_">Omit</span>&lt;<span class="hljs-title class_">DiaryEntry</span>, <span class="hljs-string">&#x27;comment&#x27;</span>&gt;;<br></code></pre></td></tr></table></figure><p>注意这只是禁止访问而已，并不是不返回那些被排除的字段而已，所以需要手动排除这些字段：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> getNonSensitiveEntries = (): <span class="hljs-title class_">NonSensitiveDiaryEntry</span>[] =&gt; &#123;<br>  <span class="hljs-keyword">return</span> diaries.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">&#123; id, date &#125;</span>) =&gt;</span> (&#123; id, date &#125;));<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用 <code>unknown</code> 可以先验证类型，然后确认预期类型，如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> parseComment = (<span class="hljs-attr">comment</span>: <span class="hljs-built_in">unknown</span>): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (!comment || !<span class="hljs-title function_">isString</span>(comment)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Incorrect or missing comment&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> comment;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="利用-typescript-编写-react-应用">利用 TypeScript 编写 React应用</h2><p>创建一个 TypeScript 应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npx create-react-app my-app --template typescript<br></code></pre></td></tr></table></figure><p>组件：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Welcome</span> = (<span class="hljs-params">&#123; name &#125;: &#123; name: <span class="hljs-built_in">string</span> &#125;</span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br></code></pre></td></tr></table></figure><p>接口可以继承，这样就可以不同类型共享相同的域，然后通过<code>switch</code> 等语句区分不同的具体类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CoursePartBase</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">exerciseCount</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CoursePartOne</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CoursePartBase</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Fundamentals&#x27;</span>;<br>  <span class="hljs-attr">description</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CoursePartTwo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CoursePartBase</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Using props to pass data&#x27;</span>;<br>  <span class="hljs-attr">groupProjectCount</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">CoursePart</span> = <span class="hljs-title class_">CoursePartOne</span> | <span class="hljs-title class_">CoursePartTwo</span>;<br></code></pre></td></tr></table></figure><h1 id="react-native">React Native</h1><h2 id="react-native-介绍">React Native 介绍</h2><p>对于跨平台方案，<a href="https://cordova.apache.org/">Cordova</a>使用标准的网络技术--HTML5、CSS3 和 JavaScript来开发多平台应用，在嵌入式浏览器窗口中运行，故不能达到使用实际本地用户界面组件的本地应用的性能或外观和感觉的</p><p><a href="https://reactnative.dev/">React Native</a> 将 React的大量功能带入本地开发，在幕后利用平台的本地组件</p><p>使用 <a href="https://docs.expo.io/versions/latest/">Expo</a>初始化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npx create-expo-app rate-repository-app --template expo-template-blank@sdk-50<br></code></pre></td></tr></table></figure><p>可以使用安卓模拟器或 Expo Go 移动应用查看</p><p>安装 eslint：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install --save-dev eslint @babel/eslint-parser eslint-plugin-react eslint-plugin-react-native<br></code></pre></td></tr></table></figure><h2 id="react-native-入门">React Native 入门</h2><p>React Native 中有很多预先定义好的<ahref="https://reactnative.dev/docs/intro-react-native-components">核心组件</a>，例如文本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Text</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">HelloWorld</span> = (<span class="hljs-params">props</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Text</span>&gt;</span>Hello world!<span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>类似的还有 <a href="https://reactnative.dev/docs/view">View</a>，<ahref="https://reactnative.dev/docs/textinput">TextInput</a>，<ahref="https://reactnative.dev/docs/pressable">Pressable</a> 等组件</p><p>注意 react native 中所有样式属性都是无单位的，可用样式属性详见 <ahref="https://github.com/vhpoet/react-native-styling-cheat-sheet">ReactNative Styling Cheat Sheet</a>，其用法为：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Text</span>, <span class="hljs-title class_">View</span>, <span class="hljs-title class_">StyleSheet</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native&#x27;</span>;<br><br><span class="hljs-keyword">const</span> styles = <span class="hljs-title class_">StyleSheet</span>.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">container</span>: &#123;<br>    <span class="hljs-attr">padding</span>: <span class="hljs-number">20</span>,<br>  &#125;,<br>  <span class="hljs-attr">text</span>: &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>    <span class="hljs-attr">fontSize</span>: <span class="hljs-number">24</span>,<br>    <span class="hljs-attr">fontWeight</span>: <span class="hljs-string">&#x27;700&#x27;</span>,<br>  &#125;,<br>&#125;);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">BigBlueText</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;View style=&#123;styles.container&#125;&gt;<br>      &lt;Text style=&#123;styles.text&#125;&gt;<br>        Big blue text<br>      &lt;Text&gt;<br>    &lt;/View&gt;<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用 flexbox 布局：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">View</span>, <span class="hljs-title class_">Text</span>, <span class="hljs-title class_">StyleSheet</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native&#x27;</span>;<br><br><span class="hljs-keyword">const</span> styles = <span class="hljs-title class_">StyleSheet</span>.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">flexContainer</span>: &#123;<br>    <span class="hljs-attr">display</span>: <span class="hljs-string">&#x27;flex&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-attr">flexItemA</span>: &#123;<br>    <span class="hljs-attr">flexGrow</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;green&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-attr">flexItemB</span>: &#123;<br>    <span class="hljs-attr">flexGrow</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>  &#125;,<br>&#125;);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">FlexboxExample</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;styles.flexContainer&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;styles.flexItemA&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Text</span>&gt;</span>Flex item A<span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;styles.flexItemB&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Text</span>&gt;</span>Flex item B<span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用 <ahref="https://www.npmjs.com/package/react-router-native">react-router-native</a>来实现路由，添加到组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">StatusBar</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;expo-status-bar&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">NativeRouter</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-native&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">NativeRouter</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Main</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">NativeRouter</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">StatusBar</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;auto&#x27;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><p>添加一个路由：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Main</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">AppBar</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&#x27;/&#x27;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">RepositoryList</span> /&gt;</span>&#125; exact /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&#x27;*&#x27;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Navigate</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&#x27;/&#x27;</span> <span class="hljs-attr">replace</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><p>用 <a href="https://jaredpalmer.com/formik/">Formik</a>来管理表单：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useFormik &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;formik&#x27;</span>;<br><br><span class="hljs-keyword">const</span> initialValues = &#123;<br>  <span class="hljs-attr">mass</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">BodyMassIndexForm</span> = (<span class="hljs-params">&#123; onSubmit &#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> formik = <span class="hljs-title function_">useFormik</span>(&#123;<br>    initialValues,<br>    onSubmit,<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">TextInput</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Weight (kg)&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;formik.values.mass&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onChangeText</span>=<span class="hljs-string">&#123;formik.handleChange(</span>&#x27;<span class="hljs-attr">mass</span>&#x27;)&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Pressable</span> <span class="hljs-attr">onPress</span>=<span class="hljs-string">&#123;formik.handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Text</span>&gt;</span>Calculate<span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Pressable</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">BodyMassIndexCalculator</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onSubmit</span> = values =&gt; &#123;...&#125;;<br><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">BodyMassIndexForm</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;onSubmit&#125;</span> /&gt;</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">BodyMassIndexCalculator</span>;<br></code></pre></td></tr></table></figure><p>使用 <a href="https://github.com/jquense/yup">Yup</a> 验证：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> yup <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;yup&#x27;</span>;<br><br><span class="hljs-keyword">const</span> validationSchema = yup.<span class="hljs-title function_">object</span>().<span class="hljs-title function_">shape</span>(&#123;<br>  <span class="hljs-attr">mass</span>: yup<br>    .<span class="hljs-title function_">number</span>()<br>    .<span class="hljs-title function_">min</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Weight must be greater or equal to 1&#x27;</span>)<br>    .required(<span class="hljs-string">&#x27;Weight is required&#x27;</span>),<br>&#125;);<br><br><span class="hljs-keyword">const</span> formik = <span class="hljs-title function_">useFormik</span>(&#123;<br>  initialValues,<br>  validationSchema,<br>  onSubmit,<br>&#125;);<br></code></pre></td></tr></table></figure><p>条件渲染错误提示：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&#123;<br>  formik.<span class="hljs-property">touched</span>.<span class="hljs-property">mass</span> &amp;&amp; formik.<span class="hljs-property">errors</span>.<span class="hljs-property">mass</span> &amp;&amp; (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Text</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">color:</span> &#x27;<span class="hljs-attr">red</span>&#x27; &#125;&#125;&gt;</span>&#123;formik.errors.mass&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>可以通过 <code>Platform.OS</code> 常量来访问用户的平台：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Platform</span>.<span class="hljs-property">OS</span> === <span class="hljs-string">&#x27;android&#x27;</span> ? <span class="hljs-string">&#x27;green&#x27;</span> : <span class="hljs-string">&#x27;blue&#x27;</span>;<br></code></pre></td></tr></table></figure><p><code>Platform.select</code> 方法：给定一个对象，其键值为<code>ios</code>、<code>android</code>、<code>native</code> 和<code>default</code> 之一：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> styles = <span class="hljs-title class_">StyleSheet</span>.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">text</span>: &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-title class_">Platform</span>.<span class="hljs-title function_">select</span>(&#123;<br>      <span class="hljs-attr">android</span>: <span class="hljs-string">&#x27;green&#x27;</span>,<br>      <span class="hljs-attr">ios</span>: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>      <span class="hljs-attr">default</span>: <span class="hljs-string">&#x27;black&#x27;</span>,<br>    &#125;),<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="与服务端通信">与服务端通信</h2><p>React Native 提供了 <ahref="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">FetchAPI</a>，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://my-api.com/post-end-point&#x27;</span>, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-title class_">Accept</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<br>    <span class="hljs-attr">firstParam</span>: <span class="hljs-string">&#x27;firstValue&#x27;</span>,<br>    <span class="hljs-attr">secondParam</span>: <span class="hljs-string">&#x27;secondValue&#x27;</span>,<br>  &#125;),<br>&#125;);<br></code></pre></td></tr></table></figure><p>也可以通过 <ahref="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequestAPI</a> 使用 <a href="https://github.com/axios/axios">Axios</a>等第三方库</p><p>这里作为 GraphQL 和 Apollo client，需要安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install @apollo/client graphql @expo/metro-config<br></code></pre></td></tr></table></figure><p>在根目录下的 <code>metro.config.js</code> 添加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; getDefaultConfig &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@expo/metro-config&#x27;</span>);<br><span class="hljs-keyword">const</span> defaultConfig = <span class="hljs-title function_">getDefaultConfig</span>(__dirname);<br>defaultConfig.<span class="hljs-property">resolver</span>.<span class="hljs-property">sourceExts</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;cjs&#x27;</span>);<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = defaultConfig;<br></code></pre></td></tr></table></figure><p>创建一个 <code>apolloClient.js</code> 文件，配置连接到 Apollo服务器的客户端：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ApolloClient</span>, <span class="hljs-title class_">InMemoryCache</span>, createHttpLink &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@apollo/client&#x27;</span>;<br><br><span class="hljs-keyword">const</span> httpLink = <span class="hljs-title function_">createHttpLink</span>(&#123; <span class="hljs-attr">uri</span>: <span class="hljs-string">&#x27;http://192.168.100.16:4000/graphql&#x27;</span> &#125;);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">createApolloClient</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApolloClient</span>(&#123;<br>    <span class="hljs-attr">link</span>: httpLink,<br>    <span class="hljs-attr">cache</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">InMemoryCache</span>(),<br>  &#125;);<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> createApolloClient;<br></code></pre></td></tr></table></figure><p>添加到组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ApolloProvider</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@apollo/client&#x27;</span>;<br><span class="hljs-keyword">const</span> apolloClient = <span class="hljs-title function_">createApolloClient</span>();<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">NativeRouter</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ApolloProvider</span> <span class="hljs-attr">client</span>=<span class="hljs-string">&#123;apolloClient&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Main</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ApolloProvider</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">NativeRouter</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><p>在组织代码时，可以在 graphql 目录下创建<code>queries.js</code>，每个查询都存储在一个变量中，并一个个导出。改变则储存在mutations.js，同时善于使用 fragments.js 来精简代码</p><p>我们有组件<em>A</em>，它渲染了组件 B 和 C，则目录可以为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dir">components/<br>  A/<br>    B.jsx<br>    C.jsx<br>    index.jsx<br></code></pre></td></tr></table></figure><p>而不需要改动引入组件 A 的代码，其自动匹配到<code>A/index.jsx</code></p><p>React Native 没有对环境变量的直接支持，但可以通过改变<code>app.json</code> 文件中定义的 Expo 配置来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dotenv/config&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;rate-repository-app&#x27;</span>,<br>  <span class="hljs-attr">extra</span>: &#123;<br>    <span class="hljs-attr">env</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">ENV</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>并配合熟悉的 <code>dotenv</code></p><p>持久化本地存储 <ahref="https://react-native-async-storage.github.io/async-storage/docs/usage/">AsyncStorage</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">expo install @react-native-async-storage/async-storage<br></code></pre></td></tr></table></figure><p>和 <code>localStorage</code>类似，但顾名思义，其操作是<strong>异步</strong>的，因为是在全局命名空间操作，故最好添加一个命名空间</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">AsyncStorage</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@react-native-async-storage/async-storage&#x27;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShoppingCartStorage</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">namespace = <span class="hljs-string">&#x27;shoppingCart&#x27;</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">namespace</span> = namespace;<br>  &#125;<br><br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">getProducts</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> rawProducts = <span class="hljs-keyword">await</span> <span class="hljs-title class_">AsyncStorage</span>.<span class="hljs-title function_">getItem</span>(<br>      <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.namespace&#125;</span>:products`</span><br>    );<br>    <span class="hljs-keyword">return</span> rawProducts ? <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(rawProducts) : [];<br>  &#125;<br><br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">addProduct</span>(<span class="hljs-params">productId</span>) &#123;<br>    <span class="hljs-keyword">const</span> currentProducts = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getProducts</span>();<br>    <span class="hljs-keyword">const</span> newProducts = [...currentProducts, productId];<br>    <span class="hljs-keyword">await</span> <span class="hljs-title class_">AsyncStorage</span>.<span class="hljs-title function_">setItem</span>(<br>      <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.namespace&#125;</span>:products`</span>,<br>      <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(newProducts)<br>    );<br>  &#125;<br><br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">clearProducts</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title class_">AsyncStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.namespace&#125;</span>:products`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">doShopping</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> shoppingCartA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShoppingCartStorage</span>(<span class="hljs-string">&#x27;shoppingCartA&#x27;</span>);<br>  <span class="hljs-keyword">await</span> shoppingCartA.<span class="hljs-title function_">addProduct</span>(<span class="hljs-string">&#x27;chips&#x27;</span>);<br>  <span class="hljs-keyword">const</span> productsA = <span class="hljs-keyword">await</span> shoppingCartA.<span class="hljs-title function_">getProducts</span>();<br>  <span class="hljs-keyword">await</span> shoppingCartA.<span class="hljs-title function_">clearProducts</span>();<br>&#125;;<br></code></pre></td></tr></table></figure><p>将访问令牌发送给 Apollo 服务器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ApolloClient</span>, <span class="hljs-title class_">InMemoryCache</span>, createHttpLink &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@apollo/client&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Constants</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;expo-constants&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; setContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@apollo/client/link/context&#x27;</span>;<br><br><span class="hljs-keyword">const</span> &#123; apolloUri &#125; = <span class="hljs-title class_">Constants</span>.<span class="hljs-property">manifest</span>.<span class="hljs-property">extra</span>;<br><span class="hljs-keyword">const</span> httpLink = <span class="hljs-title function_">createHttpLink</span>(&#123; <span class="hljs-attr">uri</span>: apolloUri &#125;);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">createApolloClient</span> = (<span class="hljs-params">authStorage</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> authLink = <span class="hljs-title function_">setContext</span>(<span class="hljs-keyword">async</span> (_, &#123; headers &#125;) =&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> accessToken = <span class="hljs-keyword">await</span> authStorage.<span class="hljs-title function_">getAccessToken</span>();<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">headers</span>: &#123;<br>          ...headers,<br>          <span class="hljs-attr">authorization</span>: accessToken ? <span class="hljs-string">`Bearer <span class="hljs-subst">$&#123;accessToken&#125;</span>`</span> : <span class="hljs-string">&#x27;&#x27;</span>,<br>        &#125;,<br>      &#125;;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>      <span class="hljs-keyword">return</span> &#123;<br>        headers,<br>      &#125;;<br>    &#125;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApolloClient</span>(&#123;<br>    <span class="hljs-attr">link</span>: authLink.<span class="hljs-title function_">concat</span>(httpLink),<br>    <span class="hljs-attr">cache</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">InMemoryCache</span>(),<br>  &#125;);<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> createApolloClient;<br></code></pre></td></tr></table></figure><p>使用 React Context 来使挂钩访问到 token：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">AuthStorageContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>();<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">AuthStorageContext</span>;<br></code></pre></td></tr></table></figure><p>在 <code>app.js</code> 中：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">AuthStorageContext</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./src/contexts/AuthStorageContext&#x27;</span>;<br><br><span class="hljs-keyword">const</span> authStorage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AuthStorage</span>();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">AuthStorageContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;authStorage&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Main</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">AuthStorageContext.Provider</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用 <code>useContext</code> 钩访问：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">AuthStorageContext</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../contexts/AuthStorageContext&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">useAuthStorage</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">AuthStorageContext</span>);<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useAuthStorage;<br></code></pre></td></tr></table></figure><h2 id="测试与扩展我们的应用">测试与扩展我们的应用</h2><p>安装 <a href="https://jestjs.io/">Jest</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install --save-dev jest jest-expo eslint-plugin-jest<br></code></pre></td></tr></table></figure><p>在 package.json 文件中加入 Jest 配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;jest&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><br>  <span class="hljs-attr">&quot;jest&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;preset&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;jest-expo&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;transform&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;^.+\\.jsx?$&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;babel-jest&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;transformIgnorePatterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-string">&quot;node_modules/(?!((jest-)?react-native|@react-native(-community)?)|expo(nent)?|@expo(nent)?/.*|@expo-google-fonts/.*|react-navigation|@react-navigation/.*|@unimodules/.*|unimodules|sentry-expo|native-base|react-native-svg|react-router-native)&quot;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>把 eslint-plugin-jest 包含在 <code>.eslintrc</code>文件的插件和扩展数组中：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;extends&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;eslint:recommended&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;plugin:react/recommended&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;plugin:jest/recommended&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>存放 test文件有两种方式，第一种是把测试文件放在其相应的子目录中，就像代码本身一样，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs file">src/<br>  __tests__/<br>    components/<br>      AppBar.js<br>      RepositoryList.js<br>    utils/<br>      authStorage.js<br></code></pre></td></tr></table></figure><p>另一种方法是在实现附近组织测试，即在同一目录下（注意添加<code>.test</code> 后缀）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dir">src/<br>  components/<br>    AppBar/<br>      AppBar.test.jsx<br>      index.jsx<br></code></pre></td></tr></table></figure><p>测试组件安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install --save-dev react-test-renderer@17.0.1 @testing-library/react-native @testing-library/jest-native<br></code></pre></td></tr></table></figure><p>一个测试的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Text</span>, <span class="hljs-title class_">View</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; render &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@testing-library/react-native&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Greeting</span> = (<span class="hljs-params">&#123; name &#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Text</span>&gt;</span>Hello &#123;name&#125;!<span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;Greeting&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;renders a greeting message based on the name prop&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; debug, getByText &#125; = <span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Greeting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;Kalle&#x27;</span> /&gt;</span></span>);<br>    <span class="hljs-title function_">debug</span>();<br>    <span class="hljs-title function_">expect</span>(<span class="hljs-title function_">getByText</span>(<span class="hljs-string">&#x27;Hello Kalle!&#x27;</span>)).<span class="hljs-title function_">toBeDefined</span>();<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>对于一些非纯函数，如需要与服务器通信，可以将非纯的部分提取出来，单独测试纯函数部分：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">RepositoryListContainer</span> = (<span class="hljs-params">&#123; repositories &#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> repositoryNodes = repositories<br>    ? repositories.<span class="hljs-property">edges</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">edge</span>) =&gt;</span> edge.<span class="hljs-property">node</span>)<br>    : [];<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FlatList</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;repositoryNodes&#125;</span> /&gt;</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">RepositoryList</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123; repositories &#125; = <span class="hljs-title function_">useRepositories</span>();<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RepositoryListContainer</span> <span class="hljs-attr">repositories</span>=<span class="hljs-string">&#123;repositories&#125;</span> /&gt;</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">RepositoryList</span>;<br></code></pre></td></tr></table></figure><p>当 API从某个集合中返回一个有序的项目列表时，它通常会返回整个项目集的一个子集，以减少所需的带宽，并降低客户端应用的内存使用。客户端就可以请求例如列表中某个索引后的前20 个项目。这种技术通常被称为<strong>分页</strong></p><p>当项目可以在由<strong>游标</strong>定义的某个项目之后被请求时，我们谈论的就是<strong>基于游标的分页</strong>。</p><p>这是一个查询：</p><figure class="highlight graphql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs graphql"><span class="hljs-punctuation">&#123;</span><br>  repositories<span class="hljs-punctuation">(</span><span class="hljs-symbol">first</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">&#123;</span><br>    edges <span class="hljs-punctuation">&#123;</span><br>      node <span class="hljs-punctuation">&#123;</span><br>        fullName<br>      <span class="hljs-punctuation">&#125;</span><br>      cursor<br>    <span class="hljs-punctuation">&#125;</span><br>    pageInfo <span class="hljs-punctuation">&#123;</span><br>      endCursor<br>      startCursor<br>      hasNextPage<br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>然后使用返回的 <code>endCursor</code> 进行下一步查询</p><p><strong>无限滚动</strong>的实现方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">RepositoryListContainer</span> = (<span class="hljs-params">&#123; repositories, onEndReach &#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> repositoryNodes = repositories<br>    ? repositories.<span class="hljs-property">edges</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">edge</span>) =&gt;</span> edge.<span class="hljs-property">node</span>)<br>    : [];<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FlatList</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;repositoryNodes&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onEndReached</span>=<span class="hljs-string">&#123;onEndReach&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onEndReachedThreshold</span>=<span class="hljs-string">&#123;0.5&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">RepositoryList</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123; repositories &#125; = <span class="hljs-title function_">useRepositories</span>(<span class="hljs-comment">/* ... */</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onEndReach</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">fetchMore</span>();<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RepositoryListContainer</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">repositories</span>=<span class="hljs-string">&#123;repositories&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onEndReach</span>=<span class="hljs-string">&#123;onEndReach&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">RepositoryList</span>;<br></code></pre></td></tr></table></figure><p>并定义相关的 <code>fetchMore</code> 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">useRepositories</span> = (<span class="hljs-params">variables</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123; data, loading, fetchMore, ...result &#125; = <span class="hljs-title function_">useQuery</span>(<span class="hljs-variable constant_">GET_REPOSITORIES</span>, &#123;<br>    variables,<br>  &#125;);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleFetchMore</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> canFetchMore = !loading &amp;&amp; data?.<span class="hljs-property">repositories</span>.<span class="hljs-property">pageInfo</span>.<span class="hljs-property">hasNextPage</span>;<br><br>    <span class="hljs-keyword">if</span> (!canFetchMore) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-title function_">fetchMore</span>(&#123;<br>      <span class="hljs-attr">variables</span>: &#123;<br>        <span class="hljs-attr">after</span>: data.<span class="hljs-property">repositories</span>.<span class="hljs-property">pageInfo</span>.<span class="hljs-property">endCursor</span>,<br>        ...variables,<br>      &#125;,<br>    &#125;);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">repositories</span>: data?.<span class="hljs-property">repositories</span>,<br>    <span class="hljs-attr">fetchMore</span>: handleFetchMore,<br>    loading,<br>    ...result,<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://github.com/jondot/awesome-react-native">AwesomeReact Native</a> 中有丰富的 React Native 资源，如 <ahref="https://callstack.github.io/react-native-paper/">React NativePaper</a>，<ahref="https://styled-components.com/">Styled-components</a>，<ahref="https://www.react-spring.io/">React-spring</a>，<ahref="https://reactnavigation.org/">React Navigation</a> 等</p><h1 id="cicd">CI/CD</h1><h2 id="cicd-简介">CI/CD 简介</h2><p><strong>CI持续集成</strong>：经常性地将开发人员的修改合并到主分支上，通常有以下的步骤：</p><ul><li>提示：保持我们的代码清洁和可维护</li><li>构建：将我们所有的代码整合成软件</li><li>测试：以确保我们不会破坏现有的功能</li><li>打包：把它全部放在一个容易移动的批次中</li><li>上传/部署：将它提供给全世界</li></ul><p><strong>CD 主分支始终保持可部署</strong>，两者并没有清晰的界限</p><p>CI 有两种选择：托管我们自己的服务器（<ahref="https://www.jenkins.io/">Jenkins</a>）或使用云服务（<ahref="https://github.com/features/actions">GitHub Actions</a>）</p><h2 id="开始认识-github-actions-吧">开始认识 GitHub Actions 吧</h2><p>GitHub Action 的基础是工作流，执行过程为：</p><ol type="1"><li>触发事件发生</li><li>带有该触发器的工作流被执行</li><li>清理</li></ol><p>每个工作流必须指定至少一个 job，其中包含一组 step来执行单个任务。jobs <strong>并行</strong>执行，每个 job 中的 steps会<strong>顺序</strong>执行</p><p>工作流存储在 `<code>.github/workflows</code> 中，格式为<code>YAML</code></p><p><del>工作流也有 hello world：</del></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Hello</span> <span class="hljs-string">World!</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">hello_world_job:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-20.04</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Say</span> <span class="hljs-string">hello</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">echo</span> <span class="hljs-string">&quot;Hello World!&quot;</span><br></code></pre></td></tr></table></figure><p>使用 <code>usess</code> 执行定义好的动作，如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">simple_deployment_pipeline:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-20.04</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v4</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">&#x27;20&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">lint</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">eslint</span><br></code></pre></td></tr></table></figure><h2 id="部署">部署</h2><p>任何事情都有可能出错</p><h2 id="保持健康状态">保持健康状态</h2><p>为了保持主分支的绿色，通常避免将任何修改直接提交到主分支，而是在一个基于主分支的最新版本的分支上提交代码，然后创建PR 合并到主分支</p><p>向工作流中加入 PR 时自动检查代码的功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><br><br>  <span class="hljs-attr">pull_request:</span><br>    <span class="hljs-attr">branches:</span> [<span class="hljs-string">master</span>]<br>    <span class="hljs-attr">types:</span> [<span class="hljs-string">opened</span>, <span class="hljs-string">synchronize</span>]<br></code></pre></td></tr></table></figure><p>版本管理：</p><ul><li>语义版本管理：易读，通常用于发布</li><li>哈希版本控制：保证唯一，通常用于开发</li></ul><p>github 可以设置受保护的分支</p><h2 id="再扩展一下">再扩展一下</h2><p>在构建失败时发送通知</p><p>随着项目越来越复杂，其构建时间也越来越长，要权衡取舍</p><h1 id="容器">容器</h1><h2 id="容器介绍">容器介绍</h2><p>使用 <a href="https://www.docker.com/">Docker</a></p><p>容器也有 <code>hello world</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker container run hello-world<br></code></pre></td></tr></table></figure><p><code>docker container ls -a</code> 列出所有的容器</p><p><code>docker start 容器名或 ID</code> 启动容器</p><p><code>docker container run -it ubuntu bash</code> 在<code>bash</code> 命令行下，以交互式启动 <code>ubuntu</code> image</p><p><code>docker kill 容器名或 ID</code> 停止某个容器</p><p><code>docker commit 容器 镜像</code> 从容器中创建一个新的镜像</p><p><code>docker image ls</code> 列出所有镜像</p><p><code>docker container rm 容器名或 ID</code> 删除某个容器</p><h2 id="构建配置环境">构建配置环境</h2><p>在 <code>Dockerfile</code> 文件中配置，如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">16</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /usr/src/app</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./index.js ./index.js</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> node index.js</span><br></code></pre></td></tr></table></figure><p>使用 <code>docker build</code> 来构建一个基于 Docker文件的镜像，<code>-t</code> 用于命名</p><p><code>.dockerignore</code>文件可以防止我们不小心将不需要的文件复制到镜像中</p><p><a href="https://docs.docker.com/compose/">Docker-compose</a>可以帮助我们管理容器</p><p>这里将之前的命令转化为一个 <code>yaml</code> 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.8&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">app:</span> <span class="hljs-comment"># 服务的名字</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">express-server</span> <span class="hljs-comment"># 声明使用的镜像</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span> <span class="hljs-comment"># 如果镜像没找到，则在哪里 build 一个镜像</span><br>    <span class="hljs-attr">ports:</span> <span class="hljs-comment"># 声明发布的端口</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">3000</span><span class="hljs-string">:3000</span><br></code></pre></td></tr></table></figure><p><code>docker-compose up</code>可以构建应用并运行应用，<code>-d</code>参数表示在后台运行，<code>docker-compose down</code> 关闭</p><p>绑定挂载是将主机上的文件与容器中的文件绑定的行为，在 Docker Compose中的 volumes 键下声明：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mongo:</span><br>  <span class="hljs-attr">image:</span> <span class="hljs-string">mongo</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">3456</span><span class="hljs-string">:27017</span><br>  <span class="hljs-attr">environment:</span><br>    <span class="hljs-attr">MONGO_INITDB_ROOT_USERNAME:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">MONGO_INITDB_ROOT_PASSWORD:</span> <span class="hljs-string">example</span><br>    <span class="hljs-attr">MONGO_INITDB_DATABASE:</span> <span class="hljs-string">the_database</span><br>  <span class="hljs-attr">volumes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">./mongo/mongo-init.js:/docker-entrypoint-initdb.d/mongo-init.js</span><br></code></pre></td></tr></table></figure><p>Docker 的 <code>exec</code> 命令可以在一个容器运行时直接跳入它，如<code>docker exec -it wonderful_ramanujan bash</code></p><p><a href="https://redis.io/">Redis</a>是一个非关系型数据库，默认情况下在内存中工作，故可以用作缓存。除此之外也可以实现“发布-订阅”模式，即作为多个应用之间的消息代理工作</p><h2 id="编排基础">编排基础</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;serve&quot;</span>, <span class="hljs-string">&quot;build&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>是 CMD 的 <code>exec</code> 形式</p><p>多阶段构建：将构建过程分成许多独立的阶段，可以限制镜像文件的大小：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 第一个 FROM 是 build-stage 阶段</span><br><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">16</span> AS build-stage<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /usr/src/app</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm ci</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm run build</span><br><span class="hljs-comment"># 新的阶段，之前的都完成了，除了我们想要 COPY 的文件</span><br><span class="hljs-keyword">FROM</span> nginx:<span class="hljs-number">1.20</span>-alpine<br><span class="hljs-comment"># 从 build-stage 中构建的目录复制到 /usr/share/nginx/html</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=build-stage /usr/src/app/build /usr/share/nginx/html</span><br></code></pre></td></tr></table></figure><p>也可以设置为直接在容器中开发程序：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">app:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">hello-front-dev</span><br>    <span class="hljs-attr">build:</span><br>      <span class="hljs-attr">context:</span> <span class="hljs-string">.</span> <span class="hljs-comment"># The context will pick this directory as the &quot;build context&quot;</span><br>      <span class="hljs-attr">dockerfile:</span> <span class="hljs-string">dev.Dockerfile</span> <span class="hljs-comment"># This will simply tell which dockerfile to read</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./:/usr/src/app</span> <span class="hljs-comment"># The path can be relative, so ./ is enough to say &quot;the same location as the docker-compose.yml&quot;</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">3000</span><span class="hljs-string">:3000</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">hello-front-dev</span> <span class="hljs-comment"># This will name the container hello-front-dev</span><br></code></pre></td></tr></table></figure><p>不过安装新的依赖比较麻烦，最好是在容器中安装，如<code>docker exec hello-front-dev npm install axios</code> 并重新<code>docker build</code></p><p><a href="https://www.busybox.net/">Busybox</a>可以帮助我们调试我们的配置，加入</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">debug-helper:</span><br>  <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br></code></pre></td></tr></table></figure><p>如发送一个请求：<code>docker-compose run debug-helper wget -O - http://app:3000</code></p><p>注意到 docker 的容器间有一个 DNS，<code>app</code>域名被解析为某容器中的网络了</p><h1 id="使用关系型数据库">使用关系型数据库</h1><h2 id="用-sequelize-使用关系型数据库">用 Sequelize使用关系型数据库</h2><p>之前使用的 MongoDB是<strong>无模式</strong>的，这里介绍一个关系型数据库——<ahref="https://www.postgresql.org/">PostgreSQL</a></p><p>安装完成后，有图形用户界面，如 <ahref="https://www.pgadmin.org/">pgAdmin</a>，这里使用命令行 <ahref="https://www.postgresql.org/docs/current/app-psql.html">psql</a></p><p><code>\d</code> 命令可以告诉数据库的内容</p><p>一个创建表的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> notes (<br>    id SERIAL <span class="hljs-keyword">PRIMARY</span> KEY,<br>    content text <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    important <span class="hljs-type">boolean</span>,<br>    <span class="hljs-type">date</span> <span class="hljs-type">time</span><br>);<br></code></pre></td></tr></table></figure><p><code>\d notes</code> 查看表格 notes</p><p>添加内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> notes (content, important) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;Relational databases rule the world&#x27;</span>, <span class="hljs-literal">true</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> notes (content, important) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;MongoDB is webscale&#x27;</span>, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p><a href="https://sequelize.org/master/">sequelize</a> 库可以在不使用SQL 语言的情况下存储 JavaScript 对象</p><p>与数据库建立连接的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;dotenv&#x27;</span>).<span class="hljs-title function_">config</span>();<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Sequelize</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;sequelize&#x27;</span>);<br><br><span class="hljs-keyword">const</span> sequelize = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sequelize</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">DATABASE_URL</span>, &#123;<br>  <span class="hljs-attr">dialectOptions</span>: &#123;<br>    <span class="hljs-attr">ssl</span>: &#123;<br>      <span class="hljs-attr">require</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">rejectUnauthorized</span>: <span class="hljs-literal">false</span>,<br>    &#125;,<br>  &#125;,<br>&#125;);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">main</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">await</span> sequelize.<span class="hljs-title function_">authenticate</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Connection has been established successfully.&#x27;</span>);<br>    sequelize.<span class="hljs-title function_">close</span>();<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Unable to connect to the database:&#x27;</span>, error);<br>  &#125;<br>&#125;;<br><br><span class="hljs-title function_">main</span>();<br></code></pre></td></tr></table></figure><p>建立代码中的模型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Note</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Model</span> &#123;&#125;<br><span class="hljs-title class_">Note</span>.<span class="hljs-title function_">init</span>(<br>  &#123;<br>    <span class="hljs-attr">id</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">DataTypes</span>.<span class="hljs-property">INTEGER</span>,<br>      <span class="hljs-attr">primaryKey</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">autoIncrement</span>: <span class="hljs-literal">true</span>,<br>    &#125;,<br>    <span class="hljs-attr">content</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">DataTypes</span>.<span class="hljs-property">TEXT</span>,<br>      <span class="hljs-attr">allowNull</span>: <span class="hljs-literal">false</span>,<br>    &#125;,<br>    <span class="hljs-attr">important</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">DataTypes</span>.<span class="hljs-property">BOOLEAN</span>,<br>    &#125;,<br>    <span class="hljs-attr">date</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">DataTypes</span>.<span class="hljs-property">DATE</span>,<br>    &#125;,<br>  &#125;,<br>  &#123;<br>    sequelize,<br>    <span class="hljs-attr">underscored</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">timestamps</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">modelName</span>: <span class="hljs-string">&#x27;note&#x27;</span>,<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><p>查找全部：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/notes&#x27;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> notes = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Note</span>.<span class="hljs-title function_">findAll</span>();<br>  res.<span class="hljs-title function_">json</span>(notes);<br>&#125;);<br></code></pre></td></tr></table></figure><p>创建新的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> note = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Note</span>.<span class="hljs-title function_">create</span>(req.<span class="hljs-property">body</span>);<br></code></pre></td></tr></table></figure><p>也可以分为两步：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> note = <span class="hljs-title class_">Note</span>.<span class="hljs-title function_">build</span>(req.<span class="hljs-property">body</span>);<br>note.<span class="hljs-property">important</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">await</span> note.<span class="hljs-title function_">save</span>();<br></code></pre></td></tr></table></figure><p>根据 id 查找：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> note = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Note</span>.<span class="hljs-title function_">findByPk</span>(req.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>);<br></code></pre></td></tr></table></figure><h2 id="加入表与查询">加入表与查询</h2><p>项目的文件结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs file">index.js<br>util<br>  config.js<br>  db.js<br>models<br>  index.js<br>  note.js<br>controllers<br>  notes.js<br></code></pre></td></tr></table></figure><p>两个表之间建立一对多的关系：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">hasMany</span>(<span class="hljs-title class_">Note</span>);<br><span class="hljs-title class_">Note</span>.<span class="hljs-title function_">belongsTo</span>(<span class="hljs-title class_">User</span>);<br><span class="hljs-title class_">Note</span>.<span class="hljs-title function_">sync</span>(&#123; <span class="hljs-attr">alter</span>: <span class="hljs-literal">true</span> &#125;);<br><span class="hljs-title class_">User</span>.<span class="hljs-title function_">sync</span>(&#123; <span class="hljs-attr">alter</span>: <span class="hljs-literal">true</span> &#125;);<br></code></pre></td></tr></table></figure><p>查询时包括的内容也一并返回：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> <span class="hljs-title class_">User</span>.<span class="hljs-title function_">findAll</span>(&#123;<br>  <span class="hljs-attr">include</span>: &#123; <span class="hljs-attr">model</span>: <span class="hljs-title class_">Note</span> &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>还可以进一步限制想要的字段的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> notes = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Note</span>.<span class="hljs-title function_">findAll</span>(&#123;<br>  <span class="hljs-attr">attributes</span>: &#123; <span class="hljs-attr">exclude</span>: [<span class="hljs-string">&#x27;userId&#x27;</span>] &#125;,<br>  <span class="hljs-attr">include</span>: &#123;<br>    <span class="hljs-attr">model</span>: <span class="hljs-title class_">User</span>,<br>    <span class="hljs-attr">attributes</span>: [<span class="hljs-string">&#x27;name&#x27;</span>],<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>我们可以实现一个带参数的查询，如<code>http://localhost:3001/api/notes?search=database&amp;important=true</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> where = &#123;&#125;;<br><span class="hljs-keyword">if</span> (req.<span class="hljs-property">query</span>.<span class="hljs-property">important</span>) &#123;<br>  where.<span class="hljs-property">important</span> = req.<span class="hljs-property">query</span>.<span class="hljs-property">important</span> === <span class="hljs-string">&#x27;true&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (req.<span class="hljs-property">query</span>.<span class="hljs-property">search</span>) &#123;<br>  where.<span class="hljs-property">content</span> = &#123; [<span class="hljs-title class_">Op</span>.<span class="hljs-property">substring</span>]: req.<span class="hljs-property">query</span>.<span class="hljs-property">search</span> &#125;;<br>&#125;<br><span class="hljs-keyword">const</span> notes = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Note</span>.<span class="hljs-title function_">findAll</span>(&#123;<br>  <span class="hljs-attr">attributes</span>: &#123; <span class="hljs-attr">exclude</span>: [<span class="hljs-string">&#x27;userId&#x27;</span>] &#125;,<br>  <span class="hljs-attr">include</span>: &#123;<br>    <span class="hljs-attr">model</span>: user,<br>    <span class="hljs-attr">attributes</span>: [<span class="hljs-string">&#x27;name&#x27;</span>],<br>  &#125;,<br>  where,<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="迁移多对多关系">迁移，多对多关系</h2><p><strong>迁移 migrantion</strong> 是一个单一的 JavaScript文件，描述了对数据库的一些修改，迁移引起的变化同步到数据库模式中，最终实现了修改可控</p><p>这是一个迁移的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">up</span>: <span class="hljs-keyword">async</span> (&#123; <span class="hljs-attr">context</span>: queryInterface &#125;) =&gt; &#123;<br>    <span class="hljs-keyword">await</span> queryInterface.<span class="hljs-title function_">createTable</span>(<span class="hljs-string">&#x27;notes&#x27;</span>, &#123;<br>      <span class="hljs-attr">id</span>: &#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-title class_">DataTypes</span>.<span class="hljs-property">INTEGER</span>,<br>        <span class="hljs-attr">primaryKey</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">autoIncrement</span>: <span class="hljs-literal">true</span>,<br>      &#125;,<br>      <span class="hljs-attr">content</span>: &#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-title class_">DataTypes</span>.<span class="hljs-property">TEXT</span>,<br>        <span class="hljs-attr">allowNull</span>: <span class="hljs-literal">false</span>,<br>      &#125;,<br>    &#125;);<br>    <span class="hljs-keyword">await</span> queryInterface.<span class="hljs-title function_">createTable</span>(<span class="hljs-string">&#x27;users&#x27;</span>, &#123;<br>      <span class="hljs-attr">id</span>: &#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-title class_">DataTypes</span>.<span class="hljs-property">INTEGER</span>,<br>        <span class="hljs-attr">primaryKey</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">autoIncrement</span>: <span class="hljs-literal">true</span>,<br>      &#125;,<br>      <span class="hljs-attr">username</span>: &#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-title class_">DataTypes</span>.<span class="hljs-property">STRING</span>,<br>        <span class="hljs-attr">unique</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">allowNull</span>: <span class="hljs-literal">false</span>,<br>      &#125;,<br>    &#125;);<br>    <span class="hljs-keyword">await</span> queryInterface.<span class="hljs-title function_">addColumn</span>(<span class="hljs-string">&#x27;notes&#x27;</span>, <span class="hljs-string">&#x27;user_id&#x27;</span>, &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">DataTypes</span>.<span class="hljs-property">INTEGER</span>,<br>      <span class="hljs-attr">allowNull</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">references</span>: &#123; <span class="hljs-attr">model</span>: <span class="hljs-string">&#x27;users&#x27;</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;id&#x27;</span> &#125;,<br>    &#125;);<br>  &#125;,<br>  <span class="hljs-attr">down</span>: <span class="hljs-keyword">async</span> (&#123; <span class="hljs-attr">context</span>: queryInterface &#125;) =&gt; &#123;<br>    <span class="hljs-keyword">await</span> queryInterface.<span class="hljs-title function_">dropTable</span>(<span class="hljs-string">&#x27;notes&#x27;</span>);<br>    <span class="hljs-keyword">await</span> queryInterface.<span class="hljs-title function_">dropTable</span>(<span class="hljs-string">&#x27;users&#x27;</span>);<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>函数 <code>up</code> 是定义了在执行迁移时应该如何修改数据库，而<code>down</code> 定义如何撤销迁移</p><p>迁移文件命名总是以日期和序号开始，如<code>migrations/20211209_00_initialize_notes_and_users.js</code></p><p><a href="https://github.com/sequelize/umzug">Umzug</a>库可以从程序中手动执行迁移：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Umzug</span>, <span class="hljs-title class_">SequelizeStorage</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;umzug&#x27;</span>);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">runMigrations</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> migrator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Umzug</span>(&#123;<br>    <span class="hljs-attr">migrations</span>: &#123;<br>      <span class="hljs-attr">glob</span>: <span class="hljs-string">&#x27;migrations/*.js&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-attr">storage</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">SequelizeStorage</span>(&#123; sequelize, <span class="hljs-attr">tableName</span>: <span class="hljs-string">&#x27;migrations&#x27;</span> &#125;),<br>    <span class="hljs-attr">context</span>: sequelize.<span class="hljs-title function_">getQueryInterface</span>(),<br>    <span class="hljs-attr">logger</span>: <span class="hljs-variable language_">console</span>,<br>  &#125;);<br>  <span class="hljs-keyword">const</span> migrations = <span class="hljs-keyword">await</span> migrator.<span class="hljs-title function_">up</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Migrations up to date&#x27;</span>, &#123;<br>    <span class="hljs-attr">files</span>: migrations.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">mig</span>) =&gt;</span> mig.<span class="hljs-property">name</span>),<br>  &#125;);<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">connectToDatabase</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">await</span> sequelize.<span class="hljs-title function_">authenticate</span>();<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">runMigrations</span>();<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于<strong>多对多</strong>模型，需要用到连接模型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Membership</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Model</span> &#123;&#125;<br><span class="hljs-title class_">Membership</span>.<span class="hljs-title function_">init</span>(<br>  &#123;<br>    <span class="hljs-attr">id</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">DataTypes</span>.<span class="hljs-property">INTEGER</span>,<br>      <span class="hljs-attr">primaryKey</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">autoIncrement</span>: <span class="hljs-literal">true</span>,<br>    &#125;,<br>    <span class="hljs-attr">user_id</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">DataTypes</span>.<span class="hljs-property">INTEGER</span>,<br>      <span class="hljs-attr">allowNull</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">references</span>: &#123; <span class="hljs-attr">model</span>: <span class="hljs-string">&#x27;users&#x27;</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;id&#x27;</span> &#125;,<br>    &#125;,<br>    <span class="hljs-attr">team_id</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">DataTypes</span>.<span class="hljs-property">INTEGER</span>,<br>      <span class="hljs-attr">allowNull</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">references</span>: &#123; <span class="hljs-attr">model</span>: <span class="hljs-string">&#x27;teams&#x27;</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;id&#x27;</span> &#125;,<br>    &#125;,<br>  &#125;,<br>  &#123;<br>    sequelize,<br>    <span class="hljs-attr">underscored</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">timestamps</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">modelName</span>: <span class="hljs-string">&#x27;membership&#x27;</span>,<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><p>然后连接：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./user&#x27;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Team</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./team&#x27;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Membership</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./membership&#x27;</span>);<br><br><span class="hljs-title class_">User</span>.<span class="hljs-title function_">belongsToMany</span>(<span class="hljs-title class_">Team</span>, &#123; <span class="hljs-attr">through</span>: <span class="hljs-title class_">Membership</span> &#125;);<br><span class="hljs-title class_">Team</span>.<span class="hljs-title function_">belongsToMany</span>(<span class="hljs-title class_">User</span>, &#123; <span class="hljs-attr">through</span>: <span class="hljs-title class_">Membership</span> &#125;);<br></code></pre></td></tr></table></figure><p>注意到模型和迁移的代码很多部分是重复的，但是代码可能会随着时间改变，而迁移则充当了“记录”的功能，故不可复用数据，只能手动复制</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;
        
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://old-driver-zero.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="web" scheme="https://old-driver-zero.github.io/tags/web/"/>
    
      <category term="赫尔辛基大学" scheme="https://old-driver-zero.github.io/tags/%E8%B5%AB%E5%B0%94%E8%BE%9B%E5%9F%BA%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>包管理器</title>
    <link href="https://old-driver-zero.github.io/posts/13aafbc3.html"/>
    <id>https://old-driver-zero.github.io/posts/13aafbc3.html</id>
    <published>2023-12-31T00:17:22.000Z</published>
    <updated>2024-04-07T02:12:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="python-包管理器anaconda">Python 包管理器——Anaconda</h1><h2 id="什么是-anaconda">什么是 Anaconda？</h2><p>Anaconda（<ahref="https://www.anaconda.com/">官方网站</a>）就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。Anaconda包含了 conda、Python 在内的超过 180 个科学包及其依赖项。</p><p>Anaconda、conda、pip 的区别：</p><ul><li><strong>Anaconda</strong> 是一个包含 180+的科学包及其依赖项的发行版本。其包含的科学包包括：conda, numpy, scipy,ipython notebook 等。</li><li><strong>conda</strong> 是包及其依赖项和环境的管理工具<ul><li>快速安装、运行和升级包及其依赖项</li><li>在计算机中便捷地创建、保存、加载和切换环境</li><li>conda 为 Python 项目而创造，但可适用于多种语言</li></ul></li><li><strong>pip</strong> 是用于安装和管理软件包的包管理器</li></ul><p>conda 和 pip 的比较：</p><ul><li><p>依赖项检查</p><ul><li><p>pip</p><ul><li><strong>不一定</strong>会展示所需其他依赖包</li><li>安装包时<strong>或许</strong>会直接忽略依赖项而安装，仅在结果中提示错误</li></ul></li><li><p>conda</p><ul><li>列出所需其他依赖包</li><li>安装包时自动安装其依赖项</li><li>可以便捷地在包的不同版本中自由切换</li></ul></li></ul></li><li><p>环境管理</p><ul><li>pip：维护多个环境难度较大</li><li>conda：比较方便地在不同环境之间进行切换，环境管理较为简单</li></ul></li><li><p>对系统自带 Python 的影响</p><ul><li>pip：在系统自带 Python 中包的更新/回退版本/卸载将影响其他程序</li><li>conda：不会影响系统自带 Python</li></ul></li></ul><h2 id="安装">安装</h2><p><a href="https://www.anaconda.com/download">官网下载</a></p><ul><li><strong>不要</strong>以管理员身份安装</li><li><strong>不要</strong>勾选 “Add Anaconda to my PATH environmentvariable.”</li></ul><h2 id="更新与换源">更新与换源</h2><p>添加三个环境变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">anaconda3\Library\bin<br>anaconda3\Scripts<br>anaconda3\<br></code></pre></td></tr></table></figure><p>验证 conda 已被安装：<code>conda --version</code></p><p>更新 conda 至最新版本：<code>conda update conda</code></p><p>升级 Anaconda Navigator：<code>conda update anaconda-navigator</code></p><p>升级所有包：<code>conda update --all</code></p><p>查看 conda 帮助信息：<code>conda -h</code></p><p>换源：把 <code>/用户名/.condarc</code> 换成<ahref="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">清华源</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">channels:<br>  - defaults<br>show_channel_urls: true<br>default_channels:<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2<br>custom_channels:<br>  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  deepmodeling: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/<br></code></pre></td></tr></table></figure><p>并运行 <code>conda clean -i</code> 清除索引</p><h2 id="管理环境">管理环境</h2><p><strong>创建新环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda create --name &lt;env_name&gt; &lt;package_names&gt;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li><code>&lt;env_name&gt;</code> 即创建的环境名</li><li><code>&lt;package_names&gt;</code> 即安装在环境中的包名</li><li>如果要安装指定的版本号，则只需要在包名后面以 <code>python=</code>和版本号的形式执行。如：<code>conda create --name python2 python=2.7</code>，即创建一个名为 <code>python2</code> 的环境，环境中安装版本为 2.7 的python</li><li>如果要在新创建的环境中创建多个包，则直接在<code>&lt;package_names&gt;</code> 后以空格隔开，添加多个包名即可。如：<code>conda create -n python3 python=3.5 numpy pandas</code>，即创建一个名为 <code>python3</code>的环境，环境中安装版本为 3.5 的python，同时也安装了 numpy 和 pandas</li></ul><p><strong>切换环境</strong>：<code>activate &lt;env_name&gt;</code></p><p><strong>退出环境</strong>：<code>deactivate</code></p><p><strong>显示已创建环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda info --envs<br>或<br>conda info -e<br>或<br>conda env list<br></code></pre></td></tr></table></figure><p><strong>复制环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda create --name &lt;new_env_name&gt; --clone &lt;copied_env_name&gt;<br></code></pre></td></tr></table></figure><p><strong>删除环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda remove --name &lt;env_name&gt; --all<br></code></pre></td></tr></table></figure><h2 id="管理包">管理包</h2><p><strong>查找可供安装的包版本</strong></p><ul><li>精确查找</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda search --full-name &lt;package_full_name&gt;<br></code></pre></td></tr></table></figure><ul><li>模糊查找</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda search &lt;text&gt;<br></code></pre></td></tr></table></figure><p><strong>获取当前环境中已安装的包信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda list<br></code></pre></td></tr></table></figure><p><strong>安装包</strong></p><ul><li>在指定环境中安装包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda install --name &lt;env_name&gt; &lt;package_name&gt;<br></code></pre></td></tr></table></figure><ul><li>在当前环境中安装包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda install &lt;package_name&gt;<br></code></pre></td></tr></table></figure><p><strong>卸载包</strong></p><ul><li>在指定环境中卸载包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda remove --name &lt;env_name&gt; &lt;package_name&gt;<br></code></pre></td></tr></table></figure><ul><li>在当前环境中卸载包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda remove &lt;package_name&gt;<br></code></pre></td></tr></table></figure><p><strong>更新包</strong></p><ul><li>更新指定包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda update &lt;package_name&gt;<br></code></pre></td></tr></table></figure><ul><li>更新所有包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda update --all<br></code></pre></td></tr></table></figure><h2 id="用-pip-命令安装">用 pip 命令安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install &lt;package_name&gt;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>pip 只是包管理器，无法对环境进行管理。因此如果想在指定环境中使用 pip进行安装包，则需要先切换到指定环境中，再使用 pip 命令安装包。</li><li>pip 无法更新 python，因为 pip 并不将 python 视为包。</li><li>pip 可以安装一些 conda 无法安装的包；conda 也可以安装一些 pip无法安装的包。因此当使用一种命令无法安装包时，可以尝试用另一种命令。</li></ul><h2 id="从-anaconda-安装包">从 Anaconda 安装包</h2><p>点击 <a href="http://anaconda.org/">AnacondaCloud</a>，搜索包名，复制代码</p><h1 id="node.js-包管理器">Node.js 包管理器</h1><h2 id="npm">npm</h2><p><strong>npm (Node Package Manager)</strong> 是 Node.js自带的包管理器，安装了 Node.js 即可使用</p><p>常用命令：</p><table><colgroup><col style="width: 43%" /><col style="width: 56%" /></colgroup><thead><tr class="header"><th>命令</th><th>效果</th></tr></thead><tbody><tr class="odd"><td><code>npm init</code></td><td>创建一个新的 package.json 文件</td></tr><tr class="even"><td><code>npm install</code></td><td>安装 package.json 文件中指定的依赖项</td></tr><tr class="odd"><td><code>npm install &lt;package name&gt; --save</code> 或<code>-S</code></td><td>安装指定的依赖项，并添加到 package.json 的 dependencies 中</td></tr><tr class="even"><td><code>npm install &lt;package name&gt; --save-dev</code> 或<code>-D</code></td><td>安装指定的依赖项，并添加到 package.json 的 devDependencies 中</td></tr><tr class="odd"><td><code>npm update</code></td><td>更新 package.json 文件中指定的所有包</td></tr><tr class="even"><td><code>npm update &lt;package name&gt;</code></td><td>更新指定的包</td></tr><tr class="odd"><td><code>npm uninstall &lt;package name&gt;</code></td><td>卸载指定的依赖项</td></tr><tr class="even"><td><code>npm run &lt;script name&gt;</code></td><td>运行 package.json 文件中指定的脚本</td></tr><tr class="odd"><td><code>npm ls</code></td><td>列出当前项目中已安装的所有包及其依赖关系</td></tr><tr class="even"><td><code>npm install &lt;package name&gt; -g</code></td><td>全局安装包</td></tr></tbody></table><p>可以使用 <code>nrm</code> 切换 npm源：<code>npm install nrm -g</code></p><p>列出可用源：<code>nrm ls</code></p><p>切换源：<code>nrm use &lt;registry&gt;</code></p><h2 id="yarn">yarn</h2><p>Yarn 同样是一个 JavaScript 的包管理器</p><p>使用 npm 安装：<code>npm install -g yarn</code></p><p>这里只列出一些和 npm 不同的命令：</p><ul><li><code>yarn add [package]</code></li><li><code>yarn remove [package]</code></li><li><code>yarn upgrade [package]</code></li></ul><p>使用 <code>yrm</code> 管理源</p><h2 id="pnpm">pnpm</h2><p>pnpm 同样是包管理器</p><h1 id="linux-包管理器aptapt-get">Linux 包管理器——apt/apt-get</h1><p>Debian 系（包括 Ubuntu）通常使用 apt/apt-get 作为包管理器</p><table><thead><tr class="header"><th>命令</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>apt install</td><td>安装一个软件包</td></tr><tr class="even"><td>apt remove</td><td>移除一个软件包</td></tr><tr class="odd"><td>apt purge</td><td>移除包及相关配置</td></tr><tr class="even"><td>apt update</td><td>刷新仓库索引</td></tr><tr class="odd"><td>apt upgrade</td><td>升级所有可升级的软件包</td></tr><tr class="even"><td>apt autoremove</td><td>移除多余的软件包</td></tr><tr class="odd"><td>apt full-upgrade</td><td>升级软件包，并自动处理依赖</td></tr><tr class="even"><td>apt search</td><td>搜索某个程序</td></tr><tr class="odd"><td>apt show</td><td>显示软件包详情</td></tr></tbody></table><p><strong>换源</strong></p><p>编辑 <code>/etc/apt/sources.list</code></p><p>更换为中科大源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs list">deb https://mirrors.ustc.edu.cn/ubuntu/ focal main restricted universe multiverse<br>deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal main restricted universe multiverse<br>deb https://mirrors.ustc.edu.cn/ubuntu/ focal-updates main restricted universe multiverse<br>deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-updates main restricted universe multiverse<br>deb https://mirrors.ustc.edu.cn/ubuntu/ focal-backports main restricted universe multiverse<br>deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-backports main restricted universe multiverse<br>deb https://mirrors.ustc.edu.cn/ubuntu/ focal-security main restricted universe multiverse<br>deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-security main restricted universe multiverse<br>deb https://mirrors.ustc.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse<br>deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;python-包管理器anaconda&quot;&gt;Python
        
      
    
    </summary>
    
    
      <category term="工具" scheme="https://old-driver-zero.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="web" scheme="https://old-driver-zero.github.io/tags/web/"/>
    
      <category term="Node.js" scheme="https://old-driver-zero.github.io/tags/Node-js/"/>
    
      <category term="python" scheme="https://old-driver-zero.github.io/tags/python/"/>
    
      <category term="Linux" scheme="https://old-driver-zero.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>全栈公开课（第一部分）</title>
    <link href="https://old-driver-zero.github.io/posts/320cf12b.html"/>
    <id>https://old-driver-zero.github.io/posts/320cf12b.html</id>
    <published>2023-12-27T00:17:22.000Z</published>
    <updated>2024-04-18T08:40:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="web-app-基础">Web app 基础</h1><p>web 开发第一原则：<strong>始终打开控制台</strong></p><p>可以在控制台查看网络信息</p><p>传统 web 应用：获取 html，获取 css，获取 JavaScript</p><p>html 是树状的结构（<strong>DOM</strong>）</p><p>可以从控制台操作 DOM</p><p>接下来是 <strong>AJAX Asynchronous JavaScript and XML</strong>时代</p><h1 id="react-入门">React 入门</h1><h2 id="react-简介">React 简介</h2><p>先安装 <a href="https://nodejs.org/en">Node.js</a></p><p>创建应用：<code>npm create vite@latest part1 -- --template react</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello world<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><p>.jsx 文件看起来返回的是 HTML 标记，实际上底层转化为了 JavaScript</p><p>注意 JSX 的每个标签都必须关闭，即写成 <code>&lt;br /&gt;</code></p><p>使用 <code>props</code> 向组件传递数据</p><p>React 组件名称必须大写</p><p>React 组件内容需要包含一个根元素，故返回值的最外层通常要加上<code>&lt;div&gt;&lt;/div&gt;</code> 或<code>&lt;&gt;&lt;/&gt;</code></p><h2 id="组件状态事件处理">组件状态，事件处理</h2><p>可以在组件内部定义助手函数</p><p>结构可用于参数传递时，如</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Hello</span> = (<span class="hljs-params">&#123; name, age &#125;</span>) =&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure><p>状态钩子的用法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [counter, setCounter] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setCounter</span>(counter + <span class="hljs-number">1</span>), <span class="hljs-number">1000</span>);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;counter&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p>事件处理：注意要求的事件处理器是对函数的引用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [counter, setCounter] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;clicked&#x27;</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;counter&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>plus<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="深入-react-应用调试">深入 React 应用调试</h2><p>复杂状态：可以使用对象或数组作为状态</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [clicks, setClicks] = <span class="hljs-title function_">useState</span>(&#123; <span class="hljs-attr">left</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">right</span>: <span class="hljs-number">0</span> &#125;);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleLeftClick</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">setClicks</span>(&#123; ...clicks, <span class="hljs-attr">left</span>: clicks.<span class="hljs-property">left</span> + <span class="hljs-number">1</span> &#125;);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleRightClick</span> = (<span class="hljs-params"></span>) =&gt;<br>    <span class="hljs-title function_">setClicks</span>(&#123; ...clicks, <span class="hljs-attr">right</span>: clicks.<span class="hljs-property">right</span> + <span class="hljs-number">1</span> &#125;);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;clicks.left&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleLeftClick&#125;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleRightClick&#125;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      &#123;clicks.right&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>useState</code> 函数<strong>只能</strong>直接在 component中定义</p><h1 id="与服务端通信">与服务端通信</h1><h2 id="从渲染集合到模块学习">从渲染集合到模块学习</h2><p>可以使用 <code>map</code> 函数从数组中生成渲染对象，注意要有 key属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">notes.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">note</span>) =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;note.id&#125;</span>&gt;</span>&#123;note.content&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>);<br></code></pre></td></tr></table></figure><h2 id="表单">表单</h2><p>输入框处理：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params">props</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [newNote, setNewNote] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;a new note...&#x27;</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleNoteChange</span> = (<span class="hljs-params">event</span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);<br>    <span class="hljs-title function_">setNewNote</span>(event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;addNote&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;newNote&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleNoteChange&#125;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;submit&#x27;</span>&gt;</span>save<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="从服务器获取数据">从服务器获取数据</h2><p>使用 <ahref="https://github.com/typicode/json-server">json-server</a>，安装为开发依赖项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install json-server --save-dev<br></code></pre></td></tr></table></figure><p>在 <code>package.json</code> 文件的 <code>scripts</code>部分做一个小小的补充：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;server&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;json-server -p3001 --watch db.json&quot;</span><br></code></pre></td></tr></table></figure><p>数据存储在 <code>db.json</code> 中</p><p>使用 <a href="https://github.com/axios/axios">axios</a>库来代替浏览器和服务器之间的通信</p><p>effect hook 可以对函数组件进行副作用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;effect&#x27;</span>);<br>  axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://localhost:3001/notes&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise fulfilled&#x27;</span>);<br>    <span class="hljs-title function_">setNotes</span>(response.<span class="hljs-property">data</span>);<br>  &#125;);<br>&#125;, []);<br></code></pre></td></tr></table></figure><p><code>useEffect</code> 第二个参数用于指定效果的运行频率，这里使用<code>[]</code> 表示只在第一次渲染时运行</p><h2 id="在服务端将数据-alert-出来">在服务端将数据 Alert 出来</h2><p>json-server 比较接近 RESTful 的 API</p><p>在 REST 中，把单个数据对象称作资源，可以通过 <code>note/3</code>找到一个单独的笔记，其中 <code>3</code> 表示该笔记的 id</p><p>json-server 的所有数据用 json 格式发送</p><p>向服务器发送数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">addNote = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  event.<span class="hljs-title function_">preventDefault</span>();<br>  <span class="hljs-keyword">const</span> noteObject = &#123;<br>    <span class="hljs-attr">content</span>: newNote,<br>    <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),<br>    <span class="hljs-attr">important</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &gt; <span class="hljs-number">0.5</span>,<br>  &#125;;<br><br>  axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;http://localhost:3001/notes&#x27;</span>, noteObject).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">setNotes</span>(notes.<span class="hljs-title function_">concat</span>(response.<span class="hljs-property">data</span>));<br>    <span class="hljs-title function_">setNewNote</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用 HTTP PUT 请求来替换整个笔记：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">toggleImportanceOf</span> = (<span class="hljs-params">id</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> url = <span class="hljs-string">`http://localhost:3001/notes/<span class="hljs-subst">$&#123;id&#125;</span>`</span>;<br>  <span class="hljs-keyword">const</span> note = notes.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> n.<span class="hljs-property">id</span> === id);<br>  <span class="hljs-keyword">const</span> changedNote = &#123; ...note, <span class="hljs-attr">important</span>: !note.<span class="hljs-property">important</span> &#125;;<br><br>  axios.<span class="hljs-title function_">put</span>(url, changedNote).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">setNotes</span>(notes.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">note</span>) =&gt;</span> (note.<span class="hljs-property">id</span> !== id ? note : response.<span class="hljs-property">data</span>)));<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><p>将其分离成一个单独的模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<br><span class="hljs-keyword">const</span> baseUrl = <span class="hljs-string">&#x27;http://localhost:3001/notes&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getAll</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> request = axios.<span class="hljs-title function_">get</span>(baseUrl);<br>  <span class="hljs-keyword">return</span> request.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response.<span class="hljs-property">data</span>);<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">create</span> = (<span class="hljs-params">newObject</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> request = axios.<span class="hljs-title function_">post</span>(baseUrl, newObject);<br>  <span class="hljs-keyword">return</span> request.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response.<span class="hljs-property">data</span>);<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">update</span> = (<span class="hljs-params">id, newObject</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> request = axios.<span class="hljs-title function_">put</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;baseUrl&#125;</span>/<span class="hljs-subst">$&#123;id&#125;</span>`</span>, newObject);<br>  <span class="hljs-keyword">return</span> request.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response.<span class="hljs-property">data</span>);<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; getAll, create, update &#125;;<br></code></pre></td></tr></table></figure><p>直接调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    noteService.<span class="hljs-title function_">getAll</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">initialNotes</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">setNotes</span>(initialNotes);<br>    &#125;);<br>  &#125;, []);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">toggleImportanceOf</span> = (<span class="hljs-params">id</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> note = notes.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> n.<span class="hljs-property">id</span> === id);<br>    <span class="hljs-keyword">const</span> changedNote = &#123; ...note, <span class="hljs-attr">important</span>: !note.<span class="hljs-property">important</span> &#125;;<br>    noteService.<span class="hljs-title function_">update</span>(id, changedNote).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">returnedNote</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">setNotes</span>(notes.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">note</span>) =&gt;</span> (note.<span class="hljs-property">id</span> !== id ? note : returnedNote)));<br>    &#125;);<br>  &#125;;<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">addNote</span> = (<span class="hljs-params">event</span>) =&gt; &#123;<br>    event.<span class="hljs-title function_">preventDefault</span>();<br>    <span class="hljs-keyword">const</span> noteObject = &#123;<br>      <span class="hljs-attr">content</span>: newNote,<br>      <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toISOString</span>(),<br>      <span class="hljs-attr">important</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &gt; <span class="hljs-number">0.5</span>,<br>    &#125;;<br>    noteService.<span class="hljs-title function_">create</span>(noteObject).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">returnedNote</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">setNotes</span>(notes.<span class="hljs-title function_">concat</span>(returnedNote));<br>      <span class="hljs-title function_">setNewNote</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>    &#125;);<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="给-react-应用加点样式">给 React 应用加点样式</h2><p>除了定义另外一个 css 文件并引入的方法外，还支持内联样式</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Footer</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> footerStyle = &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;green&#x27;</span>,<br>    <span class="hljs-attr">fontStyle</span>: <span class="hljs-string">&#x27;italic&#x27;</span>,<br>    <span class="hljs-attr">fontSize</span>: <span class="hljs-number">16</span>,<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;footerStyle&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span></span><br><span class="language-xml">        Note app, Department of Computer Science, University of Helsinki 2022</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="用-nodejs-和-express-写服务端程序">用 NodeJS 和 Express写服务端程序</h1><h2 id="node.js-与-express">Node.js 与 Express</h2><p>可以在 package.json 文件中写脚本，并 <code>npm run 脚本名</code>运行</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node index.js&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>这里使用 <a href="https://github.com/expressjs/express">express</a>库的接口：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><span class="hljs-keyword">let</span> notes = [...]<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123; response.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;&lt;h1&gt;Hello World!&lt;/h1&gt;&#x27;</span>) &#125;)<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/notes&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123; response.<span class="hljs-title function_">json</span>(notes) &#125;)<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PORT</span> = <span class="hljs-number">3001</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-variable constant_">PORT</span>, <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Server running on port <span class="hljs-subst">$&#123;PORT&#125;</span>`</span>) &#125;)<br></code></pre></td></tr></table></figure><p>使用 <a href="https://github.com/remy/nodemon">nodemon</a>可以在代码修改后自动重启服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save-dev nodemon<br></code></pre></td></tr></table></figure><p>REST API：</p><table><thead><tr class="header"><th style="text-align: left;">URL</th><th style="text-align: left;">动作</th><th style="text-align: left;">功能</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">notes/10</td><td style="text-align: left;">GET</td><td style="text-align: left;">获取一个资源</td></tr><tr class="even"><td style="text-align: left;">notes</td><td style="text-align: left;">GET</td><td style="text-align: left;">获取集合中所有的资源</td></tr><tr class="odd"><td style="text-align: left;">notes</td><td style="text-align: left;">POST</td><td style="text-align: left;">基于 request data 创建新的资源</td></tr><tr class="even"><td style="text-align: left;">notes/10</td><td style="text-align: left;">DELETE</td><td style="text-align: left;">移除该资源</td></tr><tr class="odd"><td style="text-align: left;">notes/10</td><td style="text-align: left;">PUT</td><td style="text-align: left;">用 request data 替代该资源</td></tr><tr class="even"><td style="text-align: left;">notes/10</td><td style="text-align: left;">PATCH</td><td style="text-align: left;">用 request data 替代该资源的一部分</td></tr></tbody></table><p>获取单独的资源：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/notes/:id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> id = <span class="hljs-title class_">Number</span>(request.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>);<br>  <span class="hljs-keyword">const</span> note = notes.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">note</span>) =&gt;</span> note.<span class="hljs-property">id</span> === id);<br>  response.<span class="hljs-title function_">json</span>(note);<br>&#125;);<br></code></pre></td></tr></table></figure><p>删除资源：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;/api/notes/:id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> id = <span class="hljs-title class_">Number</span>(request.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>);<br>  notes = notes.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">note</span>) =&gt;</span> note.<span class="hljs-property">id</span> !== id);<br>  response.<span class="hljs-title function_">status</span>(<span class="hljs-number">204</span>).<span class="hljs-title function_">end</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p>vscode 可以装 REST client 插件测试</p><p>接收数据要加入 json 解释器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">json</span>()); <span class="hljs-comment">// 加入 json 解释器</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">generateId</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> maxId = notes.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> ? <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...notes.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> n.<span class="hljs-property">id</span>)) : <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> maxId + <span class="hljs-number">1</span>;<br>&#125;;<br><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/notes&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> body = request.<span class="hljs-property">body</span>;<br>  <span class="hljs-keyword">if</span> (!body.<span class="hljs-property">content</span>)<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">status</span>(<span class="hljs-number">400</span>).<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">error</span>: <span class="hljs-string">&#x27;content missing&#x27;</span> &#125;);<br><br>  <span class="hljs-keyword">const</span> note = &#123;<br>    <span class="hljs-attr">content</span>: body.<span class="hljs-property">content</span>,<br>    <span class="hljs-attr">important</span>: body.<span class="hljs-property">important</span> || <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),<br>    <span class="hljs-attr">id</span>: <span class="hljs-title function_">generateId</span>(),<br>  &#125;;<br><br>  notes = notes.<span class="hljs-title function_">concat</span>(note);<br>  response.<span class="hljs-title function_">json</span>(note);<br>&#125;);<br></code></pre></td></tr></table></figure><p>注意 REST 测试时要指明数据类型：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">http://localhost:3001/api/notes/</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">content-type</span><span class="hljs-punctuation">: </span>application/json<br><br><span class="language-json"><span class="hljs-punctuation">&#123;</span></span><br><span class="language-json">    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sample&quot;</span><span class="hljs-punctuation">,</span></span><br><span class="language-json">    <span class="hljs-attr">&quot;time&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Wed, 21 Oct 2015 18:27:50 GMT&quot;</span></span><br><span class="language-json"><span class="hljs-punctuation">&#125;</span></span><br></code></pre></td></tr></table></figure><p>json-parser 是一个<strong>中间件</strong>，可以用来处理 request 和response 的函数</p><h2 id="把应用部署到网上">把应用部署到网上</h2><p>因为一些跨域请求默认是被禁止的，故可以使用 <ahref="https://github.com/expressjs/cors">cors</a>中间件来运行其他来源的请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cors&#x27;</span>);<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cors</span>());<br></code></pre></td></tr></table></figure><p>部署后端</p><p>部署前端：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;build:ui&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;rm -rf build &amp;&amp; cd ../part2-notes/ &amp;&amp; npm run build &amp;&amp; cp -r build ../notes-backend&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;deploy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;git push heroku main&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;deploy:full&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;npm run build:ui &amp;&amp; git add . &amp;&amp; git commit -m uibuild &amp;&amp; npm run deploy&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;logs:prod&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;heroku logs --tail&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>因为前端修改为了相对路径（前端和后端部署在了一起），故无法在本地调试前端，可以在本地添加一个代理：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;proxy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://localhost:3001&quot;</span><br></code></pre></td></tr></table></figure><h2 id="将数据存入-mongodb">将数据存入 MongoDB</h2><p>使用的数据库为 MongoDB，常用的服务提供商是 <ahref="https://www.mongodb.com/atlas/database">MongoDB Atlas</a></p><p>使用 <a href="https://github.com/Automattic/mongoose">mongoose</a>库，其提供了一个更高级别的 API</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongoose&#x27;</span>);<br><br><span class="hljs-keyword">const</span> password = process.<span class="hljs-property">argv</span>[<span class="hljs-number">2</span>];<br><br><span class="hljs-keyword">const</span> url = <span class="hljs-string">`mongodb+srv://fullstack:<span class="hljs-subst">$&#123;password&#125;</span>@cluster0.o1opl.mongodb.net/myFirstDatabase?retryWrites=true&amp;w=majority`</span>;<br><br>mongoose.<span class="hljs-title function_">connect</span>(url);<br><br><span class="hljs-comment">// 定义模式</span><br><span class="hljs-keyword">const</span> noteSchema = <span class="hljs-keyword">new</span> mongoose.<span class="hljs-title class_">Schema</span>(&#123;<br>  <span class="hljs-attr">content</span>: <span class="hljs-title class_">String</span>,<br>  <span class="hljs-attr">date</span>: <span class="hljs-title class_">Date</span>,<br>  <span class="hljs-attr">important</span>: <span class="hljs-title class_">Boolean</span>,<br>&#125;);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Note</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;Note&#x27;</span>, noteSchema); <span class="hljs-comment">// 创建模型</span><br><br><span class="hljs-comment">// 创建一个新的对象（使用构造函数）</span><br><span class="hljs-keyword">const</span> note = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Note</span>(&#123;<br>  <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;HTML is Easy&#x27;</span>,<br>  <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),<br>  <span class="hljs-attr">important</span>: <span class="hljs-literal">true</span>,<br>&#125;);<br><br><span class="hljs-comment">// 将对象保存到数据库</span><br>note.<span class="hljs-title function_">save</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;note saved!&#x27;</span>);<br>  mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">close</span>();<br>&#125;);<br><br><span class="hljs-comment">// 从数据库中获取对象</span><br><span class="hljs-title class_">Note</span>.<span class="hljs-title function_">find</span>(&#123;&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>  result.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">note</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(note);<br>  &#125;);<br>  mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">close</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p>可以修改模式的 <code>toJSON</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">noteSchema.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;toJSON&#x27;</span>, &#123;<br>  <span class="hljs-attr">transform</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-variable language_">document</span>, returnedObject</span>) =&gt;</span> &#123;<br>    returnedObject.<span class="hljs-property">id</span> = returnedObject.<span class="hljs-property">_id</span>.<span class="hljs-title function_">toString</span>();<br>    <span class="hljs-keyword">delete</span> returnedObject.<span class="hljs-property">_id</span>;<br>    <span class="hljs-keyword">delete</span> returnedObject.<span class="hljs-property">__v</span>;<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>一般使用环境变量，安装 <ahref="https://github.com/motdotla/dotenv">dotenv</a> 库</p><p>在 .env 文件中加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs env">MONGODB_URI=mongodb+srv://fullstack:&lt;password&gt;@cluster0.o1opl.mongodb.net/noteApp?retryWrites=true&amp;w=majority<br>PORT=3001<br></code></pre></td></tr></table></figure><p>该文件的信息的使用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;dotenv&#x27;</span>).<span class="hljs-title function_">config</span>();<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PORT</span> = process.<span class="hljs-property">env</span>.<span class="hljs-property">PORT</span>;<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-variable constant_">PORT</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Server running on port <span class="hljs-subst">$&#123;PORT&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>mongoose 有 <code>findById</code>方法，获取一个单独的笔记方法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/notes/:id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>  <span class="hljs-title class_">Note</span>.<span class="hljs-title function_">findById</span>(request.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">note</span>) =&gt;</span> &#123;<br>    response.<span class="hljs-title function_">json</span>(note);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>findByIdAndDelete</code> 和 <code>findByIdAndUpdate</code>等同理</p><p>最好在每个 <code>.then</code> 块之后使用 <code>.catch</code>捕捉异常：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)<br>  response.<span class="hljs-title function_">status</span>(<span class="hljs-number">400</span>).<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">error</span>: <span class="hljs-string">&#x27;malformatted id&#x27;</span> &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>可以进一步把错误处理程序封装到一个中间件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/notes/:id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-title class_">Note</span>.<span class="hljs-title function_">findById</span>(request.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>)<br>    .<span class="hljs-title function_">then</span>()<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-title function_">next</span>(error));<br>&#125;);<br></code></pre></td></tr></table></figure><p>我们的错误处理程序如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">errorHandler</span> = (<span class="hljs-params">error, request, response, next</span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error.<span class="hljs-property">message</span>);<br>  <span class="hljs-keyword">if</span> (error.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;CastError&#x27;</span>)<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">status</span>(<span class="hljs-number">400</span>).<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">error</span>: <span class="hljs-string">&#x27;malformatted id&#x27;</span> &#125;);<br>  <span class="hljs-title function_">next</span>(error);<br>&#125;;<br><br><span class="hljs-comment">// 这必须是最后一个载入的中间件。</span><br>app.<span class="hljs-title function_">use</span>(errorHandler);<br></code></pre></td></tr></table></figure><h2 id="eslint-与代码检查">ESLint 与代码检查</h2><p>可以使用 Mongoose 中的验证功能来检查输入格式是否正确：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> noteSchema = <span class="hljs-keyword">new</span> mongoose.<span class="hljs-title class_">Schema</span>(&#123;<br>  <span class="hljs-attr">content</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">minLength</span>: <span class="hljs-number">5</span>,<br>    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  <span class="hljs-attr">date</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Date</span>,<br>    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  <span class="hljs-attr">important</span>: <span class="hljs-title class_">Boolean</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>中间件可以添加一些信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">errorHandler</span> = (<span class="hljs-params">error, request, response, next</span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error.<span class="hljs-property">message</span>);<br>  <span class="hljs-keyword">if</span> (error.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;CastError&#x27;</span>)<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">status</span>(<span class="hljs-number">400</span>).<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">error</span>: <span class="hljs-string">&#x27;malformatted id&#x27;</span> &#125;);<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;ValidationError&#x27;</span>)<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">status</span>(<span class="hljs-number">400</span>).<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">error</span>: error.<span class="hljs-property">message</span> &#125;);<br>  <span class="hljs-title function_">next</span>(error);<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意 <code>findOneAndUpdate</code> 不会自动验证，可以显示指定：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Note</span>.<span class="hljs-title function_">findByIdAndUpdate</span>(request.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>, request.<span class="hljs-property">body</span>, &#123;<br>  <span class="hljs-attr">new</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">runValidators</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">context</span>: <span class="hljs-string">&#x27;query&#x27;</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p><a href="https://eslint.org/">ESlint</a> 是 JavaScript的静态分析工具</p><p>初始化一个默认的 ESlint 配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx eslint --init<br></code></pre></td></tr></table></figure><p>该配置保存在 <code>.eslintrc.js</code>文件中，<code>.eslintignore</code> 文件保存忽略的文件</p><p>创建单独的脚本进行 <code>linting</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;lint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;eslint .&quot;</span><br></code></pre></td></tr></table></figure><h1 id="测试-express-服务端程序-以及用户管理">测试 Express 服务端程序,以及用户管理</h1><h2 id="从后端结构到测试入门">从后端结构到测试入门</h2><p>项目的结构一般如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs file">├── index.js<br>├── app.js<br>├── build<br>│   └── ...<br>├── controllers<br>│   └── notes.js<br>├── models<br>│   └── note.js<br>├── package-lock.json<br>├── package.json<br>├── utils<br>│   ├── config.js<br>│   ├── logger.js<br>│   └── middleware.js<br></code></pre></td></tr></table></figure><p><code>utils/logger.js</code> 文件中存放打印模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">info</span> = (<span class="hljs-params">...params</span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(...params);<br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">error</span> = (<span class="hljs-params">...params</span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(...params);<br>&#125;;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123; info, error &#125;;<br></code></pre></td></tr></table></figure><p><code>utils/config.js</code> 文件中处理环境变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;dotenv&#x27;</span>).<span class="hljs-title function_">config</span>();<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PORT</span> = process.<span class="hljs-property">env</span>.<span class="hljs-property">PORT</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MONGODB_URI</span> = process.<span class="hljs-property">env</span>.<span class="hljs-property">MONGODB_URI</span>;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123; <span class="hljs-variable constant_">MONGODB_URI</span>, <span class="hljs-variable constant_">PORT</span> &#125;;<br></code></pre></td></tr></table></figure><p><code>utils/middleware.js</code> 模块中是自定义的中间件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> logger = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./logger&#x27;</span>)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">requestLogger</span> = (<span class="hljs-params">request, response, next</span>) =&gt; &#123;...&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">unknownEndpoint</span> = (<span class="hljs-params">request, response</span>) =&gt; &#123; response.<span class="hljs-title function_">status</span>(<span class="hljs-number">404</span>).<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">error</span>: <span class="hljs-string">&#x27;unknown endpoint&#x27;</span> &#125;) &#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">errorHandler</span> = (<span class="hljs-params">error, request, response, next</span>) =&gt; &#123;...&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123; requestLogger, unknownEndpoint, errorHandler &#125;<br></code></pre></td></tr></table></figure><p>与 <code>notes</code> 相关的路由现在都在<code>controllers/notes.js</code> 模块中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> notesRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>).<span class="hljs-title class_">Router</span>()<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Note</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../models/note&#x27;</span>)<br><br>notesRouter.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;...&#125;)<br>notesRouter.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/:id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response, next</span>) =&gt;</span> &#123;...&#125;)<br>notesRouter.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response, next</span>) =&gt;</span> &#123;...&#125;)<br>notesRouter.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;/:id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response, next</span>) =&gt;</span> &#123;...&#125;)<br>notesRouter.<span class="hljs-title function_">put</span>(<span class="hljs-string">&#x27;/:id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response, next</span>) =&gt;</span> &#123;...&#125;)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = notesRouter<br></code></pre></td></tr></table></figure><p>这些路由对象相当于是中间件，注意 <code>/api/notes/:id</code>被缩短为了 <code>/:id</code></p><p><code>models/note.js</code> 文件定义了 Mongoose 模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongoose&#x27;</span>)<br><br><span class="hljs-keyword">const</span> noteSchema = <span class="hljs-keyword">new</span> mongoose.<span class="hljs-title class_">Schema</span>(&#123;...&#125;)<br><br>noteSchema.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;toJSON&#x27;</span>, &#123;...&#125;)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;Note&#x27;</span>, noteSchema)<br></code></pre></td></tr></table></figure><p><code>index.js</code> 文件用于启动应用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./app&#x27;</span>); <span class="hljs-comment">// the actual Express application</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">const</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./utils/config&#x27;</span>);<br><span class="hljs-keyword">const</span> logger = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./utils/logger&#x27;</span>);<br><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(app);<br><br>server.<span class="hljs-title function_">listen</span>(config.<span class="hljs-property">PORT</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  logger.<span class="hljs-title function_">info</span>(<span class="hljs-string">`Server running on port <span class="hljs-subst">$&#123;config.PORT&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>app.js</code> 使用到了大量的中间件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./utils/config&#x27;</span>);<br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-keyword">const</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cors&#x27;</span>);<br><span class="hljs-keyword">const</span> notesRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./controllers/notes&#x27;</span>);<br><span class="hljs-keyword">const</span> middleware = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./utils/middleware&#x27;</span>);<br><span class="hljs-keyword">const</span> logger = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./utils/logger&#x27;</span>);<br><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongoose&#x27;</span>);<br><br>logger.<span class="hljs-title function_">info</span>(<span class="hljs-string">&#x27;connecting to&#x27;</span>, config.<span class="hljs-property">MONGODB_URI</span>);<br><br>mongoose.<span class="hljs-title function_">connect</span>(config.<span class="hljs-property">MONGODB_URI</span>);<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cors</span>());<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;build&#x27;</span>));<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">json</span>());<br>app.<span class="hljs-title function_">use</span>(middleware.<span class="hljs-property">requestLogger</span>);<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/api/notes&#x27;</span>, notesRouter);<br><br>app.<span class="hljs-title function_">use</span>(middleware.<span class="hljs-property">unknownEndpoint</span>);<br>app.<span class="hljs-title function_">use</span>(middleware.<span class="hljs-property">errorHandler</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = app;<br></code></pre></td></tr></table></figure><p><code>utils/for_testing.js</code> 存放自动化测试文件，如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">reverse</span> = (<span class="hljs-params">string</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> string.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">average</span> = (<span class="hljs-params">array</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">reducer</span> = (<span class="hljs-params">sum, item</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> sum + item;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> array.<span class="hljs-title function_">reduce</span>(reducer, <span class="hljs-number">0</span>) / array.<span class="hljs-property">length</span>;<br>&#125;;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123; reverse, average &#125;;<br></code></pre></td></tr></table></figure><p>这里使用 node 的内置测试库 <ahref="https://nodejs.org/docs/latest/api/test.html">node:test</a></p><p>定义 npm test：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node --test&quot;</span><br></code></pre></td></tr></table></figure><p>测试文件在 <code>test/reverse.test.js</code> 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; test &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;node:test&#x27;</span>);<br><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;node:assert&#x27;</span>);<br><br><span class="hljs-keyword">const</span> reverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../utils/for_testing&#x27;</span>).<span class="hljs-property">reverse</span>;<br><br><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;reverse of a&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">reverse</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>  assert.<span class="hljs-title function_">strictEqual</span>(result, <span class="hljs-string">&#x27;a&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="测试后端应用">测试后端应用</h2><p>使用 <a href="https://github.com/kentcdodds/cross-env">cross-env</a>包来实现跨平台兼容，并使用 <code>NODE_ENV</code>环境变量来定义应用的执行模式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cross-env NODE_ENV=production node index.js&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cross-env NODE_ENV=development nodemon index.js&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cross-env NODE_ENV=test jest --verbose --runInBand&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>为测试设置单独的数据库：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MONGODB_URI</span> =<br>  process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&#x27;test&#x27;</span><br>    ? process.<span class="hljs-property">env</span>.<span class="hljs-property">TEST_MONGODB_URI</span><br>    : process.<span class="hljs-property">env</span>.<span class="hljs-property">MONGODB_URI</span>;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">TEST_MONGODB_URI=mongodb+srv://fullstack:&lt;password&gt;@cluster0.o1opl.mongodb.net/testNoteApp?retryWrites=<span class="hljs-literal">true</span>&amp;w=majority<br></code></pre></td></tr></table></figure><p>使用 <a href="https://github.com/ladjs/supertest">supertest</a>包测试 API</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongoose&#x27;</span>);<br><span class="hljs-keyword">const</span> supertest = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;supertest&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../app&#x27;</span>);<br><br><span class="hljs-keyword">const</span> api = supertest(app);<br><br><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;notes are returned as json&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">await</span> api<br>    .<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/notes&#x27;</span>)<br>    .<span class="hljs-title function_">expect</span>(<span class="hljs-number">200</span>)<br>    .<span class="hljs-title function_">expect</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-regexp">/application\/json/</span>);<br>&#125;);<br><br><span class="hljs-comment">// 在所有测试完成后关闭连接</span><br><span class="hljs-title function_">afterAll</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">close</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>expect(response.body).toHaveLength(2)</code> 和<code>expect(response.body[0].content).toBe('HTML is easy')</code>等方便比较内容</p><p>类似的，还有 <code>beforeEach()</code> 函数在所有测试开始之前执行</p><p>可以使用 <ahref="https://github.com/davidbanham/express-async-errors">express-async-errors</a>来避免代码中大量出现的 <code>try...catch...</code> 块</p><h2 id="用户管理">用户管理</h2><p>Mongo 不是关系型数据库，故本身不支持 join 操作，只能自定义模式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> userSchema = <span class="hljs-keyword">new</span> mongoose.<span class="hljs-title class_">Schema</span>(&#123;<br>  <span class="hljs-attr">username</span>: <span class="hljs-title class_">String</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>,<br>  <span class="hljs-attr">passwordHash</span>: <span class="hljs-title class_">String</span>,<br>  <span class="hljs-attr">notes</span>: [<br>    &#123;<br>      <span class="hljs-attr">type</span>: mongoose.<span class="hljs-property">Schema</span>.<span class="hljs-property">Types</span>.<span class="hljs-property">ObjectId</span>,<br>      <span class="hljs-attr">ref</span>: <span class="hljs-string">&#x27;Note&#x27;</span>,<br>    &#125;,<br>  ],<br>&#125;);<br></code></pre></td></tr></table></figure><p>另一边类似的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> noteSchema = <span class="hljs-keyword">new</span> mongoose.<span class="hljs-title class_">Schema</span>(&#123;<br>  <span class="hljs-attr">content</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">minlength</span>: <span class="hljs-number">5</span>,<br>  &#125;,<br>  <span class="hljs-attr">date</span>: <span class="hljs-title class_">Date</span>,<br>  <span class="hljs-attr">important</span>: <span class="hljs-title class_">Boolean</span>,<br><br>  <span class="hljs-attr">user</span>: &#123;<br>    <span class="hljs-attr">type</span>: mongoose.<span class="hljs-property">Schema</span>.<span class="hljs-property">Types</span>.<span class="hljs-property">ObjectId</span>,<br>    <span class="hljs-attr">ref</span>: <span class="hljs-string">&#x27;User&#x27;</span>,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>安装 <a href="https://github.com/kelektiv/node.bcrypt.js">bcrypt</a>软件包来生成密码散列：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> saltRounds = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> passwordHash = <span class="hljs-keyword">await</span> bcrypt.<span class="hljs-title function_">hash</span>(password, saltRounds);<br></code></pre></td></tr></table></figure><p>使用 <ahref="https://github.com/mongoose-unique-validator/mongoose-unique-validator">mongoose-unique-validator</a>包来实现唯一性检查</p><p>Mongoose 库实现了集合之间的连接</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> <span class="hljs-title class_">User</span>.<span class="hljs-title function_">find</span>(&#123;&#125;).<span class="hljs-title function_">populate</span>(<span class="hljs-string">&#x27;notes&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="密钥认证">密钥认证</h2><p>在后台实现基于令牌的认证的支持</p><p>安装 <ahref="https://github.com/auth0/node-jsonwebtoken">jsonwebtoken</a>库</p><p>登录功能的代码放在 <code>controllers/login.js</code> 文件中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jsonwebtoken&#x27;</span>);<br><span class="hljs-keyword">const</span> bcrypt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;bcrypt&#x27;</span>);<br><span class="hljs-keyword">const</span> loginRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>).<span class="hljs-title class_">Router</span>();<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../models/user&#x27;</span>);<br><br>loginRouter.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">async</span> (request, response) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123; username, password &#125; = request.<span class="hljs-property">body</span>;<br><br>  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title class_">User</span>.<span class="hljs-title function_">findOne</span>(&#123; username &#125;);<br>  <span class="hljs-keyword">const</span> passwordCorrect =<br>    user === <span class="hljs-literal">null</span> ? <span class="hljs-literal">false</span> : <span class="hljs-keyword">await</span> bcrypt.<span class="hljs-title function_">compare</span>(password, user.<span class="hljs-property">passwordHash</span>);<br><br>  <span class="hljs-keyword">if</span> (!(user &amp;&amp; passwordCorrect))<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">status</span>(<span class="hljs-number">401</span>).<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">error</span>: <span class="hljs-string">&#x27;invalid username or password&#x27;</span> &#125;);<br><br>  <span class="hljs-keyword">const</span> userForToken = &#123; <span class="hljs-attr">username</span>: user.<span class="hljs-property">username</span>, <span class="hljs-attr">id</span>: user.<span class="hljs-property">_id</span> &#125;;<br><br>  <span class="hljs-keyword">const</span> token = jwt.<span class="hljs-title function_">sign</span>(<br>    userForToken,<br>    process.<span class="hljs-property">env</span>.<span class="hljs-property">SECRET</span>,<br>    &#123; <span class="hljs-attr">expiresIn</span>: <span class="hljs-number">60</span> * <span class="hljs-number">60</span> &#125; <span class="hljs-comment">// 一个小时过期</span><br>  );<br><br>  response<br>    .<span class="hljs-title function_">status</span>(<span class="hljs-number">200</span>)<br>    .<span class="hljs-title function_">send</span>(&#123; token, <span class="hljs-attr">username</span>: user.<span class="hljs-property">username</span>, <span class="hljs-attr">name</span>: user.<span class="hljs-property">name</span> &#125;);<br>&#125;);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = loginRouter;<br></code></pre></td></tr></table></figure><p>将令牌从浏览器发送到服务器要使用授权头，有几种认证方案，这里使用Bearer 方案，检验的方法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jsonwebtoken&#x27;</span>)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getTokenFrom</span> = request =&gt; &#123;<br>  <span class="hljs-keyword">const</span> authorization = request.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;authorization&#x27;</span>)<br>  <span class="hljs-keyword">if</span> (authorization &amp;&amp; authorization.<span class="hljs-title function_">toLowerCase</span>().<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;bearer &#x27;</span>)) &#123;<br>    <span class="hljs-keyword">return</span> authorization.<span class="hljs-title function_">substring</span>(<span class="hljs-number">7</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>&#125;<br><br>notesRouter.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">async</span> (request, response) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> body = request.<span class="hljs-property">body</span><br>  <span class="hljs-keyword">const</span> token = <span class="hljs-title function_">getTokenFrom</span>(request)<br>  <span class="hljs-keyword">const</span> decodedToken = jwt.<span class="hljs-title function_">verify</span>(token, process.<span class="hljs-property">env</span>.<span class="hljs-property">SECRET</span>)<br>  <span class="hljs-keyword">if</span> (!decodedToken.<span class="hljs-property">id</span>) &#123; <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">status</span>(<span class="hljs-number">401</span>).<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">error</span>: <span class="hljs-string">&#x27;token missing or invalid&#x27;</span> &#125;) &#125;<br>  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title class_">User</span>.<span class="hljs-title function_">findById</span>(decodedToken.<span class="hljs-property">id</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>发送要加上头：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Authorization</span><span class="hljs-punctuation">: </span>Bearer eyJhbGciOiJIUzI1NiIsInR5c2VybmFtZSI6Im1sdXVra2FpIiwiaW<br></code></pre></td></tr></table></figure><h1 id="测试-react-应用">测试 React 应用</h1><h2 id="完成前台的登录功能">完成前台的登录功能</h2><p>有条件地渲染登录窗口和笔记窗口：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  user === <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-title function_">loginForm</span>();<br>&#125;<br>&#123;<br>  user !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-title function_">noteForm</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>登录成功的用户信息储存在 token 中，故 noteService 模块中应添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> token = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">setToken</span> = (<span class="hljs-params">newToken</span>) =&gt; &#123;<br>  token = <span class="hljs-string">`bearer <span class="hljs-subst">$&#123;newToken&#125;</span>`</span>;<br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">create</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">newObject</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> config = &#123; <span class="hljs-attr">headers</span>: &#123; <span class="hljs-title class_">Authorization</span>: token &#125; &#125;;<br>  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">post</span>(baseUrl, newObject, config);<br>  <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>每次刷新后用户信息就消失了，可以通过将登录信息保存到本地存储中解决：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;loggedNoteappUser&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(user));<br></code></pre></td></tr></table></figure><p>使用<strong>效果钩子</strong>在进入页面时查找本地存储</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> loggedUserJSON = <span class="hljs-variable language_">window</span>.<span class="hljs-property">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;loggedNoteappUser&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (loggedUserJSON) &#123;<br>    <span class="hljs-keyword">const</span> user = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(loggedUserJSON);<br>    <span class="hljs-title function_">setUser</span>(user);<br>    noteService.<span class="hljs-title function_">setToken</span>(user.<span class="hljs-property">token</span>);<br>  &#125;<br>&#125;, []);<br></code></pre></td></tr></table></figure><h2 id="props.children-与-proptypes">props.children 与 proptypes</h2><p>一个可以展开和折叠的组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Togglable</span> = (<span class="hljs-params">props</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [visible, setVisible] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">const</span> hideWhenVisible = &#123; <span class="hljs-attr">display</span>: visible ? <span class="hljs-string">&#x27;none&#x27;</span> : <span class="hljs-string">&#x27;&#x27;</span> &#125;;<br>  <span class="hljs-keyword">const</span> showWhenVisible = &#123; <span class="hljs-attr">display</span>: visible ? <span class="hljs-string">&#x27;&#x27;</span> : <span class="hljs-string">&#x27;none&#x27;</span> &#125;;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">toggleVisibility</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setVisible</span>(!visible);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;hideWhenVisible&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;toggleVisibility&#125;</span>&gt;</span>&#123;props.buttonLabel&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;showWhenVisible&#125;</span>&gt;</span></span><br><span class="language-xml">        &#123;props.children&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;toggleVisibility&#125;</span>&gt;</span>cancel<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Togglable</span>;<br></code></pre></td></tr></table></figure><p>如果想要在 Togglable 组件之外访问 visible 变量，可以使用 React 的 ref机制：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useState, useEffect, useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">const</span> noteFormRef = <span class="hljs-title function_">useRef</span>();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">noteForm</span> = (<span class="hljs-params"></span>) =&gt; (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Togglable</span> <span class="hljs-attr">buttonLabel</span>=<span class="hljs-string">&#x27;new note&#x27;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;noteFormRef&#125;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">NoteForm</span> <span class="hljs-attr">createNote</span>=<span class="hljs-string">&#123;addNote&#125;</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">Togglable</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><p>Togglable 组件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useState, forwardRef, useImperativeHandle &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Togglable</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123; toggleVisibility &#125;;<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>通过 <code>noteFormRef.current.toggleVisibility()</code> 隐藏表单</p><p>可以使用 <ahref="https://github.com/facebook/prop-types">prop-types</a>包定义组件的预期和要求，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">PropTypes</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;prop-types&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Togglable</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> &#123;...&#125;)<br><span class="hljs-title class_">Togglable</span>.<span class="hljs-property">propTypes</span> = &#123; <span class="hljs-attr">buttonLabel</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>.<span class="hljs-property">isRequired</span> &#125;<br></code></pre></td></tr></table></figure><h2 id="测试-react-应用-1">测试 React 应用</h2><p>这里使用 <a href="https://vitest.dev/">Vitest</a>测试，安装一些有用的测试库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install --save-vitest vitest jsdom<br>npm install --save-dev @testing-library/react @testing-library/jest-dom<br></code></pre></td></tr></table></figure><p>配置测试脚本：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vitest run&quot;</span> <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>创建 <code>testSetup.js</code> 的文件，用于重置模拟浏览器的jsdom：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; afterEach &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vitest&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; cleanup &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@testing-library/react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;@testing-library/jest-dom/vitest&#x27;</span>;<br><br><span class="hljs-title function_">afterEach</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">cleanup</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p>将 <code>vite.config.js</code> 文件扩展如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">test</span>: &#123;<br>    <span class="hljs-attr">environment</span>: <span class="hljs-string">&#x27;jsdom&#x27;</span>,<br>    <span class="hljs-attr">globals</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">setupFiles</span>: <span class="hljs-string">&#x27;./testSetup.js&#x27;</span>,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>通过设置 <code>globals: true</code> ，我们无需在测试中导入关键字，如<code>describe</code>、<code>test</code> 和 <code>expect</code>。</p><p>测试是否渲染了笔记内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; render, screen &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@testing-library/react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Note</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Note&#x27;</span>;<br><br><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;renders content&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> note = &#123;<br>    <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;Component testing is done with react-testing-library&#x27;</span>,<br>    <span class="hljs-attr">important</span>: <span class="hljs-literal">true</span>,<br>  &#125;;<br><br>  <span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Note</span> <span class="hljs-attr">note</span>=<span class="hljs-string">&#123;note&#125;</span> /&gt;</span></span>);<br><br>  <span class="hljs-keyword">const</span> element = screen.<span class="hljs-title function_">getByText</span>(<br>    <span class="hljs-string">&#x27;Component testing is done with react-testing-library&#x27;</span><br>  );<br>  <span class="hljs-title function_">expect</span>(element).<span class="hljs-title function_">toBeDefined</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>screen.debug()</code> 命令可以将一个组件的 HTML 打印到终端</p><p>在处理事件时，使用 <ahref="https://testing-library.com/docs/user-event/intro">user-event</a>库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install --save-dev @testing-library/user-event<br></code></pre></td></tr></table></figure><p>事件处理程序是一个用 Jest 定义的 mock 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mockHandler = vi.<span class="hljs-title function_">fn</span>();<br></code></pre></td></tr></table></figure><p>一个 session 被启动以与渲染的组件进行交互。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> user = userEvent.<span class="hljs-title function_">setup</span>();<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">await</span> user.<span class="hljs-title function_">click</span>(button);<br><span class="hljs-keyword">const</span> button = screen.<span class="hljs-title function_">getByText</span>(<span class="hljs-string">&#x27;make not important&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="端到端测试">端到端测试</h2><p>前面讲的都是单元测试，实际上也可以进行整体测试</p><p>使用 <a href="https://playwright.dev/">Playwright</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;Note app&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;front page can be opened&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    cy.<span class="hljs-title function_">visit</span>(<span class="hljs-string">&#x27;http://localhost:3000&#x27;</span>);<br>    cy.<span class="hljs-title function_">contains</span>(<span class="hljs-string">&#x27;Notes&#x27;</span>);<br>    cy.<span class="hljs-title function_">contains</span>(<br>      <span class="hljs-string">&#x27;Note app, Department of Computer Science, University of Helsinki 2022&#x27;</span><br>    );<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>向窗体中输入信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;Note app&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;user can log in&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    cy.<span class="hljs-title function_">contains</span>(<span class="hljs-string">&#x27;login&#x27;</span>).<span class="hljs-title function_">click</span>();<br>    cy.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;#username&#x27;</span>).<span class="hljs-title function_">type</span>(<span class="hljs-string">&#x27;mluukkai&#x27;</span>);<br>    cy.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;#password&#x27;</span>).<span class="hljs-title function_">type</span>(<span class="hljs-string">&#x27;salainen&#x27;</span>);<br>    cy.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;#login-button&#x27;</span>).<span class="hljs-title function_">click</span>();<br>    cy.<span class="hljs-title function_">contains</span>(<span class="hljs-string">&#x27;Matti Luukkainen logged in&#x27;</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="利用-redux-进行状态管理">利用 Redux 进行状态管理</h1><h2 id="flux-架构与-redux">Flux 架构与 Redux</h2><p>在 <a href="https://redux.js.org/">Redux</a> 中，状态被完全从 React组件中分离出来，进入它自己的存储</p><p>存储器的状态通过动作改变，可以自定义一个动作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>动作对应用状态的影响通过 reducer 实现，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">counterReducer</span> = (<span class="hljs-params">state = <span class="hljs-number">0</span>, action</span>) =&gt; &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;INCREMENT&#x27;</span>:<br>      <span class="hljs-keyword">return</span> state + <span class="hljs-number">1</span>;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>reducer 作为创建存储的一个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(counterReducer);<br></code></pre></td></tr></table></figure><p>操作则使用 <code>dispatch()</code> 方法，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">store.<span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span> &#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(store.<span class="hljs-title function_">getState</span>()); <span class="hljs-comment">// 获取状态</span><br></code></pre></td></tr></table></figure><p>注意 reducer 必须是一个<strong>纯函数</strong></p><p>让应用能够访问存储的方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Provider</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)).<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">&#123;store&#125;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><p>现在使用 <code>useDispatch()</code> 分派动作，相应的，使用<code>useSelector</code> 获取数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useSelector, useDispatch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>();<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">toggleImportance</span> = (<span class="hljs-params">id</span>) =&gt; &#123;<br>    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">toggleImportanceOf</span>(id));<br>  &#125;;<br>  <span class="hljs-keyword">const</span> notes = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state);<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="再来点-reducers">再来点 reducers</h2><p>可以使用 <a href="https://redux-toolkit.js.org/">Redux Toolkit</a>组合两个 reducer：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">configureStore</span>(&#123;<br>  <span class="hljs-attr">reducer</span>: &#123;<br>    <span class="hljs-attr">notes</span>: noteReducer,<br>    <span class="hljs-attr">filter</span>: filterReducer,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>用 createSlice 函数创建 reducer 和相应的动作创建器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> noteSlice = <span class="hljs-title function_">createSlice</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;notes&#x27;</span>,<br>  initialState,<br>  <span class="hljs-attr">reducers</span>: &#123;<br>    <span class="hljs-title function_">createNote</span>(<span class="hljs-params">state, action</span>) &#123;<br>      <span class="hljs-keyword">const</span> content = action.<span class="hljs-property">payload</span>;<br>      state.<span class="hljs-title function_">push</span>(&#123;<br>        content,<br>        <span class="hljs-attr">important</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">id</span>: <span class="hljs-title function_">generateId</span>(),<br>      &#125;);<br>    &#125;,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>注意到 <code>state</code> 可变了</p><h2 id="在-redux-应用中与后端通信">在 Redux 应用中与后端通信</h2><p>使用 <a href="https://github.com/reduxjs/redux-thunk">Redux Thunk</a>库来实现动作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">initializeNotes</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (dispatch) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> notes = <span class="hljs-keyword">await</span> noteService.<span class="hljs-title function_">getAll</span>();<br>    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">setNotes</span>(notes));<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="react-queryusereducer-和-context">React Query，useReducer 和context</h2><p>用 <a href="https://tanstack.com/query/latest/docs/react/">ReactQuery</a> 存储并管理从服务器检索的数据</p><p>将这个库中的函数传递给整个应用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">QueryClient</span>, <span class="hljs-title class_">QueryClientProvider</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-query&#x27;</span>;<br><span class="hljs-keyword">const</span> queryClient = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryClient</span>();<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)).<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">QueryClientProvider</span> <span class="hljs-attr">client</span>=<span class="hljs-string">&#123;queryClient&#125;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">QueryClientProvider</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><p>获取方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">useQuery</span>(<span class="hljs-string">&#x27;notes&#x27;</span>, <span class="hljs-function">() =&gt;</span><br>  axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://localhost:3001/notes&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-property">data</span>)<br>);<br></code></pre></td></tr></table></figure><p>使用 mutation 创建新笔记并在本地插入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> newNoteMutation = <span class="hljs-title function_">useMutation</span>(createNote, &#123;<br>    <span class="hljs-attr">onSuccess</span>: <span class="hljs-function">(<span class="hljs-params">newNote</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> notes = queryClient.<span class="hljs-title function_">getQueryData</span>(<span class="hljs-string">&#x27;notes&#x27;</span>);<br>      queryClient.<span class="hljs-title function_">setQueryData</span>(<span class="hljs-string">&#x27;notes&#x27;</span>, notes.<span class="hljs-title function_">concat</span>(newNote));<br>    &#125;,<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>useReducer</code> 提供了为应用创建状态的机制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [counter, counterDispatch] = <span class="hljs-title function_">useReducer</span>(counterReducer, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>使用 <code>createContext()</code> 创建context，这样就不需要层层传递给各组件了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;<span class="hljs-title class_">CounterContext</span>.<span class="hljs-property">Provider</span> value=&#123;[counter, counterDispatch]&#125;&gt;<br>  ...<br>&lt;/<span class="hljs-title class_">CounterContext</span>.<span class="hljs-property">Provider</span>&gt;<br></code></pre></td></tr></table></figure><p>其他组件可以使用 <code>useContext</code> 访问</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;web-app-基础&quot;&gt;Web app
        
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://old-driver-zero.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="web" scheme="https://old-driver-zero.github.io/tags/web/"/>
    
      <category term="赫尔辛基大学" scheme="https://old-driver-zero.github.io/tags/%E8%B5%AB%E5%B0%94%E8%BE%9B%E5%9F%BA%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
</feed>