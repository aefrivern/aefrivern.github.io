<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Qt 学习笔记 | Aefrivern的小屋</title><meta name="author" content="Aefrivern"><meta name="copyright" content="Aefrivern"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="下载和安装  官网 国内镜像网站  中国科学技术大学：http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;qtproject&#x2F; 清华大学：https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;qt&#x2F; 北京理工大学：http:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;qtproject&#x2F; 中国互联网络信息中心：https:&#x2F;&#x2F;mirrors.cnnic.cn&#x2F;qt&#x2F;    安装时">
<meta property="og:type" content="article">
<meta property="og:title" content="Qt 学习笔记">
<meta property="og:url" content="https://aefrivern.github.io/posts/d7fdf01f.html">
<meta property="og:site_name" content="Aefrivern的小屋">
<meta property="og:description" content="下载和安装  官网 国内镜像网站  中国科学技术大学：http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;qtproject&#x2F; 清华大学：https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;qt&#x2F; 北京理工大学：http:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;qtproject&#x2F; 中国互联网络信息中心：https:&#x2F;&#x2F;mirrors.cnnic.cn&#x2F;qt&#x2F;    安装时">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://aefrivern.github.io/gallery/cover/Qt%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.webp">
<meta property="article:published_time" content="2023-04-12T05:04:08.000Z">
<meta property="article:modified_time" content="2024-11-23T06:02:04.000Z">
<meta property="article:author" content="Aefrivern">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="Qt">
<meta property="article:tag" content="GUI">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://aefrivern.github.io/gallery/cover/Qt%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Qt 学习笔记",
  "url": "https://aefrivern.github.io/posts/d7fdf01f.html",
  "image": "https://aefrivern.github.io/gallery/cover/Qt%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.webp",
  "datePublished": "2023-04-12T05:04:08.000Z",
  "dateModified": "2024-11-23T06:02:04.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Aefrivern",
      "url": "https://aefrivern.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/illustration/favicon.ico"><link rel="canonical" href="https://aefrivern.github.io/posts/d7fdf01f.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"GY5EJYJ1FS","apiKey":"c443c952672ec7062840aac45536181e","indexName":"blog","hitsPerPage":6,"languages":{"input_placeholder":"搜索文章","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Qt 学习笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4031045_1yiosqv4vch.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/highlight.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/hexo-butterfly-article-double-row.css"><script src="/js/echarts.min.js"></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image: url(/gallery/wallpaper/wallpaper.webp);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/%E5%A4%B4%E5%83%8F_%E7%81%B0%E5%A4%AA%E7%8B%BC.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">191</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">245</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye-01"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-a-16-01-01"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-wenjianjia"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/anime/"><i class="fa-fw iconfont icon-zhifeiji"></i><span> 二次元</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw iconfont icon-xiangce"></i><span> 画廊</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyu"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/charts/"><i class="fa-fw iconfont icon-tongjichaxun"></i><span> 统计</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw iconfont icon-liuyan"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/random/"><i class="fa-fw iconfont icon-suiji"></i><span> 随便逛逛</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/gallery/cover/Qt 学习笔记.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Aefrivern的小屋</span></a><a class="nav-page-title" href="/"><span class="site-name">Qt 学习笔记</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-sousuo1"></use></svg><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye-01"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-a-16-01-01"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-wenjianjia"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/anime/"><i class="fa-fw iconfont icon-zhifeiji"></i><span> 二次元</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw iconfont icon-xiangce"></i><span> 画廊</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyu"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/charts/"><i class="fa-fw iconfont icon-tongjichaxun"></i><span> 统计</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw iconfont icon-liuyan"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/random/"><i class="fa-fw iconfont icon-suiji"></i><span> 随便逛逛</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Qt 学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-12T05:04:08.000Z" title="发表于 2023-04-12 13:04:08">2023-04-12</time><span class="post-meta-separator">|</span><svg class="meta_icon post-ui-icon" style="width:13px;height:13px;position:relative;top:2px"><use xlink:href="#icon-gengxin"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-23T06:02:04.000Z" title="更新于 2024-11-23 14:02:04">2024-11-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><a class="faa-parent animated-hover"></a><svg class="meta_icon post-ui-icon" style="width:13px;height:13px;position:relative;top:2px"><use xlink:href="#icon-fenlei"></use></svg><a class="post-meta-categories" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-word"></use></svg><span class="post-meta-label">总字数:</span><span class="word-count">1618</span><span class="post-meta-separator">|</span><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>6分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="下载和安装">下载和安装</h2>
<ul>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://download.qt.io/archive/qt/">官网</a></li>
<li>国内镜像网站
<ul>
<li>中国科学技术大学：<a target="_blank" rel="noopener external nofollow noreferrer" href="http://mirrors.ustc.edu.cn/qtproject/">http://mirrors.ustc.edu.cn/qtproject/</a></li>
<li>清华大学：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://mirrors.tuna.tsinghua.edu.cn/qt/">https://mirrors.tuna.tsinghua.edu.cn/qt/</a></li>
<li>北京理工大学：<a target="_blank" rel="noopener external nofollow noreferrer" href="http://mirror.bit.edu.cn/qtproject/">http://mirror.bit.edu.cn/qtproject/</a></li>
<li>中国互联网络信息中心：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://mirrors.cnnic.cn/qt/">https://mirrors.cnnic.cn/qt/</a></li>
</ul>
</li>
</ul>
<p>安装时如果操作系统为 Windows，则应该安装 MinGW 版本</p>
<h2 id="Qt-Creator">Qt Creator</h2>
<ul>
<li><code>QWidget</code> 类：不带菜单栏的</li>
<li><code>QMainWindow</code> 类：带菜单栏的</li>
</ul>
<p>界面：代码实现和图形界面分开</p>
<p>代码区有头文件和相应的实现（都在类中）</p>
<p>图形界面有插件和相应的属性设置</p>
<p>有不知道的命令可以在左侧<code>帮助</code>中查</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">#<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;widget.h&quot;</span></span><br><br>#<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QApplication&gt;</span> <span class="hljs-comment">// 包含一个应用程序类的文件</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>; <span class="hljs-comment">// 应用程序对象，有且仅有一个</span><br>    Widget w;<br>    w.<span class="hljs-built_in">show</span>(); <span class="hljs-comment">// 窗口对象默认不会显示，需要手动调用</span><br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">exec</span>();  <span class="hljs-comment">// 让代码阻塞到这行</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="信号与槽">信号与槽</h2>
<h3 id="插入信号和槽的方法">插入信号和槽的方法</h3>
<p>最直接的：右键对象，<code>转到槽</code>，只需直接在所给的函数中写代码</p>
<p>向 <code>private slots</code> 中添加函数声明，并连接信号与槽：</p>
<p>谁发出信号，发出什么信号，谁处理信号，怎么处理信号</p>
<p>例如：<code>connnect(ui-&gt;cmdLineEdit, SIGNAL(returnPressed()), this, SLOT(on_commitButton_clicked()));</code></p>
<p>也可以：<code>connect(ui-&gt;cancelButton, &amp;QPushButton::clicked, this, &amp;Widget::on_cancelButton_clicked);</code></p>
<p>后面部分可以写成 lambda 表达式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">connect</span>(ui-&gt;browseButton, &amp;QPushButton::clicked, [<span class="hljs-keyword">this</span>]()&#123;<br>    QMessageBox::<span class="hljs-built_in">information</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;信息&quot;</span>, <span class="hljs-string">&quot;点击浏览&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h3 id="自定义信号">自定义信号</h3>
<p>头文件里写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">signals:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendToWidget</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>
<p>发出信号：<code>emit sendToWidget()</code></p>
<p>信号可以包含参数，槽也可以包含参数，且允许传递无用的信号</p>
<ul>
<li>一个信号可以连接多个槽，但这些槽执行顺序不确定</li>
<li>一个槽可以与多个信号相连，只要接收到其中一个信号，就会执行该槽</li>
</ul>
<h2 id="实现计算器">实现计算器</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setWindowTitle</span>(<span class="hljs-string">&quot;计算器&quot;</span>);<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setFixedSize</span>(<span class="hljs-number">200</span>, <span class="hljs-number">280</span>); <span class="hljs-comment">// 固定窗口大小</span><br><br><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setWindowTitle</span>(<span class="hljs-string">&quot;计算器&quot;</span>); <span class="hljs-comment">// 设置窗口标题</span><br><br><span class="hljs-function">QFont <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-string">&quot;仿宋&quot;</span>, <span class="hljs-number">14</span>)</span></span>;<br>ui-&gt;mainLineEdit-&gt;<span class="hljs-built_in">setFont</span>(f); <span class="hljs-comment">// 设置字体</span><br><br><span class="hljs-function">QIcon <span class="hljs-title">icon</span><span class="hljs-params">(<span class="hljs-string">&quot;E:\\code\\Qt\\calculator\\tt.jpg&quot;</span>)</span></span>;<br>ui-&gt;deleteButton-&gt;<span class="hljs-built_in">setIcon</span>(icon); <span class="hljs-comment">// 设置图标</span><br><br>ui-&gt;equalButton-&gt;<span class="hljs-built_in">setStyleSheet</span>(<span class="hljs-string">&quot;background:blue&quot;</span>); <span class="hljs-comment">// 设置按钮背景色</span><br></code></pre></td></tr></table></figure>
<h2 id="计时器">计时器</h2>
<h3 id="QObject">QObject</h3>
<p>使用放在基类 <code>QObject</code> 中的计时器</p>
<p>定义函数：<code>virtual void timerEvent(QTimerEvent *event)</code></p>
<p>开始计时：<code>myTimerId = this-&gt;startTimer(TIMEOUT)</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Widget::timerEvent</span><span class="hljs-params">(QTimerEvent *event)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (event-&gt;<span class="hljs-built_in">timerId</span>() != myTimerId) <span class="hljs-comment">// 判断该事件是否是由自己刚才设定的那个计时器触发的</span><br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-function">QString <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-string">&quot;E:\\Pictures\\正经的\\琉璃神社壁纸包 2022年6月号\\&quot;</span>)</span></span>;<br>    path += QString::<span class="hljs-built_in">number</span>(picId) + <span class="hljs-string">&quot;.jpg&quot;</span>;<br><br>    <span class="hljs-function">QImage <span class="hljs-title">img</span><span class="hljs-params">(path)</span></span>;<br>    ui-&gt;label-&gt;<span class="hljs-built_in">setPixmap</span>(QPixmap::<span class="hljs-built_in">fromImage</span>(img)); <span class="hljs-comment">// 使用 QImage 保存图片，QPixmap 显示图片</span><br><br>    picId++;<br>    <span class="hljs-keyword">if</span> (picId &gt; <span class="hljs-number">42</span>)<br>        picId = <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="QTimer">QTimer</h3>
<p>定义：<code>QTimer* timer</code></p>
<p>连接信号与槽：<code>connect(timer, &amp;QTimer::timeout, this, &amp;Widget::timeoutSlot)</code></p>
<p>时间到了执行一次：<code>QTimer::singleShot(TIMEOUT, this, SLOT(timeoutSlot()));</code></p>
<h2 id="文件操作">文件操作</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">MainWindow::<span class="hljs-built_in">MainWindow</span>(QWidget *parent)<br>    : <span class="hljs-built_in">QMainWindow</span>(parent)<br>    , <span class="hljs-built_in">ui</span>(<span class="hljs-keyword">new</span> Ui::MainWindow)<br>&#123;<br>    ui-&gt;<span class="hljs-built_in">setupUi</span>(<span class="hljs-keyword">this</span>);<br><br>    <span class="hljs-built_in">connect</span>(ui-&gt;newAction, &amp;QAction::triggered, <span class="hljs-keyword">this</span>, &amp;MainWindow::newActionSlot); <span class="hljs-comment">// 将菜单栏选项和事件连接起来</span><br>    <span class="hljs-built_in">connect</span>(ui-&gt;openAction, &amp;QAction::triggered, <span class="hljs-keyword">this</span>, &amp;MainWindow::openActionSlot);<br>    <span class="hljs-built_in">connect</span>(ui-&gt;saveAction, &amp;QAction::triggered, <span class="hljs-keyword">this</span>, &amp;MainWindow::saveActionSlot);<br>&#125;<br><br>MainWindow::~<span class="hljs-built_in">MainWindow</span>()<br>&#123;<br>    <span class="hljs-keyword">delete</span> ui;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWindow::newActionSlot</span><span class="hljs-params">()</span> </span>&#123;<br>    ui-&gt;textEdit-&gt;<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setWindowTitle</span>(<span class="hljs-string">&quot;新建文本文档.txt&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWindow::openActionSlot</span><span class="hljs-params">()</span> </span>&#123;<br>    QString fileName = QFileDialog::<span class="hljs-built_in">getOpenFileName</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;选择一个文件&quot;</span>, QCoreApplication::<span class="hljs-built_in">applicationFilePath</span>(), <span class="hljs-string">&quot;*.cpp&quot;</span>); <span class="hljs-comment">// 弹出选择路径的窗口</span><br>    <span class="hljs-keyword">if</span> (fileName.<span class="hljs-built_in">isEmpty</span>())<br>        QMessageBox::<span class="hljs-built_in">warning</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;警告&quot;</span>, <span class="hljs-string">&quot;请选择一个文件&quot;</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        QFile <span class="hljs-built_in">file</span>(fileName); <span class="hljs-comment">// 创建文件对象</span><br>        file.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly); <span class="hljs-comment">// 以只读方式打开文件</span><br>        ui-&gt;textEdit-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-built_in">QString</span>(file.<span class="hljs-built_in">readAll</span>())); <span class="hljs-comment">// 将读取的内容转为字符串</span><br>        file.<span class="hljs-built_in">close</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWindow::saveActionSlot</span><span class="hljs-params">()</span> </span>&#123;<br>    QString fileName = QFileDialog::<span class="hljs-built_in">getSaveFileName</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;请选择一个文件&quot;</span>,  CoreApplication::<span class="hljs-built_in">applicationFilePath</span>()); <span class="hljs-comment">// 当前路径</span><br>    <span class="hljs-keyword">if</span> (fileName.<span class="hljs-built_in">isEmpty</span>())<br>        QMessageBox::<span class="hljs-built_in">warning</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;警告&quot;</span>, <span class="hljs-string">&quot;请选择一个文件&quot;</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        QFile <span class="hljs-built_in">file</span>(fileName);<br>        file.<span class="hljs-built_in">open</span>(QIODevice::WriteOnly);<br>        file.<span class="hljs-built_in">write</span>(ui-&gt;textEdit-&gt;<span class="hljs-built_in">toPlainText</span>().<span class="hljs-built_in">toLocal8Bit</span>()); <span class="hljs-comment">// 将保存内容转为字符串</span><br>        file.<span class="hljs-built_in">close</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="文件的打开与文件信息的获取">文件的打开与文件信息的获取</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;<br><br>    <span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;in.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly | QIODevice::Text)) &#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;Open file failed.&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">while</span> (!file.<span class="hljs-built_in">atEnd</span>()) &#123;<br>            <span class="hljs-built_in">qDebug</span>() &lt;&lt; file.<span class="hljs-built_in">readLine</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">QFileInfo <span class="hljs-title">info</span><span class="hljs-params">(file)</span></span>;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; info.<span class="hljs-built_in">isDir</span>();<br><br>    <span class="hljs-keyword">return</span> app.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>QFileInfo</code> 的一些函数：</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>用处</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>isDir()</code></td>
<td>检查该文件是否是目录</td>
</tr>
<tr>
<td><code>isExecutable()</code></td>
<td>检查该文件是否是可执行文件</td>
</tr>
<tr>
<td><code>baseName()</code></td>
<td>获取文件名（</td>
</tr>
<tr>
<td><code>completeBaseName()</code></td>
<td>获取完整的文件名</td>
</tr>
<tr>
<td><code>suffix()</code></td>
<td>获取文件后缀名</td>
</tr>
<tr>
<td><code>completeSuffix()</code></td>
<td>获取完整的文件后缀</td>
</tr>
</tbody>
</table>
<h3 id="二进制文件读写">二进制文件读写</h3>
<p>使用 <code>QDataStream</code> 类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 写</span><br><span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;file.dat&quot;</span>)</span></span>;<br>file.<span class="hljs-built_in">open</span>(QIODevice::WriteOnly);<br><span class="hljs-function">QDataStream <span class="hljs-title">out</span><span class="hljs-params">(&amp;file)</span></span>;<br>out &lt;&lt; <span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;the answer is&quot;</span>);<br>out &lt;&lt; (qint32)<span class="hljs-number">42</span>;<br>file.<span class="hljs-built_in">close</span>(); <span class="hljs-comment">// 为性能起见，数据只有在文件关闭时才会真正写入</span><br><br><span class="hljs-comment">// 读</span><br><span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;file.dat&quot;</span>)</span></span>;<br>file.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly);<br><span class="hljs-function">QDataStream <span class="hljs-title">in</span><span class="hljs-params">(&amp;file)</span></span>;<br>QString str;<br>qint32 a;<br>in &gt;&gt; str &gt;&gt; a;<br></code></pre></td></tr></table></figure>
<h3 id="文本文件读写">文本文件读写</h3>
<p>使用 <code>QTextStream</code> 类</p>
<p>读写方法类似</p>
<h2 id="鼠标和键盘事件">鼠标和键盘事件</h2>
<p>所需头文件：</p>
<ul>
<li><code>#include &lt;QKeyEvent&gt;</code></li>
<li><code>#include &lt;QMouseEvent&gt;</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWindow::keyPressEvent</span><span class="hljs-params">(QKeyEvent *k)</span> </span>&#123; <span class="hljs-comment">// 键盘事件</span><br>    <span class="hljs-keyword">if</span> (k-&gt;<span class="hljs-built_in">modifiers</span>() == Qt::ControlModifier &amp;&amp; k-&gt;<span class="hljs-built_in">key</span>() == Qt::Key_S) <span class="hljs-comment">// Qt:: 里面有一些预定义的宏</span><br>        <span class="hljs-built_in">saveActionSlot</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWindow::mousePressEvent</span><span class="hljs-params">(QMouseEvent *m)</span> </span>&#123; <span class="hljs-comment">// 鼠标事件</span><br>    QPoint pt = m-&gt;<span class="hljs-built_in">pos</span>(); <span class="hljs-comment">// 鼠标指针对象</span><br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; pt;<br>    <span class="hljs-keyword">if</span> (m-&gt;<span class="hljs-built_in">button</span>() == Qt::LeftButton) &#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;左键被按下&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m-&gt;<span class="hljs-built_in">button</span>() == Qt::RightButton) &#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;右键被按下&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="启动新窗口">启动新窗口</h2>
<p>类似于 <code>main.cpp</code> 中所写的</p>
<p>因为 <code>show</code> 并不会阻塞函数，所以这个函数会继续执行，所以必须在<strong>堆空间</strong>而不是栈空间创建对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Chat 为新增的 Widget 类</span><br>Chat *c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Chat</span>(socket);<br><span class="hljs-comment">// 不能写成 Chat c(socket);</span><br>c-&gt;<span class="hljs-built_in">show</span>();<br></code></pre></td></tr></table></figure>
<h2 id="多线程">多线程</h2>
<p>新建一个继承自 <code>QThread</code> 的类 <code>myThread</code>，该类中须实现线程处理函数 <code>run()</code></p>
<p>调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">myThread *t = <span class="hljs-keyword">new</span> myThread; <span class="hljs-comment">// 创建线程对象</span><br>t-&gt;<span class="hljs-built_in">start</span>(); <span class="hljs-comment">// 启动线程</span><br></code></pre></td></tr></table></figure>
<h2 id="绘图">绘图</h2>
<p>坐标原点在左上角，向右为 x 轴正方向，向下为 y 轴正方向</p>
<p>需要 <code>&lt;QPainter&gt;</code> 头文件</p>
<p>事件为：<code>void paintEvent(QPaintEvent *)</code></p>
<p>调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PaintedWidget::paintEvent</span><span class="hljs-params">(QPaintEvent *)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>; <span class="hljs-comment">// 在当前绘图设备（PaintedWidget）上绘图</span><br>    painter.<span class="hljs-built_in">drawLine</span>(<span class="hljs-number">80</span>, <span class="hljs-number">100</span>, <span class="hljs-number">650</span>, <span class="hljs-number">500</span>); <span class="hljs-comment">// 画线</span><br>    painter.<span class="hljs-built_in">setPen</span>(Qt::red); <span class="hljs-comment">// 调整笔的颜色</span><br>    painter.<span class="hljs-built_in">drawRect</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">400</span>); <span class="hljs-comment">// 画左上角坐标为(10, 10)，水平、竖直边长分别为 100, 400</span><br>    painter.<span class="hljs-built_in">setPen</span>(<span class="hljs-built_in">QPen</span>(Qt::green, <span class="hljs-number">5</span>)); <span class="hljs-comment">// 宽度为5</span><br>    painter.<span class="hljs-built_in">setBrush</span>(Qt::blue);<br>    painter.<span class="hljs-built_in">drawEllipse</span>(<span class="hljs-number">50</span>, <span class="hljs-number">150</span>, <span class="hljs-number">400</span>, <span class="hljs-number">200</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>若想要再次手动调用该事件，使用 `update()</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/Qt/">Qt</a><a class="post-meta__tags" href="/tags/GUI/">GUI</a></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/3c3cdb74.html" title="Git 学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Git 学习笔记</div></div><div class="info-2"><div class="info-item-1">简介 Git 是一种 分布式版本控制系统，和 集中式版本控制系统 相对，其特点是每个用户在本地都有一份完整的版本库。 Git 的优点：  直接记录快照，而非差异比较。如果文件没有更改，Git 不会重新存储该文件，而是建立一个链接，故能节省空间。建议某转发文件存多份的互联网大厂好好学一下 近乎所有操作都是本地执行。不需要连接服务器，速度快，且可以在无网络的环境下工作 保证完整性。所有数据在储存前都会计算检验和 一般只添加数据。能够保证 Git 可以成功恢复之前的版本  文件的三种状态：  已提交 committed 已修改 modified 已暂存 staged  Git 的三个区域：  工作区 暂存区 Git 目录   基本的 Git 工作流程如下：  在工作区中修改文件 将你想要下次提交的更改选择性地暂存。将更改的部分添加到暂存区 提交更新。将暂存区的文件的快照永久性存储到 Git 目录  配置 查看所有的配置： git config --global --list 设置用户名和邮件地址： git config --global user.name...</div></div></div></a><a class="pagination-related" href="/posts/88200036.html" title="LaTeX 学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/LaTeX%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">LaTeX 学习笔记</div></div><div class="info-2"><div class="info-item-1">前言 LaTeX 的优点  排版美观，结构清晰，尤其适合数学公式排版 具有庞大、活跃的用户群体 它灵活，强大——各种文档都有对应宏包 论文，幻灯，表格… 改变你编辑文档的思路 非图形界面；文档按模块统一处理…  编辑文字思路：  使用命令描述生成方式，而非最终效果。 按功能区分内容。 整体考虑排版。  环境配置 Overleaf Overleaf 提供 LaTeX 在线编译 TeX Live TeX Live 是 LaTeX 的发行版，以下是下载地址：  官网：TeX Live - TeX Users Group (tug.org) 国外镜像：HK 镜像 国内镜像：清华镜像列表，以及中科大镜像列表  VScode 中配置 LaTeX 安装扩展 LaTeX Workshop 添加代码 &quot;latex-workshop.latex.tools&quot;: [    &#123;        &quot;name&quot;: &quot;pdflatex&quot;,        &quot;command&quot;: &quot;pdflatex&quot;,  ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="iconfont icon-tuijian"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/f8060ffb.html" title="C++ 入门（上）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/C++%20%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%8A%EF%BC%89.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-05</div><div class="info-item-2">C++ 入门（上）</div></div><div class="info-2"><div class="info-item-1">基于 C++ Primer Fifth 编写 不愧是 C++，这才只是入门，只到 C++ 11 开始 Getting Started 万恶之源： ##include &lt;iostream&gt;int main() &#123;    std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl;    return 0;&#125; 文件的后缀名有很多，最常见的应该是 .cc 和 .cpp 编译器也有很多，如使用 g++ 编译： g++ -o prog1 prog1.cc  添加支持 c++ 11 标准：-std=c++11 -Wall 生成更多警告信息  输入输出：  这里使用了 iostream 库中的标准输入流和标准输出流，该库中还有标准错误流 cerr 和 clog &lt;&lt; 是输出操作符，&gt;&gt; 是输入操作符 endl 是一种 控制符 manipulator，有结束当前行和刷新缓冲区的作用  std:: 表示使用 命名空间 namespace...</div></div></div></a><a class="pagination-related" href="/posts/47e8553d.html" title="C++ Concurrency In Action"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/C++%20Concurrency%20In%20Action.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-03</div><div class="info-item-2">C++ Concurrency In Action</div></div><div class="info-2"><div class="info-item-1">基于 C++ Concurrency In Action Second Edition 编写 C++ 并发世界 并发 concurrency 是指两件或更多分开的活动在同时发生 单核 CPU 通过 context switch 来形成多个任务在同时执行的假象 多核 CPU 原理也类似 并发的方法：  多进程 多线程  并发和并行 parallelism 概念类似，但是  并行通常更考虑效率 并发则关心关注点分离  故使用并发的情况：  关注点分离 任务和数据的并行  C++ 中原来没有关于并发的标准，和 C 语言一样使用操作系统提供的 API。从 C++11 开始，封装了较一般的 thread 等 从并发版的 hello world 开始： ##include &lt;iostream&gt;##include &lt;thread&gt;void hello() &#123;    std::cout &lt;&lt; &quot;Hello, World&quot; &lt;&lt; std::endl;&#125;int main() &#123;   ...</div></div></div></a><a class="pagination-related" href="/posts/51f33067.html" title="C++20"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/C++20.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-01</div><div class="info-item-2">C++20</div></div><div class="info-2"><div class="info-item-1">C++20 带来了不亚于 C++11 的重大改变，其中最重要的就是概念、协程、range、模块 Concepts concepts 有多种使用方法： // 使用 requirestemplate&lt;typename T&gt;requires std::integral&lt;T&gt;void f(T t) &#123;&#125;// 直接在模板参数列表中使用template&lt;std::integral T&gt;void f(T t) &#123;&#125;// 在 auto 中使用auto f(std::integral auto t) &#123;&#125; 除了限定参数，也可以限定返回值，类模板，泛型成员函数 支持重载、特化模板 多个 concept 用 &amp;&amp; 连接 有许多预先定义好的 concept，详见 cppreference 定义 concept 的语法： template&lt;typename T&gt;concept MyConcept = requires(T t) &#123;  &#123; t.foo()...</div></div></div></a><a class="pagination-related" href="/posts/8724ba9a.html" title="C++ 入门（下）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/C++%20%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%8B%EF%BC%89.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-10</div><div class="info-item-2">C++ 入门（下）</div></div><div class="info-2"><div class="info-item-1">关联型容器 Associative Containers 关联型容器通常需要键满足 &lt;，否则可以自定义一个： bool compareIsbn(const Sales_data &amp;lhs, const Sales_data &amp;rhs) &#123;    return lhs.isbn() &lt; rhs.isbn();&#125;multiset&lt;Sales_data, decltype(compareIsbn)*&gt; bookstore(compareIsbn); 关联性容器定义了三种类型：  key_type mapped_type value_type  set：key_type map：pair&lt;const key_type, mapped_type&gt;    set 的迭代器都是 const_iterator .lower_bound() &gt;=，.upper_bound() &gt;，.equal_range() 除此之外，还有键可以重复的 multiset 和 multimap unordered_set 和...</div></div></div></a><a class="pagination-related" href="/posts/f366bb7b.html" title="C++杂项"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/C++%E6%9D%82%E9%A1%B9.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-01</div><div class="info-item-2">C++杂项</div></div><div class="info-2"><div class="info-item-1">安装 C++ 编译器 对于 Windows 用户，这里推荐 WinLibs，里面同时包含了 GCC 和 Clang，以及一些在开发中常用的工具，如 CMake、GNU Make、Ninja、Nasm、Doxygen、cppcheck 等。 将下载的压缩包解压到某个目录，然后将该目录添加到环境变量 PATH 中 对中文的支持 C语言直接设置控制台输出字符编码： #include &lt;locale.h&gt;#include &lt;stdio.h&gt;int main()&#123;    setlocale(LC_ALL, &quot;zh_CN.UTF-8&quot;);    printf(&quot;你好，世界！\n&quot;);    return 0;&#125; 配置 VS Code 安装如下插件  clangd：比微软官方的 C/C++ 插件 更好用 CodeLLDB：调试插件 CMake 和 CMake Tools：cmake 是目前看来 c++ 项目中最好的构建工具  配置 clangd // Clangd 运行参数(终端输入 clangd...</div></div></div></a><a class="pagination-related" href="/posts/30479bcf.html" title="Effective C++"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/Effective%20C++.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-20</div><div class="info-item-2">Effective C++</div></div><div class="info-2"><div class="info-item-1">基于 Effective C++ Third Edition: 55 Specific Ways to Improve Your Programs and designs 编写 让你自己习惯于 C++ 将 C++ 视为语言的联邦 C++ 不是一门单独的语言，其具有各种不同风格的语言特性，以至于可能出现两个同样使用 C++ 的人会看不懂彼此的代码。一般分为四大组成部分：  C 面向对象的 C++ 模板 C++ STL  因此基于使用的 C++ 的部分不用，Effective C++ 编程的规则也可能不同 倾向于 const、enum 和 inline 而不是 #define 对于变量而言，const 和 enum 限制了作用域 对于函数而言，inline 函数能够避免一些未知错误 尽可能使用 const 声明某种东西 const 可以帮助编译器检测一些使用错误，同时 const 可以适用于任何作用域中的对象，包括函数参数，返回值，甚至整个成员函数 编译器强制 bitwise const，但应该使用逻辑 const 编程 当 const 和非 const...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/%E5%A4%B4%E5%83%8F_%E7%81%B0%E5%A4%AA%E7%8B%BC.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Aefrivern</div><div class="author-info-description">我一定会回来的</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">191</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">245</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/aefrivern" rel="external nofollow noreferrer" target="_blank" title="icon-github"><i class="GitHub"></i></a><a class="social-icon" href="mailto:2771503468@qq.com" rel="external nofollow noreferrer" target="_blank" title="icon-youxiang"><i class="QQ邮箱"></i></a><a class="social-icon" href="https://steamcommunity.com/id/old_driver_zero" rel="external nofollow noreferrer" target="_blank" title="icon-steam"><i class="Steam"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><a class="faa-parent animated-hover"><svg class="faa-tada icon" style="height:25px;width:25px;fill:currentColor;position:relative;top:5px" aria-hidden="true"><use xlink:href="#icon-mulu"></use></svg></a><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AE%89%E8%A3%85"><span class="toc-number">1.</span> <span class="toc-text">下载和安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Qt-Creator"><span class="toc-number">2.</span> <span class="toc-text">Qt Creator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD"><span class="toc-number">3.</span> <span class="toc-text">信号与槽</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">插入信号和槽的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%A1%E5%8F%B7"><span class="toc-number">3.2.</span> <span class="toc-text">自定义信号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">实现计算器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">计时器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QObject"><span class="toc-number">5.1.</span> <span class="toc-text">QObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QTimer"><span class="toc-number">5.2.</span> <span class="toc-text">QTimer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">6.</span> <span class="toc-text">文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%E4%B8%8E%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-number">6.1.</span> <span class="toc-text">文件的打开与文件信息的获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="toc-number">6.2.</span> <span class="toc-text">二进制文件读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="toc-number">6.3.</span> <span class="toc-text">文本文件读写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E5%92%8C%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="toc-number">7.</span> <span class="toc-text">鼠标和键盘事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%96%B0%E7%AA%97%E5%8F%A3"><span class="toc-number">8.</span> <span class="toc-text">启动新窗口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">9.</span> <span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%98%E5%9B%BE"><span class="toc-number">10.</span> <span class="toc-text">绘图</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>安得广厦千万间，大庇天下寒士俱欢颜，风雨不动安如山。</div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/comments/">留点什么</a><a href="/random/">随便逛逛</a></li><li><a href="/about/">关于</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/gallery/">我的画廊</a><a href="/charts/">网站统计</a></li></ul></div></div></div></div><div class="copyright">&copy;2022 - 2025 By Aefrivern</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><script async src="//at.alicdn.com/t/c/font_4031045_1yiosqv4vch.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      window.location.href = e.request.responseURL
    }
  })
})()</script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/c/font_4031045_izvon5l4fr8.js"></script><!-- hexo injector body_end end --></body></html>