<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MIT 6.S081：操作系统工程 | Aefrivernの小屋</title><meta name="author" content="Aefrivern"><meta name="copyright" content="Aefrivern"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="简介和例子 Introduction and Examples 操作系统的目标：  抽象硬件 多路复用 multiplex，即同时运行多个程序 隔离性 不同活动共享信息 安全或权限系统 高性能 大量不同的应用场景  分为用户空间和内核 kernel 空间，内核直接与硬件资源交互，应用程序通过系统调用 system call 来与内核交互  系统调用包括了 write、open、fork 等，看起来">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT 6.S081：操作系统工程">
<meta property="og:url" content="https://aefrivern.github.io/posts/ce6540f3.html">
<meta property="og:site_name" content="Aefrivernの小屋">
<meta property="og:description" content="简介和例子 Introduction and Examples 操作系统的目标：  抽象硬件 多路复用 multiplex，即同时运行多个程序 隔离性 不同活动共享信息 安全或权限系统 高性能 大量不同的应用场景  分为用户空间和内核 kernel 空间，内核直接与硬件资源交互，应用程序通过系统调用 system call 来与内核交互  系统调用包括了 write、open、fork 等，看起来">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://aefrivern.github.io/gallery/cover/MIT%206.S081%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B.webp">
<meta property="article:published_time" content="2024-09-03T02:12:27.000Z">
<meta property="article:modified_time" content="2024-11-23T06:02:05.000Z">
<meta property="article:author" content="Aefrivern">
<meta property="article:tag" content="MIT">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://aefrivern.github.io/gallery/cover/MIT%206.S081%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B.webp"><link rel="shortcut icon" href="/illustration/favicon.ico"><link rel="canonical" href="https://aefrivern.github.io/posts/ce6540f3.html"><link rel="preconnect" href="//unpkg.com"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"GY5EJYJ1FS","apiKey":"c443c952672ec7062840aac45536181e","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MIT 6.S081：操作系统工程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-23 14:02:05'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4031045_1yiosqv4vch.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/highlight.css"><link rel="stylesheet" href="/css/custom.css"><script src="/js/echarts.min.js"></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://unpkg.com/pace-js@1.2.4/themes/blue/pace-theme-minimal.css"/><script src="https://unpkg.com/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/c/font_4031045_izvon5l4fr8.js"></script><!-- hexo injector body_end end --></body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/%E5%A4%B4%E5%83%8F_%E7%81%B0%E5%A4%AA%E7%8B%BC.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">159</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">216</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-shouye-01"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shouye-01"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-guidang"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guidang"></use></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw icon-a-16-01-01"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-a-16-01-01"></use></svg><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-wenjianjia"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wenjianjia"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/anime/"><i class="fa-fw icon-zhifeiji"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhifeiji"></use></svg><span> 二次元</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/gallery/"><i class="fa-fw icon-xiangce"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiangce"></use></svg><span> 画廊</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-guanyu"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyu"></use></svg><span> 关于</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/charts/"><i class="fa-fw icon-tongjichaxun"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tongjichaxun"></use></svg><span> 统计</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-liuyan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyan"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/random/"><i class="fa-fw icon-suiji"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-suiji"></use></svg><span> 随便逛逛</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/gallery/cover/MIT%206.S081%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="Aefrivernの小屋"><span class="site-name">Aefrivernの小屋</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-sousuo1"></use></svg><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-shouye-01"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shouye-01"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-guidang"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guidang"></use></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw icon-a-16-01-01"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-a-16-01-01"></use></svg><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-wenjianjia"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wenjianjia"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/anime/"><i class="fa-fw icon-zhifeiji"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhifeiji"></use></svg><span> 二次元</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/gallery/"><i class="fa-fw icon-xiangce"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiangce"></use></svg><span> 画廊</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-guanyu"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyu"></use></svg><span> 关于</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/charts/"><i class="fa-fw icon-tongjichaxun"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tongjichaxun"></use></svg><span> 统计</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-liuyan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyan"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/random/"><i class="fa-fw icon-suiji"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-suiji"></use></svg><span> 随便逛逛</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MIT 6.S081：操作系统工程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-03T02:12:27.000Z" title="发表于 2024-09-03 10:12:27">2024-09-03</time><span class="post-meta-separator">|</span><svg class="meta_icon post-ui-icon" style="width:13px;height:13px;position:relative;top:2px"><use xlink:href="#icon-gengxin"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-23T06:02:05.000Z" title="更新于 2024-11-23 14:02:05">2024-11-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><a class="faa-parent animated-hover"></a><svg class="meta_icon post-ui-icon" style="width:13px;height:13px;position:relative;top:2px"><use xlink:href="#icon-fenlei"></use></svg><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-word"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">5.5k</span><span class="post-meta-separator">|</span><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="简介和例子-Introduction-and-Examples">简介和例子 Introduction and Examples</h2>
<p>操作系统的目标：</p>
<ul>
<li>抽象硬件</li>
<li>多路复用 multiplex，即同时运行多个程序</li>
<li>隔离性</li>
<li>不同活动共享信息</li>
<li>安全或权限系统</li>
<li>高性能</li>
<li>大量不同的应用场景</li>
</ul>
<p>分为用户空间和<strong>内核 kernel</strong> 空间，内核直接与硬件资源交互，应用程序通过<strong>系统调用 system call</strong> 来与内核交互</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/MIT%206.S081%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.webp" alt="操作系统结构"></p>
<p>系统调用包括了 <code>write</code>、<code>open</code>、<code>fork</code> 等，看起来和普通的函数调用差不多</p>
<p>操作系统设计的矛盾点：</p>
<ul>
<li>高效 - 抽象</li>
<li>强大 - 简单的 API</li>
<li>灵活 - 安全</li>
</ul>
<h2 id="组织和系统调用-Organization-and-System-Calls">组织和系统调用 Organization and System Calls</h2>
<p>操作系统的隔离性和防御性</p>
<ul>
<li>user/kernel mode</li>
<li>虚拟内存</li>
</ul>
<p>kernel mode 权限更高，能够执行一些 user mode 不允许执行的命令</p>
<p>每个进程都有自己的<strong>页表 page table</strong></p>
<p>将程序的控制权转移到内核的指令是 <strong>ecall</strong>，其传入一个数字作为参数，表示要求的系统调用</p>
<p>内核有时被称为<strong>可被信任的计算空间 Trusted Computing Base</strong>，其必须将用户的进程当作是恶意的</p>
<p>什么代码该运行在 kernel mode？</p>
<ul>
<li>整个操作系统——<strong>宏内核 Monolithic Kernel Design</strong>
<ul>
<li>绝大多数操作系统都这么做</li>
<li>缺点：出现 bug 的概率较高</li>
<li>优点：性能强</li>
</ul>
</li>
<li><strong>微内核 Micro Kernel Design</strong>：运行尽可能少的代码
<ul>
<li>嵌入式系统</li>
<li>优缺点与上面的相反</li>
</ul>
</li>
</ul>
<h2 id="页表-Page-Tables">页表 Page Tables</h2>
<p>由于内存地址对应关系的表单也保存在内存中，所以需要一个寄存器来保存该表单在内存中的物理地址，这个寄存器叫 SATP</p>
<p>为了节省表单的空间，给出两个解决方案：</p>
<ul>
<li>4 KB 为一页</li>
<li>三级表</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/MIT%206.S081%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80.webp" alt="虚拟地址与物理地址"></p>
<p>对于物理地址：低于 0x80000000 的不存在 DRAM 中，而是对应其他 IO 设备</p>
<p>对于虚拟地址：</p>
<p>注意到存在 Guard page，其未被映射到某个物理地址，目的是当 kernel stack 耗尽时，会溢出到 Guard page，立刻出发 page fault，就能直到 kernel stack 出错了</p>
<h2 id="隔离-系统调用的出入-Isolation-System-Call-entry-exit">隔离 &amp; 系统调用的出入 Isolation &amp; System Call entry/exit</h2>
<p>用户空间和内核空间会发生在：</p>
<ul>
<li>系统调用</li>
<li>page fault，除 0 等错误</li>
<li>中断</li>
</ul>
<p>这种切换被称为 <strong>trap</strong></p>
<p>涉及的一些寄存器：</p>
<ul>
<li>32 个通用寄存器</li>
<li>pc</li>
<li>表示当前在 supervisor mode 还是 user mode 的标志位</li>
<li><strong>SATP（Supervisor Address Translation and Protection）寄存器</strong>：指向 page table 的物理内存地址</li>
<li><strong>STVEC（Supervisor Trap Vector Base Address Register）寄存器</strong>：指向内核中处理 trap 的指令的起始地址</li>
<li><strong>SEPC（Supervisor Exception Program Counter）寄存器</strong>：在 trap 的过程中保存 pc 的值</li>
<li><strong>SSRATCH（Supervisor Scratch Register）寄存器</strong></li>
</ul>
<p>整个过程需要对这些东西执行的操作：</p>
<ul>
<li>保存 32 个用户寄存器，因为这些寄存器会被内核代码使用，要防止其被弄乱</li>
<li>保存 pc，能够继续执行程序</li>
<li>改成 supervisor mode</li>
<li>SATP 从 user page table 指向 kernel page table</li>
<li>堆栈寄存器指向位于内核的一个地址，因为需要一个堆栈来调用内核的 C 函数</li>
<li>跳入内核的 C 代码</li>
</ul>
<p>trap 机制的实现目标：</p>
<ul>
<li>只保存而不查看 32 个寄存器</li>
<li>trap 机制对用户代码透明</li>
</ul>
<p>对于 supervisor mode 的特权，有一点值得注意：可以使用 PTE_U 标志位为 0 的 PTE，（在这里）不能使用 PTE_U = 1 的 PTE</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/MIT%206.S081%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B/trap%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.webp" alt="trap代码执行流程"></p>
<p>ecall 做的事：</p>
<ul>
<li>代码从 user mode 改到 supervisor mode</li>
<li>将 pc 的值保存到 SEPC</li>
<li>关中断</li>
<li>跳转到 STVEC 寄存器指向的指令</li>
</ul>
<p>RISC-V 的 ecall 的硬件做的事非常少，是秉持了提供灵活性的原则</p>
<p>内核将 trapframe page 映射到了每个 user page table，其包含了 32 个寄存器等数据，而在进入 user space 之前，内核会将 trapframe page 的地址保存在 SSCRATCH 寄存器中，配合交换两个寄存器的 csrrw 指令，实现保存另一个寄存器的值，并将自己的值加载给另一个寄存器</p>
<p>至于为什么要内核自己找一块地方自己来保存，是因为可能有的编程语言没有栈，或者栈的格式和寻常理解的不一样</p>
<p>trampoline 的代码在 user page table 中的映射与 kernel page table 中的映射完全一样，所以切换 page table 时程序不会崩溃</p>
<h2 id="页错误-Page-Faults">页错误 Page Faults</h2>
<p>page fault 的信息：</p>
<ul>
<li>引起 page fault 的内存地址</li>
<li>引起 page fault 的原因类型</li>
<li>引起 page fault 时的 pc 值，这表明了 page fault 在用户空间发生的位置</li>
</ul>
<p><strong>Lazy page allocation</strong>：可以不立刻为程序分配物理内存</p>
<p><strong>Zero Fill On Demand</strong>：在 C 语言中，定义一个大数组，其内容默认全为 0，则只需要真正分配一块物理内存</p>
<p><strong>Copy On Write Fork</strong>：在子进程复制父进程的虚拟地址空间时，并不复制，而是直接引用父进程的 page，初始时全是只读的，某一方需要写的时候才分配新的内存，并修改为可读写</p>
<ul>
<li>PTE 中的 RSW 可以作为 copy-on-write 的标志位</li>
<li>对于多重引用的问题，需要另外维护一个数据结构来完成引用的计数</li>
</ul>
<p><strong>Demand Paging</strong>：并不加载程序内存的 text，data 区域</p>
<p><strong>Memory Mapped Files</strong>：即 mmap</p>
<h2 id="中断-Interrupts">中断 Interrupts</h2>
<p>中断，即硬件想要得到操作系统的关注，处理过程和系统调用类似，但有以下几点不同：</p>
<ul>
<li>异步</li>
<li>并发</li>
<li>程序设备</li>
</ul>
<p>处理器上通过 <strong>Platform Level Interrupt Control (PLIC)</strong> 来处理设备中断</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/MIT%206.S081%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B/PLIC.webp" alt="PLIC"></p>
<p>当 PLIC 接收到中断请求时，</p>
<ul>
<li>通知当前有一个待处理的中断</li>
<li>其中一个 CPU 核会 Claim 接收中断，这样 PLIC 就不会把中断发给其他的 CPU 处理</li>
<li>CPU 核处理完中断之后，CPU 会通知 PLIC</li>
<li>PLIC 将不再保存中断的信息</li>
</ul>
<p>驱动分为两部分：bottom/top</p>
<ul>
<li>bottom 部分通常是 Interrupt handler</li>
<li>top 部分是用户进程或内核的其他部分调用的接口</li>
<li>通常有 buffer，top 和 bottom 部分会同时读写数据</li>
</ul>
<p>硬件的编程通常通过 memory mapped I/O 实现</p>
<p>RISC-V 中与中断有关的寄存器：</p>
<ul>
<li>
<p>**SIE（Supervisor Interrupt Enable）**寄存器：这个寄存器中有一个 bit（E）专门针对例如 UART 的外部设备的中断；有一个 bit（S）专门针对软件中断，软件中断可能由一个 CPU 核触发给另一个 CPU 核；还有一个 bit（T）专门针对定时器中断。</p>
</li>
<li>
<p><strong>SSTATUS（Supervisor Status）寄存器</strong>：每一个 CPU 核都有独立的 SIE 和 SSTATUS 寄存器，除了通过 SIE 寄存器来单独控制特定的中断，还可以通过 SSTATUS 寄存器中的一个 bit 来控制所有的中断。</p>
</li>
<li>
<p>**SIP（Supervisor Interrupt Pending）**寄存器：当发生中断时，处理器可以通过查看这个寄存器知道当前是什么类型的中断。</p>
</li>
</ul>
<p>UART 驱动的 top 和 bottom 部分是一个 producer-consumer 模型</p>
<p>对于一个快速的设备，Interrupt 机制的开销太大了，一般使用 polling。有的驱动能够在 polling 和 Interrupt 之间动态切换</p>
<h2 id="线程切换-Thread-Switching">线程切换 Thread Switching</h2>
<p>多线程原因：</p>
<ul>
<li>分时复用任务</li>
<li>程序结构简单</li>
<li>并行运算</li>
</ul>
<p>这里对于<strong>线程 thread</strong> 的定义是单个串行执行代码的单元</p>
<p>线程的状态：</p>
<ul>
<li>PC</li>
<li>寄存器</li>
<li>Stack</li>
</ul>
<p>多线程的并行运行主要有两个策略：</p>
<ul>
<li>是在多核处理器上使用多个 CPU</li>
<li>一个 CPU 在多个线程之间来回切换</li>
</ul>
<p>处理<strong>运算密集型线程（compute bound thread）</strong>：利用定时器中断，将 CPU 出让（<strong>yield</strong>）给线程调度器</p>
<p>这种流程叫做 <strong>pre-emptive scheduling</strong>，即用户代码本身没有出让 CPU，定时器中断仍然会将 CPU 的控制权拿走，并出让给线程调度器，与之相反的是 <strong>voluntary scheduling</strong></p>
<p>在实际实现中是这样的：使用 pre-emptive scheduling 将 CPU 控制权从用户进程给到内核，然后使用 voluntary scheduling 内核中用户进程对应的内核线程会代表用户进程出让 CPU</p>
<p>为了区分线程，线程有一些状态：</p>
<ul>
<li><strong>RUNNING</strong>，线程当前正在某个 CPU 上运行</li>
<li><strong>RUNABLE</strong>，线程还没有在某个 CPU 上运行，但是一旦有空闲的 CPU 就可以运行</li>
<li><strong>SLEEPING</strong>，线程在等待一些 I/O 事件，它只会在 I/O 事件发生了之后运行</li>
</ul>
<p>线程切换如图，即从用户进程进入对应的内核进程，然后进入该 CPU 的 schedulder 函数，其找到下一个进程，切换到该进程，最后退出该内核进程到用户进程中</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/MIT%206.S081%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2.webp" alt="线程切换"></p>
<p>注意到，这里的 <strong>context switching</strong> 指一个内核线程和调度器线程之间的切换</p>
<h2 id="Sleep-和-Wake-Up">Sleep 和 Wake Up</h2>
<p>在 xv6 系统的设计中，进程在调用 switch 函数的过程中，有两个限制条件：</p>
<ul>
<li>必须要持有 p-&gt;lock</li>
<li>同时又不能持有任何其他的锁</li>
</ul>
<p>注意到 <code>sleep</code> 的接口 <code>sleep(&amp;tx_chan, &amp;uart_tx_lock)</code> 中需要传入一个锁，如果改成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">release(&amp;uart_tx_lock);<br><span class="hljs-comment">// INTERRUPT</span><br>broken_sleep(&amp;tx_chan);<br>acquire(&amp;uart_tx_lock);<br></code></pre></td></tr></table></figure>
<p>要是在注释处发生中断，则有可能出现 <code>wakeup</code> 在 <code>sleep</code> 之前被调用，即 <strong>lost wakeup</strong></p>
<p>还有要注意的是 <code>sleep</code> 的写法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (tx_done == <span class="hljs-number">0</span>)<br>    sleep(&amp;tx_chan, &amp;uart_tx_lock);<br></code></pre></td></tr></table></figure>
<p>即写在一个循环里面，因为有可能出现被唤醒了，但是其他人将等待的事件拿走了，而只能继续 sleep 的情况</p>
<p>解决 lost wakeup 的问题需要遵循一系列规则：</p>
<ul>
<li>调用 sleep 时需要持有 condition lock，这样 sleep 函数才能知道相应的锁</li>
<li>sleep 函数只有在获取到进程的锁 p-&gt;lock 之后，才能释放 condition lock</li>
<li>wakeup 需要同时持有两个锁才能查看进程</li>
</ul>
<p>对于如何关闭一个进程，存在两大问题：</p>
<ul>
<li>不能直接单方面的摧毁另一个线程</li>
<li>即使一个线程调用了 exit 系统调用，并且是自己决定要退出，它仍然持有了运行代码所需要的一些资源</li>
</ul>
<p>在 <code>exit</code> 系统调用中，我们将进程的状态设置为 <code>ZOMBIE</code>，注意并没有释放资源，只是进程不再运行了</p>
<p>在 <code>wait</code> 系统调用中，父进程会找到 ZOMBIE 进程，然后释放资源</p>
<p><code>kill</code> 系统调用基本上不做任何事情，只是设置 <code>killed</code> 标志位；然后在 <code>usertrap</code> 函数中自我检查并调用 <code>exit</code></p>
<p>特别的，对于 <code>SLEEPING</code> 中的进程，通常会在循环中检测并直接退出；但是，对于等待磁盘读写的进程，又最好完成整个系统调用再退出</p>
<h2 id="文件系统-File-Systems">文件系统 File Systems</h2>
<p>文件系统的特性：</p>
<ul>
<li>对于用户友好的路径/文件名</li>
<li>在用户之间和进程之间共享文件</li>
<li>持久化</li>
</ul>
<p>背后的机制：</p>
<ul>
<li>对硬件的抽象</li>
<li>crash safety</li>
<li>磁盘排布</li>
<li>性能</li>
</ul>
<p><strong>inode</strong> 是代表一个文件的对象，通过编号区分，有一个 link count 来跟踪指向这个 inode 的文件名的数量，此外还有 openfd count。一个文件只能在这两个计数器都为 0 的时候才能被删除</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/MIT%206.S081%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F.webp" alt="文件系统组织方式"></p>
<p>有两个术语：</p>
<ul>
<li><strong>sector</strong> 通常是磁盘驱动可以读写的最小单元，它过去通常是 512 字节</li>
<li><strong>block</strong> 由文件系统定义，在 XV6 中它是 1024 字节</li>
</ul>
<p>从文件系统来看，布局为：</p>
<ul>
<li>block0 要么没有用，要么被用作 boot sector 来启动操作系统。</li>
<li>block1 通常被称为 super block，它描述了文件系统</li>
<li>inode：多个 inode 会打包存在一个 block 中，一个 inode 是 64 字节。</li>
<li>bitmap block：只占据一个 block，记录了数据 block 是否空闲。</li>
<li>数据 block：存储文件和目录的内容</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/MIT%206.S081%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80.webp" alt="文件系统布局"></p>
<p>inode 的结构：</p>
<ul>
<li>type：是文件还是目录</li>
<li>nlink：即 link 计数器，用来跟踪究竟有多少文件名指向了当前的 inode</li>
<li>size</li>
<li>direct block number</li>
<li>indirect block number</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/MIT%206.S081%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B/inode.webp" alt="inode"></p>
<p>目录包含了多条 directory entries，每一条 entry</p>
<ul>
<li>前 2 个字节包含目录中文件或子目录的 inode 编号，</li>
<li>后 14 个字节包含文件或子目录名</li>
</ul>
<p>block cache：</p>
<ul>
<li>在内存中，对于一个 block 只能有一份缓存</li>
<li>使用 sleep lock 而不是 spinlock</li>
<li>使用 LRU 作为 cache 替换策略</li>
<li>有两层锁：第一层锁用来保护 buffer cache 的内部数据；第二层锁用来保护单个 block 的 cache</li>
</ul>
<h2 id="崩溃恢复-Crash-Recovery">崩溃恢复 Crash Recovery</h2>
<p>目标是为了在发生 crash 之后仍然能够正常使用<strong>文件系统</strong></p>
<p>出现文件系统无法正常使用的原因在于有多个写磁盘的操作，这些操作必须作为一个原子操作出现在磁盘上</p>
<p>这里给出的解决方案是 <strong>logging</strong></p>
<ul>
<li><strong>log write</strong>：任何写操作都先写入到 log</li>
<li><strong>commit</strong>：当文件系统的操作结束，并且都存在于 log 中，我们会 commit 文件系统的操作</li>
<li><strong>install</strong>：将 block 从 log 分区移到文件系统分区</li>
<li><strong>clean</strong>：清除 log</li>
</ul>
<p>重启后 reinstall</p>
<p>log 最开始有一个 header block，包括：</p>
<ul>
<li>n：有效的 log block 的数量</li>
<li>b：每个 log block 实际对应的 block 编号</li>
</ul>
<p>然后是每个 block 的数据，内存中也有一份 header block 的拷贝</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/MIT%206.S081%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B/log%E7%BB%93%E6%9E%84.webp" alt="log结构"></p>
<p>尽管示例的文件系统很简单，但也有几个微妙的注意点：</p>
<ul>
<li>cache eviction：buffer cache 不能撤回任何还位于 log 的 block</li>
<li>文件系统操作必须适配 log 的大小：要是一个文件系统操作写入数据超过了 log 大小，则会被分割成多个小一点的写操作，这样就失去了写操作的原子性，但至少保全了文件系统</li>
<li>并发执行的 transaction 写入的总 log 数小于 log 区域的大小，这里的方法是通过限制并发文件系统操作的个数</li>
</ul>
<h2 id="文件系统性能与快速崩溃恢复-File-System-Performance-and-Fast-Crash-Recovery">文件系统性能与快速崩溃恢复 File System Performance and Fast Crash Recovery</h2>
<p>在这里 ext3 = ext2 + journal</p>
<p>logging 系统需要满足的：</p>
<ul>
<li><strong>write ahead rule</strong>：需要预先在 log 中定义好所有需要具备原子性的更新，之后才能应用这些更新</li>
<li><strong>freeing rule</strong>：直到 log 中所有的写操作被更新到文件系统之前，我们都不能释放或者重用 log</li>
</ul>
<p>xv6 很慢的原因：系统调用对于写磁盘操作来说是<strong>同步</strong>的</p>
<p>ext3 维护了一些 transaction 信息，所以可以维护多个在不同阶段的 transaction 的信息，包括</p>
<ul>
<li>序列号，block 编号</li>
<li>对应了系统调用的 handles</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/MIT%206.S081%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B/ext3%20log.webp" alt="ext3 log结构"></p>
<p>descriptor block 和 commit block 会以一个 32bit 的 magic number 作为起始，以同 data block 区分开</p>
<p>注意 log 中会有多个 transaction，但是一个时间只有一个正在进行的 transaction</p>
<p>ext3 提升性能的方法：</p>
<ul>
<li><strong>异步的</strong>系统调用</li>
<li><strong>批量执行 batching</strong>，即将多个系统调用打包成一个 transaction</li>
<li>并发</li>
</ul>
<p>异步执行的优点在于能够同时进行磁盘操作和应用程序运算，缺点在于系统调用的返回并不能表示其应该完成的工作实际完成了，故会提供一个 <code>fsync</code> 的系统调用来同步</p>
<p>batching 的优点：</p>
<ul>
<li>分摊了 transaction 带来的固有的损耗</li>
<li><strong>write absorption</strong>，即多个系统调用写了同一个 block</li>
<li>disk scheduling，即大量连续写的请求</li>
</ul>
<p>两种 concurrency：</p>
<ul>
<li>多个系统调用同时执行</li>
<li>多个不同状态的 transaction 同时存在</li>
</ul>
<p>ext3 需要跟踪正在进行的系统调用个数，通过 <strong>handle</strong> 识别并记住系统调用所属的 transaction</p>
<p>transaction commit 步骤：</p>
<ol>
<li>阻止新的系统调用</li>
<li>等待 transaction 中未完成的系统调用完成</li>
<li>开始一个新的 transaction</li>
<li>更新 descriptor block</li>
<li>将实际的 block 写入到 log 中</li>
<li>等待写 log 结束</li>
<li>写 commit block</li>
<li>等待写 commit block 结束</li>
<li>将 transaction 包含的 block 写入到文件系统中的实际位置</li>
<li>写完后，重用那些 log 空间</li>
</ol>
<h2 id="用户应用程序使用的虚拟内存-Virtual-memory-for-applications">用户应用程序使用的虚拟内存 Virtual memory for applications</h2>
<p>虚拟内存的特性：</p>
<ul>
<li>trap：用户定义 Page Fault handler（<code>sigaction</code>）</li>
<li>Prot1：降低一个 Page 的 accessability（<code>mprotect</code>）</li>
<li>ProtN：类似于 Prot1，但是可以将成本分摊到 N 个 Page，使得操作单个 Page 的性能损耗更少（<code>mprotect</code>）</li>
<li>Unprot：增加一个 Page 的 accessability（<code>mprotect</code>）</li>
<li>Dirty：查看内存 Page 是否是 Dirty</li>
<li>map2：一段物理内存对应两份虚拟内存，注意可以有不同的 accessability（多次 <code>mmap</code>）</li>
</ul>
<p><strong>Virtual Memory Areas（VMAs）</strong>：记录一些有关连续虚拟内存地址段的信息</p>
<p><strong>构建大缓存表</strong>：其实就是在 Page Fault Handler 中计算，而在外部看来，就是一张非常大的缓存表</p>
<p><strong>copying GC</strong>：将对象从 from 空间复制到 to 空间</p>
<p><strong>Baker's Real-Time Copying Garbage Collector</strong>：和上面类似，但是是 <strong>incremental GC</strong>，即不必停止程序一次完成，而是一步步完成</p>
<ul>
<li>应用程序调用 new 来申请内存时，扫描几个对象，并将这些对象从 from 空间 forward 到 to 空间</li>
<li>每次获取一个指针指向的对象（dereference）时，都需要检查对象是否在 from 空间中，是的话将其从 from 空间 forward 到 to 空间</li>
</ul>
<p>注意到有两个问题：</p>
<ul>
<li>检查指针的开销</li>
<li>难以并发</li>
</ul>
<p>论文中给出的方法：将空间进一步划分为 scanned 和 unscanned，将 unscanned 权限设置为 None</p>
<ul>
<li>在 Page Fault Handler 中，扫描位于内存的所有对象，将这些对象所指向的其他对象从 from 空间 forward 到 to 空间，然后该对象标记为 scanned 并恢复权限</li>
</ul>
<p>注意到这种方法本质上是将指针检查交给硬件完成了，除此之外，同步也交给硬件完成了</p>
<p>还有权限问题：应用程序要求 unscanned 权限为 None，而 GC 则要求读写权限，这里使用 map2 实现</p>
<h2 id="OS-架构-OS-organization">OS 架构 OS organization</h2>
<p>微内核：进程抽象和通过 **IPC（Inter-Process Communication）**进程间通信</p>
<p>其余，如文件系统是通过一个用户空间进程来实现</p>
<p>现在微内核一般出现在微型嵌入式系统中</p>
<p>大量使用 IPC，故 IPC 的速度很重要</p>
<p>为了兼容现有的程序，该论文对 Linux 进行了一些修改，使其能够作为一个用户进程运行在 L4 上</p>
<h2 id="虚拟机-Virtual-Machines">虚拟机 Virtual Machines</h2>
<p>**Virtual Machine Monitor（VMM）**上面是 Guest 空间，下面是 Host 空间</p>
<p>由于 Guest kernel 运行在 User mode，所以使用 privileged 指令会触发 trap 走回到 VMM 中，VMM 获得控制权</p>
<p>VMM 会为每一个 Guest 维护一套虚拟状态信息</p>
<p>Trap and Emulate 的实现还包括了 Page Table。VMM 会为每个虚拟机维护一个映射表，将 Guest 物理内存地址映射到真实的物理内存地址</p>
<p><strong>Shadow Page Table</strong> 的地址是 VMM 向真实 SATP 寄存器写入的值，使得 Guest kernel 认为自己使用的是一个正常的 Page Table，但是实际的硬件使用的是 Shadow Page Table</p>
<p>对于设备，有三种策略：</p>
<ul>
<li>模拟一些设备</li>
<li>提供虚拟设备</li>
<li>对于真实设备的 pass-through</li>
</ul>
<p>Intel 的 VT-x 在硬件上提供了对虚拟机的支持</p>
<p>**EPT（Extended Page Table）**会指向一个 Page Table，对 Guest 的地址进行第二次的翻译</p>
<p>Dune 能够在硬件层面支持进程同时拥有 Guest Supervisor mode 和 Guest User mode，这样进程可以在自己的 User mode 中运行未被信任的插件代码</p>
<h2 id="网络-Network">网络 Network</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/MIT%206.S081%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B/packet%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B.webp" alt="packet的控制流程"></p>
<p>曲线的下降被称为中断的 <strong>Livelock</strong>，是由于输入中断的优先级更高，使得转发 packet 的任务可能分配不到任何 CPU 时间</p>
<p>解决方案是关中断，唤醒处理 packet 的线程，从<strong>网卡</strong>一次拉取多个 packet 并处理，不断重复，直到网卡中没有等待处理的 packet，然后重新打开网卡中断并 sleep</p>
<p>实际上是在高负载时将中断模式（Interrupt Scheme）转变成了轮询模式（Polling Scheme）</p>
<h2 id="Meltdown">Meltdown</h2>
<p>Meltdown 涉及利用 CPU 内隐藏的实现细节，因此被称为 Micro-Architectural Attack</p>
<p>攻击者依赖 CPU 的两个实现技巧：预测执行和缓存</p>
<ul>
<li>Intel CPU 的超前的预测执行会忽略权限将数据取出</li>
<li>该论文发布时绝大多数操作系统为了性能，不会在内核空间和用户空间之间切换的时候更换 Page Table，所以缓存不会在切换时被刷新。因此可以通过时间来得到缓存的信息</li>
</ul>
<p>原因类似的还有 Spectre</p>
<p>操作系统给出的修复方案是切换 Page Table</p>
<h2 id="RCU">RCU</h2>
<p>目标结构是一个链表，且有多个并发读，只有一个写</p>
<p>第一种方案是读写锁，代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rwlock</span> &#123;</span><br>    <span class="hljs-type">int</span> n;<br>&#125;;<br><br>r_lock(l):<br>    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>        x = l-&gt;n<br>        <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span><br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> CAS(&amp;l-&gt;n, x, x + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span><br><br>w_lock(l):<br>    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">if</span> CAS(&amp;l-&gt;n, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure>
<p>可以注意到，问题在于每次循环都只能有一个成功，同时由于要修改计数器 <code>l-&gt;n</code>，导致每次都需要让其余核的缓存失效</p>
<p>于是出现了 <strong>RCU（Read Copy Update）</strong>，通过增加写入者的负担来使读取速度加快</p>
<p>注意这种方法的要求是 <strong>committing write</strong> 必须是原子的，因此双向链表无法使用，但树却非常合适</p>
<p>有的编译器可能会重排读操作，从而导致出现问题，所以应该设置 <strong>memory barrier</strong>，强制完成之前的操作</p>
<p>最后一个问题在于何时释放旧对象，RCU 使用的方法是：</p>
<ul>
<li>读取者不允许在 context switch 时持有一个链表元素的指针</li>
<li>写入者在每一个 CPU 核都执行过至少一次 context switch 之后再释放链表元素</li>
</ul>
<p>这是简单的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">rcu_read_lock()<br>e = head<br><span class="hljs-keyword">while</span> (p) &#123;<br>    e = rcu_dereference(e)<br>    look at e-&gt;x<br>    e = e-&gt;next<br>&#125;<br>rcu_read_unlock()<br><br>acquire(lock)<br>old = head<br>e = alloc()<br>e-&gt;x = ...<br>e-&gt;next = head-&gt;next<br>rcu_assign_pointer(&amp;head, e)<br>release(lock)<br><br>synchronized_rcu()<br><span class="hljs-built_in">free</span>(old)<br></code></pre></td></tr></table></figure>
<p>RCU 是否有用取决于工作负载，通常对于读频繁的业务有一定的提升</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MIT/">MIT</a><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="/gallery/cover/MIT%206.S081%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/86226930.html" title="Coursera：机器学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/Coursera%EF%BC%9A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Coursera：机器学习</div></div></a></div><div class="next-post pull-right"><a href="/posts/14ee3e49.html" title="愿你们的旅途上充满了无尽的诅咒和祝福"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/%E6%9D%A5%E8%87%AA%E6%B7%B1%E6%B8%8A.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">愿你们的旅途上充满了无尽的诅咒和祝福</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="iconfont icon-tuijian"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/4392373e.html" title="MIT 18.01：单变量微积分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/MIT%2018.01%EF%BC%9A%E5%8D%95%E5%8F%98%E9%87%8F%E5%BE%AE%E7%A7%AF%E5%88%86.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-31</div><div class="title">MIT 18.01：单变量微积分</div></div></a></div><div><a href="/posts/bb154b63.html" title="MIT 18.02：多变量微积分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/MIT%2018.02%EF%BC%9A%E5%A4%9A%E5%8F%98%E9%87%8F%E5%BE%AE%E7%A7%AF%E5%88%86.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-31</div><div class="title">MIT 18.02：多变量微积分</div></div></a></div><div><a href="/posts/440ed920.html" title="MIT 18.03：微分方程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/MIT%2018.03%EF%BC%9A%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-19</div><div class="title">MIT 18.03：微分方程</div></div></a></div><div><a href="/posts/62a1ec0c.html" title="MIT 18.04：复变函数"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/MIT%2018.04%EF%BC%9A%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-27</div><div class="title">MIT 18.04：复变函数</div></div></a></div><div><a href="/posts/ad31055e.html" title="MIT 6.041 &amp; 6.431：概率系统分析与应用概率"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/MIT%206.041%20&%206.431%EF%BC%9A%E6%A6%82%E7%8E%87%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%E6%A6%82%E7%8E%87.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-27</div><div class="title">MIT 6.041 &amp; 6.431：概率系统分析与应用概率</div></div></a></div><div><a href="/posts/3871b764.html" title="MIT 18.06：线性代数"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/MIT%2018.06%EF%BC%9A%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-02</div><div class="title">MIT 18.06：线性代数</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/%E5%A4%B4%E5%83%8F_%E7%81%B0%E5%A4%AA%E7%8B%BC.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Aefrivern</div><div class="author-info__description">我一定会回来的</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">159</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">216</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/aefrivern" rel="external nofollow noreferrer" target="_blank" title="GitHub"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-github"></use></svg></a><a class="social-icon faa-parent animated-hover" href="mailto:2771503468@qq.com" rel="external nofollow noreferrer" target="_blank" title="QQ邮箱"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://steamcommunity.com/id/old_driver_zero" rel="external nofollow noreferrer" target="_blank" title="Steam"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-steam"></use></svg></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><a class="faa-parent animated-hover"><svg class="faa-tada icon" style="height:25px;width:25px;fill:currentColor;position:relative;top:5px" aria-hidden="true"><use xlink:href="#icon-mulu"></use></svg></a><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B%E5%92%8C%E4%BE%8B%E5%AD%90-Introduction-and-Examples"><span class="toc-number">1.</span> <span class="toc-text">简介和例子 Introduction and Examples</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E7%BB%87%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-Organization-and-System-Calls"><span class="toc-number">2.</span> <span class="toc-text">组织和系统调用 Organization and System Calls</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8-Page-Tables"><span class="toc-number">3.</span> <span class="toc-text">页表 Page Tables</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BA%E5%85%A5-Isolation-System-Call-entry-exit"><span class="toc-number">4.</span> <span class="toc-text">隔离 &amp; 系统调用的出入 Isolation &amp; System Call entry&#x2F;exit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%94%99%E8%AF%AF-Page-Faults"><span class="toc-number">5.</span> <span class="toc-text">页错误 Page Faults</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD-Interrupts"><span class="toc-number">6.</span> <span class="toc-text">中断 Interrupts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2-Thread-Switching"><span class="toc-number">7.</span> <span class="toc-text">线程切换 Thread Switching</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sleep-%E5%92%8C-Wake-Up"><span class="toc-number">8.</span> <span class="toc-text">Sleep 和 Wake Up</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-File-Systems"><span class="toc-number">9.</span> <span class="toc-text">文件系统 File Systems</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D-Crash-Recovery"><span class="toc-number">10.</span> <span class="toc-text">崩溃恢复 Crash Recovery</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D-File-System-Performance-and-Fast-Crash-Recovery"><span class="toc-number">11.</span> <span class="toc-text">文件系统性能与快速崩溃恢复 File System Performance and Fast Crash Recovery</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8%E7%9A%84%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98-Virtual-memory-for-applications"><span class="toc-number">12.</span> <span class="toc-text">用户应用程序使用的虚拟内存 Virtual memory for applications</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OS-%E6%9E%B6%E6%9E%84-OS-organization"><span class="toc-number">13.</span> <span class="toc-text">OS 架构 OS organization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA-Virtual-Machines"><span class="toc-number">14.</span> <span class="toc-text">虚拟机 Virtual Machines</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C-Network"><span class="toc-number">15.</span> <span class="toc-text">网络 Network</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Meltdown"><span class="toc-number">16.</span> <span class="toc-text">Meltdown</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RCU"><span class="toc-number">17.</span> <span class="toc-text">RCU</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>安得广厦千万间，大庇天下寒士俱欢颜，风雨不动安如山。</div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/comments/">留点什么</a><a href="/random/">随便逛逛</a></li><li><a href="/about/">关于</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/gallery/">我的画廊</a><a href="/charts/">网站统计</a></li></ul></div></div></div></div><div class="copyright">&copy;2022 - 2024 By Aefrivern</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://unpkg.com/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.js"></script><script src="https://unpkg.com/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://unpkg.com/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><script async src="//at.alicdn.com/t/c/font_4031045_1yiosqv4vch.js"></script><link rel="stylesheet" href="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://unpkg.com/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://unpkg.com/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://unpkg.com/algoliasearch@4.22.0/dist/algoliasearch-lite.umd.js"></script><script src="https://unpkg.com/instantsearch.js@4.63.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.12.0"></script></div></div></html>