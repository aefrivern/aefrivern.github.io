<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Coursera Nand2Tetris：依据基本原理构建现代计算机：从与非门到俄罗斯方块 | Aefrivern的小屋</title><meta name="author" content="Aefrivern"><meta name="copyright" content="Aefrivern"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="布尔函数和逻辑门 Boolean Functions and Gate Logic 布尔逻辑 Boolean Logic 与或非 布尔函数合成 Boolean Functions Synthesis 不同的布尔函数能表达相同的意思 所有布尔函数都可以用“与或非”表示 进一步，都可以用“与非”表示 (x OR y) &#x3D; NOT(NOT(x) AND NOT(y)) 更进一步，可以用 NAND （AN">
<meta property="og:type" content="article">
<meta property="og:title" content="Coursera Nand2Tetris：依据基本原理构建现代计算机：从与非门到俄罗斯方块">
<meta property="og:url" content="https://aefrivern.github.io/posts/fb3794ef.html">
<meta property="og:site_name" content="Aefrivern的小屋">
<meta property="og:description" content="布尔函数和逻辑门 Boolean Functions and Gate Logic 布尔逻辑 Boolean Logic 与或非 布尔函数合成 Boolean Functions Synthesis 不同的布尔函数能表达相同的意思 所有布尔函数都可以用“与或非”表示 进一步，都可以用“与非”表示 (x OR y) &#x3D; NOT(NOT(x) AND NOT(y)) 更进一步，可以用 NAND （AN">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://aefrivern.github.io/gallery/cover/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97.webp">
<meta property="article:published_time" content="2023-08-28T00:17:22.000Z">
<meta property="article:modified_time" content="2024-11-23T06:27:49.000Z">
<meta property="article:author" content="Aefrivern">
<meta property="article:tag" content="希伯来大学">
<meta property="article:tag" content="体系结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://aefrivern.github.io/gallery/cover/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Coursera Nand2Tetris：依据基本原理构建现代计算机：从与非门到俄罗斯方块",
  "url": "https://aefrivern.github.io/posts/fb3794ef.html",
  "image": "https://aefrivern.github.io/gallery/cover/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97.webp",
  "datePublished": "2023-08-28T00:17:22.000Z",
  "dateModified": "2024-11-23T06:27:49.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Aefrivern",
      "url": "https://aefrivern.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/illustration/favicon.ico"><link rel="canonical" href="https://aefrivern.github.io/posts/fb3794ef.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"GY5EJYJ1FS","apiKey":"c443c952672ec7062840aac45536181e","indexName":"blog","hitsPerPage":6,"languages":{"input_placeholder":"搜索文章","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Coursera Nand2Tetris：依据基本原理构建现代计算机：从与非门到俄罗斯方块',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4031045_1yiosqv4vch.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/highlight.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/hexo-butterfly-article-double-row.css"><script src="/js/echarts.min.js"></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image: url(/gallery/wallpaper/wallpaper.webp);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/%E5%A4%B4%E5%83%8F_%E7%81%B0%E5%A4%AA%E7%8B%BC.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">180</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">235</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye-01"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-a-16-01-01"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-wenjianjia"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/anime/"><i class="fa-fw iconfont icon-zhifeiji"></i><span> 二次元</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw iconfont icon-xiangce"></i><span> 画廊</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyu"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/charts/"><i class="fa-fw iconfont icon-tongjichaxun"></i><span> 统计</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw iconfont icon-liuyan"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/random/"><i class="fa-fw iconfont icon-suiji"></i><span> 随便逛逛</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/gallery/cover/Coursera Nand2Tetris：依据基本原理构建现代计算机：从与非门到俄罗斯方块.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Aefrivern的小屋</span></a><a class="nav-page-title" href="/"><span class="site-name">Coursera Nand2Tetris：依据基本原理构建现代计算机：从与非门到俄罗斯方块</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-sousuo1"></use></svg><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye-01"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-a-16-01-01"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-wenjianjia"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/anime/"><i class="fa-fw iconfont icon-zhifeiji"></i><span> 二次元</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw iconfont icon-xiangce"></i><span> 画廊</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyu"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/charts/"><i class="fa-fw iconfont icon-tongjichaxun"></i><span> 统计</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw iconfont icon-liuyan"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/random/"><i class="fa-fw iconfont icon-suiji"></i><span> 随便逛逛</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Coursera Nand2Tetris：依据基本原理构建现代计算机：从与非门到俄罗斯方块</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-28T00:17:22.000Z" title="发表于 2023-08-28 08:17:22">2023-08-28</time><span class="post-meta-separator">|</span><svg class="meta_icon post-ui-icon" style="width:13px;height:13px;position:relative;top:2px"><use xlink:href="#icon-gengxin"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-23T06:27:49.000Z" title="更新于 2024-11-23 14:27:49">2024-11-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><a class="faa-parent animated-hover"></a><svg class="meta_icon post-ui-icon" style="width:13px;height:13px;position:relative;top:2px"><use xlink:href="#icon-fenlei"></use></svg><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-word"></use></svg><span class="post-meta-label">总字数:</span><span class="word-count">6255</span><span class="post-meta-separator">|</span><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="布尔函数和逻辑门-Boolean-Functions-and-Gate-Logic">布尔函数和逻辑门 Boolean Functions and Gate Logic</h2>
<h3 id="布尔逻辑-Boolean-Logic">布尔逻辑 Boolean Logic</h3>
<p>与或非</p>
<h3 id="布尔函数合成-Boolean-Functions-Synthesis">布尔函数合成 Boolean Functions Synthesis</h3>
<p>不同的布尔函数能表达相同的意思</p>
<p>所有布尔函数都可以用“与或非”表示</p>
<p>进一步，都可以用“与非”表示 <code>(x OR y) = NOT(NOT(x) AND NOT(y))</code></p>
<p>更进一步，可以用 <code>NAND</code> （<code>AND</code> 的否定）表示（<code>NOR</code> 也可以）：</p>
<ul>
<li><code>NOT(x) = (x NAND x)</code></li>
<li><code>(x AND y) = NOT(x NAND y)</code></li>
</ul>
<p>故可以仅使用 <code>NAND</code> 构造整个逻辑</p>
<h3 id="逻辑门-Logic-Gates">逻辑门 Logic Gates</h3>
<p>基本逻辑门，复合逻辑门</p>
<p>将复合逻辑门看作黑盒，关心接口，不关心实现</p>
<h3 id="硬件描述语言-Hardware-Description-Language">硬件描述语言 Hardware Description Language</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs HDL">// 接口<br>CHIP Xor &#123;<br>    IN a, b;<br>    OUT out;<br><br>    PARTS:<br>    // 实现<br>    Not(in=a, out=nota);<br>    Not(in=b, out=notb);<br>    And(a=a, b=notb, out=aAndNotb);<br>    And(a=b, b=nota, out=bAndNota);<br>    Or(a=aAndNotb, b=bAndNota, out=out);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>HDL 是一种函数式语言</li>
<li>HDL 的顺序不重要</li>
<li>想要使用芯片，必须了解其接口，如 <code>Not(in= , out= )</code></li>
<li><code>partName(a=a, out=out)</code> 之类的写法很常见</li>
</ul>
<p>常见的 HDL：VHDL，Verilog</p>
<h3 id="硬件模拟-Hardware-Simulation">硬件模拟 Hardware Simulation</h3>
<p>老师专门为该课程编写的一个程序，用于测试。虽然简陋，但五脏俱全，设计非常精巧</p>
<p>在实际的硬件开发中，一般分两种岗位：</p>
<ul>
<li>系统架构师</li>
<li>开发者</li>
</ul>
<p>架构师决定使用的芯片，对于每块芯片，架构师创造：</p>
<ul>
<li>API</li>
<li>测试脚本</li>
<li>比较文件</li>
</ul>
<p>开发者根据这些要求制作</p>
<h3 id="多比特总线-Multi-bit-Buses">多比特总线 Multi-bit Buses</h3>
<p>使用起来类似数组</p>
<p>支持分成子总线，如 <code>a[0..7]=lsb, a[8..15]=msb</code></p>
<p>注意，<code>a[0]</code> 表示最右边的位</p>
<h2 id="布尔代数和-ALU-Boolean-Arithmetic-and-the-ALU">布尔代数和 ALU Boolean Arithmetic and the ALU</h2>
<h3 id="二进制数字-Binary-Numbers">二进制数字 Binary Numbers</h3>
<p>二进制的表示，与十进制的转换等</p>
<h3 id="二进制加法-Binary-Addition">二进制加法 Binary Addition</h3>
<p>半加器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs HDL">CHIP HalfAdder &#123;<br>    IN a, b;    // 1-bit inputs<br>    OUT sum,    // Right bit of a + b<br>        carry;  // Left bit of a + b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>全加器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs HDL">CHIP FullAdder &#123;<br>    IN a, b, c;  // 1-bit inputs<br>    OUT sum,     // Right bit of a + b + c<br>        carry;   // Left bit of a + b + c<br>&#125;<br></code></pre></td></tr></table></figure>
<p>16 位加法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs HDL">CHIP Add16 &#123;<br>    IN a[16], b[16];<br>    OUT out[16];<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="负数-Negative-Numbers">负数 Negative Numbers</h3>
<p>将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord mathnormal">x</span></span></span></span> 表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">2^n-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>，化简得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">1 + (2^n - 1) - x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>，即取反加一</p>
<p>保证了正负零一致</p>
<h3 id="算术逻辑单元-ALU">算术逻辑单元 ALU</h3>
<p>计算两个输入的函数，并输出结果</p>
<p>接受一些控制位：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs HDL">if (zx == 1) set x = 0     // 16-bit constant<br><br>if (nx == 1) set x = !x    // bitwise not<br><br>if (zy == 1) set y = 0     // 16-bit constant<br><br>if (ny == 1) set y = !y    // bitwise not<br><br>if (f == 1)  set out = x + y  // integer 2&#x27;s complement addition<br><br>if (f == 0)  set out = x &amp; y  // bitwise and<br><br>if (no == 1) set out = !out  // bitwise no<br></code></pre></td></tr></table></figure>
<p>除了结果外，还有两个位输出一些有用的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs HDL">if (out == 0) set zr = 1<br><br>if (out &lt; 0) set ng = 1<br></code></pre></td></tr></table></figure>
<p>通过那些控制位，可以实现计算</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo separator="true">,</mo><mi>x</mi><mo>−</mo><mi>y</mi><mo separator="true">,</mo><mi>y</mi><mo>−</mo><mi>x</mi><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mo>−</mo><mi>x</mi><mo separator="true">,</mo><mo>−</mo><mi>y</mi><mo separator="true">,</mo><mo stretchy="false">!</mo><mi>x</mi><mo separator="true">,</mo><mo stretchy="false">!</mo><mi>y</mi><mo separator="true">,</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>x</mi><mi mathvariant="normal">&amp;</mi><mi>y</mi><mo separator="true">,</mo><mi>x</mi><mi mathvariant="normal">∥</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">x+y, x-y, y-x, 0, 1, -1, x, y, -x, -y, !x, !y, x+1, y+1, x-1, y-1, x\&amp;y, x\|y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mclose">!</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mclose">!</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mord">&amp;</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mord">∥</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></p>
<h2 id="内存-Memory">内存 Memory</h2>
<h3 id="序列逻辑-Sequential-Logic">序列逻辑 Sequential Logic</h3>
<p>把时间离散化，可以忽略延迟</p>
<p>组合逻辑：<code>out[t] = function(in[t])</code></p>
<p>序列逻辑：<code>state[t] = function(state[t-1])</code></p>
<h3 id="触发器-Flip-Flops">触发器 Flip Flops</h3>
<p>有两种状态：记忆 0 和记忆 1</p>
<p>时钟数据触发器（DFF）：<code>out[t] = in[t-1]</code></p>
<p>所以序列逻辑的实现如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E5%BA%8F%E5%88%97%E9%80%BB%E8%BE%91%E5%AE%9E%E7%8E%B0.webp" alt="序列逻辑实现"></p>
<p>如果是时钟，则组合逻辑为 +1</p>
<p>1 bit 的寄存器，load 控制读写</p>
<h3 id="内存单元-Memory-Units">内存单元 Memory Units</h3>
<p>最基本的内存元素：register</p>
<ul>
<li>输入数据长度 w</li>
</ul>
<p>RAM 的抽象：</p>
<ul>
<li>n 个寄存器序列</li>
<li>每次只有一个寄存器选中</li>
<li>地址长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">k = \log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span></span></span></span></li>
<li>RAM 就是一个有时钟表现的序列芯片</li>
</ul>
<p>随机访问：无论 RAM 大小如何，每个寄存器都可以在相同的时间被访问</p>
<h3 id="计时器-Counters">计时器 Counters</h3>
<p>因为计算机需要跟踪获取的指令并执行下一个，此控制可以通过程序计时器实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs HDL">CHIP PC &#123;<br>    IN in[16],load,inc,reset;<br>    OUT out[16];<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="机器语言-Machine-Language">机器语言 Machine Language</h2>
<p>​</p>
<h3 id="元素-Elements">元素 Elements</h3>
<p>内存层次结构，CPU 中有寄存器</p>
<p>控制流，如循环</p>
<h3 id="黑客计算机和机器语言-The-Hack-Computer-and-Machine-Language">黑客计算机和机器语言 The Hack Computer and Machine Language</h3>
<p>构成：</p>
<ul>
<li>数据内存 RAM</li>
<li>指令内存 ROM</li>
<li>CPU</li>
<li>指令、数据、地址总线</li>
</ul>
<p>三个寄存器：</p>
<ul>
<li>D 保存一个 16 bit 的值</li>
<li>A 保存一个 16 bit 的值</li>
<li>M 代表地址为 A 的 16 bit RAM 寄存器</li>
</ul>
<p>A 指令：<code>@value</code>，其中 <code>value</code> 是一个非负十进制常数或一个代表常数的符号</p>
<p>效果：</p>
<ul>
<li>将 A 寄存器设为 <code>value</code></li>
<li>将 RAM[A] 变成选定的 RAM 寄存器</li>
</ul>
<p>C 指令：<code>dest = comp ; jump</code> 其中 <code>dest</code> 和 <code>jump</code> 是可选的</p>
<ul>
<li><code>comp = 0, 1, -1, D, A, ...</code></li>
<li><code>dest = null, M, D, MD, A, AM, AD, AMD</code></li>
<li><code>jump = null, JGT, JEQ, JGE, JLT, JNE, JLE, JMP</code></li>
</ul>
<h3 id="黑客语言详述-Hack-Language-Specification">黑客语言详述 Hack Language Specification</h3>
<p>A 指令对应二进制数</p>
<p>C 指令分为三段，一一对应</p>
<h3 id="输入-输出-Input-Output">输入-输出 Input-Output</h3>
<p>屏幕内存映射：</p>
<p>将像素 <code>(row, col)</code> 开关：</p>
<ul>
<li><code>word = Screen[32*row +col/16]</code></li>
<li><code>word = RAM[16384 + 32*row + col/16]</code></li>
<li>将 <code>word</code> 的 <code>(col % 16)</code> 位变为 0 或 1</li>
<li>将 <code>word</code> 放到 RAM 中</li>
</ul>
<p>键盘内存映射：</p>
<p>当键被按下，代码出现在其中，为相应的 ASCII 码；若没有键被按下，则为 0</p>
<h3 id="黑客编程-Hack-Programming">黑客编程 Hack Programming</h3>
<h4 id="处理寄存器和内存">处理寄存器和内存</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Hack">// RAM[17] = 10<br>@10<br>D=A<br>@17<br>M=D<br></code></pre></td></tr></table></figure>
<p>由于数字和内存写法一致，可采用以下写法区分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Hack">// RAM[17] = 10<br>@10<br>D=A<br>@R17<br>M=D<br></code></pre></td></tr></table></figure>
<p>还有一些特殊的记号，如 <code>SCREEN</code>,<code>KBD</code> 等</p>
<p>终止程序：写一个死循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs hack">@END<br>0;JMP<br></code></pre></td></tr></table></figure>
<h4 id="分支">分支</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs hack">// if R0 &gt; 0<br>//      R1 = 1<br>// else<br>//      R1 = 0<br>    @R0<br>    D = M<br><br>    @POSITIVE<br>    D;JGT<br><br>    @R1<br>    M = 0<br>    @END<br>    0; JMP<br><br>(POSITIVE)<br>    @R1<br>    M = 1<br><br>(END)<br>    @END<br>    0; JMP<br></code></pre></td></tr></table></figure>
<h4 id="变量">变量</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">// temp = R1<br>@R1<br>D = M<br>@temp<br>M = D<br></code></pre></td></tr></table></figure>
<h4 id="迭代">迭代</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs hack">// RAM[1] = 1 + 2 + ... + n<br>@R0<br>D = M<br>@n<br>M = D<br>@i<br>M = 1<br>@sum<br>M = 0<br>(LOOP)<br>    @i<br>    D = M<br>    @n<br>    D=D-M<br>    @STOP<br>    D;JGT // if i &gt; n goto STOP<br><br>    @sum<br>    D = M<br>    @i<br>    D = D + M<br>    @sum<br>    M = D // sum = sum + 1<br>    @i<br>    M = M + 1 // i = i + 1<br>    @LOOP<br>    0; JMP<br><br>(STOP)<br>    @sum<br>    D = M<br>    @R1<br>    M = D // RAM[1] = sum<br><br>(END)<br>    @END<br>    0; JMP<br></code></pre></td></tr></table></figure>
<h4 id="指针">指针</h4>
<p>需要用指针访问内存时，使用 <code>A=M</code>，如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs hack">@i<br>A = D + M<br>M = -1<br></code></pre></td></tr></table></figure>
<h2 id="计算机结构-Computer-Architecture">计算机结构 Computer Architecture</h2>
<h3 id="冯诺依曼结构-Von-Neumann-Architecture">冯诺依曼结构 Von Neumann Architecture</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84.webp" alt="冯诺依曼结构"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E4%BF%A1%E6%81%AF%E6%B5%81.webp" alt="信息流"></p>
<h3 id="获取-执行循环-The-Fetch-Execute-Cycle">获取-执行循环 The Fetch-Execute Cycle</h3>
<p>基本 CPU 循环：从程序内存中<strong>获取</strong>一个指令并<strong>执行</strong>它</p>
<p>通过 PC 控制指令的顺序执行或跳出</p>
<p>程序和数据存在一起，可能产生冲突，其中一个解决方法是用多路复用器：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E6%8C%87%E4%BB%A4%E5%AF%84%E5%AD%98%E5%99%A8.webp" alt="指令寄存器"></p>
<p>但是这里使用的是简单的将程序和数据放在内存的不同部分</p>
<h3 id="中央处理器-Central-Processing-Unit">中央处理器 Central Processing Unit</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/CPU%E6%8E%A5%E5%8F%A3.webp" alt="CPU接口"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/CPU%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.webp" alt="CPU内部结构"></p>
<p>指令分为 A 和 C 两种</p>
<p>具体的控制位详见代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs hack">CHIP CPU &#123;<br><br>    IN  inM[16],         // M value input  (M = contents of RAM[A])<br>        instruction[16], // Instruction for execution<br>        reset;           // Signals whether to re-start the current<br>                         // program (reset==1) or continue executing<br>                         // the current program (reset==0).<br><br>    OUT outM[16],        // M value output<br>        writeM,          // Write to M?<br>        addressM[15],    // Address in data memory (of M)<br>        pc[15];          // address of next instruction<br><br>    PARTS:<br>    // Put your code here:<br>    // 第一个 Mux16<br>    Mux16(a=instruction, b=ALUout, sel=instruction[15], out=ia);<br><br>    // ARegister<br>    And(a=instruction[15], b=instruction[5], out=a1);<br>    Not(in=instruction[15], out=a2);<br>    Or(a=a1, b=a2, out=inARegister);<br>    ARegister(in=ia, load=inARegister, out=ARegisterOut, out[0..14]=addressM);<br><br>    // 第二个 Mux16<br>    And(a=instruction[15], b=instruction[12], out=mux2);<br>    Mux16(a=ARegisterOut, b=inM, sel=mux2, out=ALUin);<br><br>    // DRegister<br>    And(a=instruction[15], b=instruction[4], out=inDRegister);<br>    DRegister(in=ALUout, load=inDRegister, out=DRegisterOut);<br><br>    // ALU<br>    And(a=instruction[15], b=instruction[11], out=zx);<br>    And(a=instruction[15], b=instruction[10], out=nx);<br>    And(a=instruction[15], b=instruction[9], out=zy);<br>    And(a=instruction[15], b=instruction[8], out=ny);<br>    And(a=instruction[15], b=instruction[7], out=f);<br>    And(a=instruction[15], b=instruction[6], out=no);<br>    ALU(x=DRegisterOut, y=ALUin, zx=zx, nx=nx, zy=zy, ny=ny, f=f, no=no, out=ALUout, out=outM, zr=zr, ng=ng);<br><br>    // write<br>    And(a=instruction[15], b=instruction[3], out=writeM);<br><br>    // PC<br>    // 分解出大于、小于、等于<br>    And(a=instruction[15], b=instruction[0], out=greater);<br>    And(a=instruction[15], b=instruction[1], out=equal);<br>    And(a=instruction[15], b=instruction[2], out=less);<br><br>    // 正数<br>    Not(in=ng, out=nng);<br>    Not(in=zr, out=nzr);<br>    And(a=nng, b=nzr, out=ps);<br><br>    // 分别判断是否满足条件<br>    And(a=less, b=ng, out=isLess);<br>    And(a=equal, b=zr, out=isEqual);<br>    And(a=greater, b=ps, out=isGreater);<br><br>    Or(a=isLess, b=isEqual, out=part);<br>    Or(a=part, b=isGreater, out=load);<br><br>    PC(in=ARegisterOut, load=load, inc=true, reset=reset, out[0..14]=pc);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="黑客计算机-The-Hack-Computer">黑客计算机 The Hack Computer</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E5%86%85%E5%AD%98%E5%AE%9E%E7%8E%B0.webp" alt="内存实现"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E9%BB%91%E5%AE%A2%E8%AE%A1%E7%AE%97%E6%9C%BA.webp" alt="黑客计算机"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E8%AF%BE%E7%A8%8B%E7%BB%93%E6%9E%84.webp" alt="课程结构"></p>
<h2 id="汇编器-Assembler">汇编器 Assembler</h2>
<h3 id="汇编语言和汇编器-Assembly-Languages-and-Assemblers">汇编语言和汇编器 Assembly Languages and Assemblers</h3>
<p>汇编器是软件，是硬件上的第一层软件</p>
<p>重复直到文件结束：</p>
<ul>
<li>读取下一个汇编语言命令</li>
<li>分成不同域</li>
<li>对每个域查找二进制代码</li>
<li>把代码组合成一个简单的机器语言命令</li>
<li>输出机器语言命令</li>
</ul>
<p>用符号表将变量名和预先定义的常量映射为数字地址</p>
<h3 id="黑客汇编语言：一个翻译者的立场-The-Hack-Assembly-Language-A-Translator-s-Perspective">黑客汇编语言：一个翻译者的立场 The Hack Assembly Language: A Translator's Perspective</h3>
<ul>
<li>
<p>空格：</p>
<ul>
<li>空行 / 缩进</li>
<li>行内注释</li>
<li>行间注释</li>
</ul>
</li>
<li>
<p>指令：</p>
<ul>
<li>
<p>A 指令</p>
</li>
<li>
<p>C 指令</p>
</li>
</ul>
</li>
<li>
<p>符号：</p>
<ul>
<li>预先定义的符号</li>
<li>标签声明 <code>(label)</code></li>
<li>变量声明 <code>@variableName</code></li>
</ul>
</li>
</ul>
<h3 id="汇编过程：处理指令-The-Assembly-Process-Handling-Instructions">汇编过程：处理指令 The Assembly Process: Handling Instructions</h3>
<p>A 指令 <code>@value</code>：</p>
<ul>
<li>如果是一个数字，则生成等价的 15 bit 二进制常数</li>
<li>如果是符号，则见后</li>
</ul>
<p>C 指令：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E7%BF%BB%E8%AF%91C%E6%8C%87%E4%BB%A4.webp" alt="翻译C指令"></p>
<h3 id="汇编过程：处理符号-The-Assembly-Process-Handling-Symbols">汇编过程：处理符号 The Assembly Process: Handling Symbols</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E7%AC%A6%E5%8F%B7%E8%A1%A8.webp" alt="一图胜千言"></p>
<h3 id="开发一个黑客汇编器：建议软件结构-Developing-a-Hack-Assembler-Proposed-Software-Architecture">开发一个黑客汇编器：建议软件结构 Developing a Hack Assembler: Proposed Software Architecture</h3>
<p><code>parsing</code></p>
<p><code>coding</code></p>
<h2 id="虚拟机-I：栈算术-Virtual-Machine-I-Stack-Arithmetic">虚拟机 I：栈算术 Virtual Machine I: Stack Arithmetic</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E8%AF%BE%E7%A8%8B%E8%AE%A1%E5%88%92.webp" alt="课程计划"></p>
<h3 id="程序编译预览-Program-Compilation-Preview">程序编译预览 Program Compilation Preview</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E4%B8%A4%E5%B1%82%E7%BC%96%E8%AF%91.webp" alt="两层编译"></p>
<h3 id="虚拟机抽象：栈-VM-Abstraction-the-Stack">虚拟机抽象：栈 VM Abstraction: the Stack</h3>
<p><code>push</code>,<code>pop</code> 操作</p>
<p>对栈使用函数：</p>
<ul>
<li>pop 参数</li>
<li>计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></li>
<li>push 结果</li>
</ul>
<h3 id="虚拟机抽象：内存段-VM-Abstraction-Memory-Segments">虚拟机抽象：内存段 VM Abstraction: Memory Segments</h3>
<p>因为变量有多种，故内存也有分段：</p>
<p><code>push segment i</code>：</p>
<ul>
<li><code>segment</code>：argument, local, static, constant, this, that, pointer, temp</li>
<li><code>i</code>：非负正数（该内存段中的地址）</li>
</ul>
<p><code>pop segment i</code>：</p>
<ul>
<li><code>segment</code>：argument, local, static, this, that, pointer, temp</li>
<li><code>i</code>：非负正数（该内存段中的地址）</li>
</ul>
<h3 id="虚拟机实现：栈-VM-Implementation-the-Stack">虚拟机实现：栈 VM Implementation: the Stack</h3>
<p>指针操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">D = *p     // D = 23<br><br>p--        // RAM[0] = 256<br>D = *p     // D = 19<br></code></pre></td></tr></table></figure>
<p>简单来说，就是 <code>push constant i</code> -&gt; <code>*SP = i, SP++</code></p>
<h3 id="虚拟机实现：内存段-VM-Implementation-Memory-Segments">虚拟机实现：内存段 VM Implementation: Memory Segments</h3>
<p>对于 <code>local</code> 之类，存储一个指向该内存段首地址的指针 <code>LCL</code></p>
<p><code>pop local i</code> -&gt; <code>addr = LCL + i, SP--, *addr = *SP</code></p>
<p><code>push local i</code> -&gt; <code>addr = LCL + i, *SP = *addr, SP++</code></p>
<p><code>argument</code>, <code>this</code>, <code>that</code> 同理</p>
<p><code>const</code> 比较简单：<code>push constant i</code> -&gt; <code>*SP = i, SP++</code></p>
<p><code>static</code> 要存在全局，所以 <code>static i</code> -&gt; <code>Foo.i</code></p>
<p><code>temp</code> 只有 8 个，<code>push temp i</code> -&gt; <code>addr = 5 + i, *SP = *addr, SP++</code>，<code>pop</code> 同理</p>
<p><code>pointer</code> 用于区分 this 和 that：<code>push pointer 0/1</code> -&gt; <code>*SP = THIS/THAT, SP++</code></p>
<h2 id="虚拟机-II：程序控制-Virtual-Machine-II-Program-Control">虚拟机 II：程序控制 Virtual Machine II: Program Control</h2>
<h3 id="程序控制-Program-Control">程序控制 Program Control</h3>
<p>分支控制：</p>
<ul>
<li><code>goto label</code></li>
<li><code>if-goto label</code></li>
<li><code>label label</code></li>
</ul>
<p>函数控制：</p>
<ul>
<li><code>call functionName nArgs</code></li>
<li><code>function functionName nVars</code></li>
<li><code>return</code></li>
</ul>
<h3 id="分支-Branching">分支 Branching</h3>
<p>其中 <code>if-goto label</code> 是当 <code>cond = pop</code> 时，跳转到 <code>label</code></p>
<h3 id="函数：抽象-Functions-Abstraction">函数：抽象 Functions: Abstraction</h3>
<p>从 caller 来看，相当于把参数转化为了一个结果</p>
<p>从 callee 来看，相当于创造了一个新的空间，<code>argument</code> 和 <code>local</code> 预先分配好了，栈起初是空的</p>
<p>故：</p>
<p><code>call</code>：</p>
<ul>
<li>把参数传递给被调函数</li>
<li>决定在 caller 代码中返回的地址</li>
<li>保存 caller 的返回地址，栈，内存段</li>
<li>跳到执行被调函数</li>
</ul>
<p><code>return</code>：</p>
<ul>
<li>返回计算出的值给 caller</li>
<li>循环利用被调函数使用的内存资源</li>
<li>恢复 caller 的栈和内存段</li>
<li>跳到 caller 代码的返回地址</li>
</ul>
<h3 id="函数调用和返回：实现预览-Function-Call-and-Return-Implementation-Preview">函数调用和返回：实现预览 Function Call and Return: Implementation Preview</h3>
<p>函数的调用链：栈</p>
<p>函数调用的三个过程对内存的操作</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/call.webp" alt="call"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/function.webp" alt="function"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/return.webp" alt="return"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E5%85%A8%E5%B1%80%E6%A0%88.webp" alt="全局栈实现了调用链"></p>
<h3 id="函数调用和返回：运行模拟-Function-Call-and-Return-Run-time-Simulation">函数调用和返回：运行模拟 Function Call and Return: Run-time Simulation</h3>
<h3 id="函数调用和返回：实现-Function-Call-and-Return-Implementation">函数调用和返回：实现 Function Call and Return: Implementation</h3>
<p>处理 <code>call functionName nArgs</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs vm">push returnAddress<br>push LCL<br>push ARG<br>push THIS<br>push THAT<br>ARG = SP-5-nArgs<br>LCL = SP<br>goto functionName<br>(returnAddress)<br></code></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/call%E5%AE%9E%E7%8E%B0.webp" alt="call实现"></p>
<p>处理 <code>function functionName nVars</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs vm">(functionName)<br>    repeat nVars times:<br>    push 0<br></code></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/function%E5%AE%9E%E7%8E%B0.webp" alt="function实现"></p>
<p>处理 <code>return</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs vm">endFrame = LCL<br>retAddr = *(endFrame - 5)<br>*ARG = pop()<br>SP = ARG + 1<br>THAT = *(endFrame - 1)<br>THIS = *(endFrame - 2)<br>ARG = *(endFrame - 3)<br>LCL = *(endFrame - 4)<br>goto retAddr<br></code></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/return%E5%AE%9E%E7%8E%B0.webp" alt="return实现"></p>
<h3 id="在黑客平台上的-VM-实现-VM-Implementation-on-the-Hack-Platform">在黑客平台上的 VM 实现 VM Implementation on the Hack Platform</h3>
<p>引导：</p>
<ul>
<li>
<p>VM 程序中其中一个叫 <code>Main.vm</code>，该文件中的一个函数叫 <code>main</code></p>
</li>
<li>
<p>当 VM 实现运行时，第一个执行无参数的函数 <code>Sys.init</code></p>
</li>
<li>
<p><code>Sys.init</code> 调用 <code>Main.main</code>，进入无限循环</p>
</li>
</ul>
<h2 id="高级语言-High-Level-Language">高级语言 High-Level Language</h2>
<h3 id="Jack-语言概论-The-Jack-Language-in-a-nutshell">Jack 语言概论 The Jack Language in a nutshell</h3>
<p>Jack 语言是类似 Java 的语言，面向对象，但不支持继承</p>
<p>必须有一个类 <code>Main</code>，其必须有 <code>main</code> 函数，程序的进入点是 <code>Main.main</code></p>
<p>Jack 中的 <code>Array</code> 是没有类型的</p>
<p>操作系统：</p>
<ul>
<li><code>Keyboard.readInt</code></li>
<li><code>Output.printString</code></li>
<li><code>Output.printInt</code></li>
</ul>
<p>数据类型：</p>
<ul>
<li>原始：
<ul>
<li><code>int</code></li>
<li><code>char</code></li>
<li><code>boolean</code></li>
</ul>
</li>
<li>类的类型：
<ul>
<li>操作系统：<code>Array</code>、<code>String</code></li>
<li>程序扩展</li>
</ul>
</li>
</ul>
<h3 id="基于对象编程-Object-Based-Programming">基于对象编程 Object-Based Programming</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">/** Represents the Fraction type and related operations. */<br>class Fraction &#123;<br>   field int numerator, denominator;  // field = property = member variable.<br><br>   /** Constructs a (reduced) fraction from the given numerator and denominator. */<br>   constructor Fraction new(int x, int y) &#123;<br>      let numerator = x;<br>      let denominator = y;<br>      do reduce();   // reduces the fraction<br>      return this;   // a constructor is expected to return a reference to the new object<br>   &#125;<br><br>   // Reduces this fraction.<br>   method void reduce() &#123;<br>      var int g;<br>      let g = Fraction.gcd(numerator, denominator);<br>      if (g &gt; 1) &#123;<br>         let numerator = numerator / g;<br>         let denominator = denominator / g;<br>      &#125;<br>      return;<br>   &#125;<br><br>   /** Accessors. */<br>   method int getNumerator() &#123; return numerator; &#125;<br>   method int getDenominator() &#123; return denominator; &#125;<br><br>   /** Returns the sum of this fraction and the other one. */<br>   method Fraction plus(Fraction other) &#123;<br>      var int sum;<br>      let sum = (numerator * other.getDenominator()) + (other.getNumerator() * denominator);<br>      return Fraction.new(sum, denominator * other.getDenominator());<br>   &#125;<br><br>   // More fraction-related methods (minus, times, div, etc.) can be added here.<br><br>   /** Disposes this fraction. */<br>   method void dispose() &#123;<br>      do Memory.deAlloc(this);  // uses an OS routine to recycle the memory held by the object<br>      return;<br>   &#125;<br><br>   /** Prints this fraction in the format x/y. */<br>   method void print() &#123;<br>      do Output.printInt(numerator);<br>      do Output.printString(&quot;/&quot;);<br>      do Output.printInt(denominator);<br>      return;<br>   &#125;<br><br>   // Computes the greatest common divisor of the given integers.<br>   function int gcd(int a, int b) &#123;<br>      var int r;<br>      while (~(b = 0)) &#123;             // applies Euclid&#x27;s algorithm<br>         let r = a - (b * (a / b));  // r = remainder of the integer division a/b<br>         let a = b; let b = r;<br>      &#125;<br>      return a;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>还有调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">// Computes the sum of 2/3 and 1/5.<br>class Main &#123;<br>   function void main() &#123;<br>      var Fraction a, b, c;<br>      let a = Fraction.new(2,3);<br>      let b = Fraction.new(1,5);<br>      let c = a.plus(b);  // Computes c = a + b<br>      do c.print();       // Prints &quot;13/15&quot;<br>      return;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>已经比较详细了，不必多说</p>
<p>注意几点：</p>
<ul>
<li><code>field</code> 相当于私有的成员变量</li>
<li><code>function</code> 相当于 Java 中的 <code>static</code> 函数</li>
<li><code>this</code> 是地址，<code>constructor</code> 必须显式返回 <code>this</code></li>
<li>任何函数都必须 <code>return</code>，其中 <code>void</code> 函数必须显式 <code>return</code></li>
<li>由于没有垃圾收集，所以必须显式 <code>dispose</code></li>
</ul>
<h3 id="列表处理-List-Processing">列表处理 List Processing</h3>
<p>定义：</p>
<ul>
<li><code>null</code></li>
<li>或一个元素 + list</li>
</ul>
<h3 id="Jack-语言规范：语法-Jack-Language-Specification-Syntax">Jack 语言规范：语法 Jack Language Specification: Syntax</h3>
<p>语法元素：</p>
<ul>
<li>空格，注释</li>
<li>关键字</li>
<li>符号</li>
<li>常数</li>
<li>标识符</li>
</ul>
<h3 id="Jack-语言规范：数据类型-Jack-Language-Specification-Data-Types">Jack 语言规范：数据类型 Jack Language Specification: Data Types</h3>
<p>类型转换：</p>
<ul>
<li>字符和整数可以相互转换</li>
<li>整数可赋值给数组名，被当成内存地址对待</li>
<li>一个对象可以转化为一个数组，反之亦然</li>
</ul>
<h3 id="Jack-语言规范：类-Jack-Language-Specification-Classes">Jack 语言规范：类 Jack Language Specification: Classes</h3>
<p>Jack 的标准库/OS 有 8 个类：<code>Math</code>、<code>String</code>、<code>Array</code>、<code>Output</code>、<code>Screen</code>、<code>Keyboard</code>、<code>Memory</code>、<code>Sys</code></p>
<h3 id="Jack-语言规范：方法-Jack-Language-Specification-Methods">Jack 语言规范：方法 Jack Language Specification: Methods</h3>
<p><code>let</code>：必须在赋值中使用：<code>let x = 0</code></p>
<p><code>do</code>：必须被用于在表达式外调用函数或方法：<code>do reduce()</code></p>
<p>语句的主体必须在括号内，即使只有一条语句</p>
<p>所有的子过程都必须以 <code>return</code> 结尾</p>
<p>运算符没有优先级：<code>2 + 3 * 4 = 20</code>，<code>2 + (3 * 4) = 14</code></p>
<p>弱类型</p>
<h3 id="使用-Jack-语言和-OS-来开发应用程序-Developing-Apps-using-the-Jack-Language-and-OS">使用 Jack 语言和 OS 来开发应用程序 Developing Apps using the Jack Language and OS</h3>
<p>文字输出：23 行，每行 64 个字符</p>
<p>详见官网的手册</p>
<h2 id="编译器-I：语法分析-Compiler-I-Syntax-Analysis">编译器 I：语法分析 Compiler I: Syntax Analysis</h2>
<h3 id="语法分析-Syntax-Analysis">语法分析 Syntax Analysis</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/Jack%E7%BC%96%E8%AF%91%E5%99%A8%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4.webp" alt="Jack编译器开发步骤"></p>
<h3 id="词汇分析-Lexical-Analysis">词汇分析 Lexical Analysis</h3>
<p>将输入的代码分解成一个个基本组成（<strong>tokens</strong>），如</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/tokenizer.webp" alt="tokenizer"></p>
<h3 id="语法-Grammars">语法 Grammars</h3>
<p><strong>语法</strong>是描述 tokens 是如何组合的规则，如</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/Jack%20grammar.webp" alt="Jack grammar"></p>
<h3 id="解析树-Parse-Trees">解析树 Parse Trees</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E8%A7%A3%E6%9E%90%E6%A0%91.webp" alt="解析树"></p>
<h3 id="解析器逻辑-Parser-Logic">解析器逻辑 Parser Logic</h3>
<ul>
<li>遵守规则的右边，解析对应的输入</li>
<li>如果右边是一个不终止的规则 xxx，则调用 <code>compileXXX</code></li>
<li>递归调用</li>
</ul>
<p>LL grammar：可以被递归下降的解析器没有回调解析（简单来说就是没有“歧义”）</p>
<p>LL(k) parser：需要看最多 k 个 tokens 才能确定规则的解析器</p>
<h3 id="Jack-语法-The-Jack-Grammar">Jack 语法 The Jack Grammar</h3>
<p>注意如果一个 token 是 varName 时，要向后看，因为可能有多种情况</p>
<h3 id="Jack-分析-The-Jack-Analysis">Jack 分析 The Jack Analysis</h3>
<p>当碰到极个别非终止元素（<code>type</code>、<code>class name</code>、<code>subroutine name</code>、<code>variable name</code>、<code>statement</code>、<code>subroutine call</code>）时，不需要标记，因为 <code>varName: identifier</code></p>
<h2 id="编译器-II：代码生成-Compiler-II-Code-Generation">编译器 II：代码生成 Compiler II: Code Generation</h2>
<h3 id="代码生成-Code-Generation">代码生成 Code Generation</h3>
<h3 id="处理变量-Handling-Variables">处理变量 Handling Variables</h3>
<p>在变量声明时，对类中的变量和函数中的变量分别生成一张符号表，注意任何函数符号表中都会自带一个 this 指针</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E5%8F%98%E9%87%8F%E5%90%8D%E7%AC%A6%E5%8F%B7%E8%A1%A8.webp" alt="符号表"></p>
<p>在变量使用时，先在子过程层级的符号表中查找，若找不到，则查找类层级</p>
<p>对于嵌套的作用域，可以把符号表连成一个链表</p>
<h3 id="处理表达式-Handling-Expressions">处理表达式 Handling Expressions</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E8%A1%A8%E8%BE%BE%E5%BC%8F.webp" alt="表达式"></p>
<p>可以看出，后缀表达式是最适合的</p>
<p>但是我们不需要建立表达式树，观察中缀表达式和后缀表达式的关系，可以得出：</p>
<p><code>codeWrite(exp):</code></p>
<ul>
<li>如果 <code>exp</code> 是整数 <code>n</code> -&gt; <code>push n</code></li>
<li>变量 <code>var</code> -&gt; <code>push var</code></li>
<li><code>exp1 op exp2</code> -&gt; <code>codeWrite(exp1); codeWrite(exp2); op</code></li>
<li><code>op exp</code> -&gt; <code>codeWrite(exp); op</code></li>
<li><code>f(exp1, exp2, ...)</code> -&gt; <code>codeWrite(exp1); codeWrite(exp1); ... call f</code></li>
</ul>
<p>注意：<em>再次重申 Jack 语言是没有操作符优先级的</em></p>
<h3 id="处理控制流-Handling-Flow-of-Control">处理控制流 Handling Flow of Control</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E7%BC%96%E8%AF%91if%E8%AF%AD%E5%8F%A5.webp" alt="编译if语句"></p>
<p><code>while</code> 则更简单：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E7%BC%96%E8%AF%91while%E8%AF%AD%E5%8F%A5.webp" alt="编译while语句"></p>
<p>注意 <em>处理多个 if-while 和嵌套 if-while</em></p>
<h3 id="处理对象：低层级方面-Handling-Objects-Low-Level-Aspects">处理对象：低层级方面 Handling Objects: Low-Level Aspects</h3>
<ul>
<li>高级 OO 程序创建和操作对象和数组</li>
<li>中级 VM 程序在虚拟内存段上操作</li>
<li>低级机器程序直接在 RAM 上操作</li>
</ul>
<p><strong>而编译的难题就在于建立桥梁</strong>：</p>
<ul>
<li>对象数据通过 <code>this</code> 段访问</li>
<li>数组数据通过 <code>that</code> 段访问</li>
<li>在使用这些段之前，必须先用 <code>pointer</code> 锚定</li>
</ul>
<h3 id="处理对象：构造-Handling-Objects-Construction">处理对象：构造 Handling Objects: Construction</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E7%BC%96%E8%AF%91%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.webp" alt="编译构造函数"></p>
<h3 id="处理对象：操作-Handling-Objects-Manipulation">处理对象：操作 Handling Objects: Manipulation</h3>
<p>将 OO 风格转为过程风格：<code>p1.distance(p2)</code> -&gt; <code>distance(p1, p2)</code></p>
<p>因为每个方法都需要访问对象的 <code>fields</code>，即通过 <code>this i</code> 访问第 <code>i</code> 个 <code>field</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E7%BC%96%E8%AF%91%E6%96%B9%E6%B3%95.webp" alt="编译方法"></p>
<p>对于 <code>void</code> 方法，返回一个 <code>constant 0</code>，并在调用后立刻 <code>pop temp 0</code> 释放掉</p>
<h3 id="处理数组-Handling-Arrays">处理数组 Handling Arrays</h3>
<p>将数组名赋予内存地址，使用 <code>that</code> 访问数组的位置，如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs vm">// arr[2] = 17<br>push arr<br>push 2<br>add<br>pop pointer 1<br>push 17<br>pop that 0<br></code></pre></td></tr></table></figure>
<p>注意 <em>和对象不同，that 指向的是数组中的某一个元素</em></p>
<p>对于更复杂一些的情况（例如两边都有数组），则使用 <code>temp</code> 暂存右边的值，所以正确的写法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">//arr[expression1]=expression2,<br>push arr<br>计算并 push expression1 的值<br>add<br>计算并 push expression2 的值<br>pop temp 0 // temp 0 = expression2, 栈顶值为 arr[expression1] 的地址<br>pop pointer1<br>push temp 0<br>pop that e<br></code></pre></td></tr></table></figure>
<p>这个方案也适用于多重数组嵌套</p>
<h3 id="对虚拟机的标准映射-Standard-Mapping-Over-the-Virtual-Machine">对虚拟机的标准映射 Standard Mapping Over the Virtual Machine</h3>
<p>文件和子过程：</p>
<ul>
<li>每个文件 <code>fileName.jack</code> 被编译为 <code>fileName.vm</code></li>
<li>每个 <code>fileName.jack</code> 中的子过程 <code>subName</code> 被编译为 VM 函数 <code>fileName.subName</code></li>
<li>一个 k 个参数的 <code>constructor</code> 或 <code>function</code> 被编译为有 k 个参数的 VM 函数</li>
<li>一个有 k 个参数的 Jack <code>method</code>被编译为有 k+1 个参数的 VM 函数</li>
</ul>
<p>变量：</p>
<ul>
<li><code>local</code> 变量映射到虚拟段 <code>local</code></li>
<li><code>argument</code> 变量映射到虚拟段 <code>argument</code></li>
<li><code>static</code> 变量映射到虚拟段 <code>static</code></li>
<li><code>field</code> 变量：
<ul>
<li>假设 <code>pointer 0</code> 为 <code>this</code> 对象</li>
<li>该对象的第 i 个 field 映射到 <code>this i</code></li>
</ul>
</li>
</ul>
<p>数组：</p>
<ul>
<li>将 <code>pointer 1</code> 设为地址 <code>arr + i</code></li>
<li>通过 <code>this 0</code> 访问</li>
</ul>
<p>编译子过程：</p>
<ul>
<li><code>method</code>：设置 <code>this</code> 段的地址为 <code>argument 0</code></li>
<li><code>constructor</code>：
<ul>
<li>对新的对象分配空间，设置 <code>this</code> 为新的对象地址</li>
<li>返回 <code>this</code></li>
</ul>
</li>
<li><code>void</code>：返回 <code>constant 0</code></li>
</ul>
<p>调用子过程：将参数放入栈中，调用子过程</p>
<ul>
<li>如果是 <code>method</code>，则先将该对象的引用放入，再放入参数并调用</li>
<li>如果是 <code>void</code>，则在结束后 <code>pop</code> 掉</li>
</ul>
<p>常数：</p>
<ul>
<li><code>null</code> -&gt; <code>constant 0</code></li>
<li><code>false</code> -&gt; <code>constant 0</code></li>
<li><code>true</code> -&gt; <code>constant -1</code></li>
</ul>
<h2 id="操作系统-Operating-System">操作系统 Operating System</h2>
<h3 id="简介">简介</h3>
<p>包括的内容：</p>
<ul>
<li>游戏时间分析</li>
<li>资源管理</li>
<li>处理输入</li>
<li>向量图形</li>
<li>文字输出</li>
<li>类型转换</li>
<li>字符串处理</li>
</ul>
<h3 id="效率很重要-Efficiency-Matters">效率很重要 Efficiency Matters</h3>
<p>对于乘法，使用二进制的乘法竖式计算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">// 计算 x * y<br>multiply(x, y):<br>    sum = 0<br>    shiftedX = x<br>    for i = 0 ... w - 1 do<br>        if ((y 的第 i 位) == 1)<br>            sum = sum + shiftedX<br>        shiftedX = shiftedX * 2<br>    return sum<br></code></pre></td></tr></table></figure>
<ul>
<li>
<p>该算法正比于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>=</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">w = \log_2 N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p>
</li>
<li>
<p>对于负数，该算法同样有效</p>
</li>
<li>
<p>对于溢出，该算法总是返回正确答案 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">\mod 2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span></p>
</li>
</ul>
<p>对于其中的获取第 i 位的操作，定义一个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">function boolean bit(int x, int i)<br></code></pre></td></tr></table></figure>
<p>初始化 <code>Math</code> 类时生成一个数组，存入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">2^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span>，使用该数组来实现 <code>bit(x, i)</code></p>
<h3 id="数学操作-Mathematical-Operations">数学操作 Mathematical Operations</h3>
<p>对于除法，一种方法同样是模拟除法的竖式</p>
<p>这里给出第二种方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">// 计算 x / y<br>divide(x, y):<br>    if (y &gt; x) return 0<br>    q = divide(x, 2 * y)<br>    if ((x - 2 * q * y) &lt; y)<br>        return 2 * q<br>    else<br>        return 2 * q + 1<br></code></pre></td></tr></table></figure>
<p>该算法的基本思想是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">/</mi><mn>7</mn><mo>=</mo><mn>2</mn><mo>∗</mo><mo stretchy="false">(</mo><mn>50</mn><mi mathvariant="normal">/</mi><mn>7</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mo>∗</mo><mo stretchy="false">(</mo><mn>2</mn><mo>∗</mo><mo stretchy="false">(</mo><mn>25</mn><mi mathvariant="normal">/</mi><mn>7</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">100 / 7 = 2 * (50 / 7) = 2 * (2 * (25 / 7)) = ...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">/</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mord">0</span><span class="mord">/</span><span class="mord">7</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord">5</span><span class="mord">/</span><span class="mord">7</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.10556em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></p>
<ul>
<li>
<p>运行时间正比于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">\log_2 N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p>
</li>
<li>
<p>处理负数时，计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>x</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">∣</mi><mi>y</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|x| / |y|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord">/</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">∣</span></span></span></span>，再设置符号</p>
</li>
<li>
<p>处理溢出：当 y 变成负数时，溢出可以被检测到，故将第一句改为 <code>if (y &gt; x || y &lt; 0) return 0</code></p>
</li>
</ul>
<p>平方根：反函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">x^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 很容易计算，故策略为找到一个使得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>y</mi><mn>2</mn></msup><mo>≤</mo><mi>x</mi><mo>&lt;</mo><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">y^2 ≤ x &lt; (y+1)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>，通过二分搜索 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>…</mo><msup><mn>2</mn><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 … 2^{n/2} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9713299999999999em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">// 计算函数 y = sqrt(x)<br>sqrt(x):<br>    y = 0<br>    for j = n / 2 - 1 ... 0 do<br>        if (y + 2^j)^2 &lt;= x then y = y + 2^j<br>    return y<br></code></pre></td></tr></table></figure>
<p>对于溢出，将 <code>(y + 2^j)^2 &lt;= x</code> 改为 <code>(y + 2^j)^2 &lt;= x &amp;&amp; (y + 2^j)^2 &gt; 0</code></p>
<h3 id="内存访问-Memory-Access">内存访问 Memory Access</h3>
<p>直接设置数组名指针为 0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">class Memory &#123;<br>    static array ram;<br><br>    function void init() &#123;<br>        let ram = 0;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="堆管理-Heap-Management">堆管理 Heap Management</h3>
<p>将可用的内存段连成一个链表</p>
<ul>
<li><code>alloc(size)</code>：寻找合适大小的内存段，将其从段中移除，交给客户</li>
<li><code>dealloc(object)</code>：将该对象连到链表中</li>
</ul>
<p>当然，这样做到最后就会有很多碎片内存段</p>
<p>实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">static Array heap;<br>let heap = 2048<br></code></pre></td></tr></table></figure>
<p>使用 <code>heap</code> 数组实现，地址 <code>arr</code> 的内存段的 <code>next</code> 和 <code>size</code> 可以通过 <code>heap[adr - 1]</code> 和 <code>heap[addr - 2]</code> 实现</p>
<h3 id="图形-Graphics">图形 Graphics</h3>
<p>向量图保存图形的画法，放大后不失真；位图保存像素，放大后失真</p>
<p>设置某一个像素颜色的命令与之前的类似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">function void drawPixel(int x, int y) &#123;<br>    address = 32 * y + x / 16<br>    value = Memory.peek[16384 + address]<br>    设置 value 的第 (x % 16) 位为当前颜色<br>    do Memory.poke(address, value)<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="画线-Line-Drawing">画线 Line Drawing</h3>
<p>大概是近似方格覆盖线，其中决定是向上覆盖方格还是向右覆盖方格由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>b</mi><mi>a</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{b}{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{dy}{dx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 的大小关系决定</p>
<p>但每次计算太耗时，令 <code>diff = a * dy - b * dx</code>，观察每次 <code>a</code> 和 <code>b</code> 的改变，可以得出 <code>diff</code> 的改变</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">a = 0; b = 0; diff = 0;<br>while ((a &lt;= dx) &amp;&amp; (b &lt;= dy))<br>    drawPixel(x + a, y + b);<br>    if (diff &lt; 0) &#123;a = a + 1; diff = diff + dy;&#125;<br>    else &#123;b = b + 1; diff = diff - dx;&#125;<br></code></pre></td></tr></table></figure>
<p>画圆：将实心圆转化为从上往下画一条条水平线，线的左右端点位置可以通过勾股定理得出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">drawCircle(x, y, r)<br>    for each dy = -r to r do:<br>        drawLine(x - sqrt(r^2 - dy^2), y + dy, x + sqrt(r^2 - dy^2), y + dy)<br></code></pre></td></tr></table></figure>
<p>空心圆则只需要画两个像素点即可</p>
<p>注意：</p>
<ul>
<li>
<p>屏幕的原点在左上角</p>
</li>
<li>
<p>将算法推广到能画任何方向的线段</p>
</li>
<li>
<p>对于水平和竖直方向的线做特殊优化</p>
</li>
<li>
<p>对于溢出，限制 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>≤</mo><mn>181</mn></mrow><annotation encoding="application/x-tex">r ≤ 181</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">8</span><span class="mord">1</span></span></span></span></p>
</li>
</ul>
<h3 id="处理文字输出-Handling-Textual-Output">处理文字输出 Handling Textual Output</h3>
<ul>
<li>每个字符占据了固定大小的 11px 高，8px 宽的框架</li>
<li>右边有两个空列，底部有一个空行</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E5%AD%97%E7%AC%A6%E9%9B%86.webp" alt="字符集"></p>
<p>在初始化时预先加载到内存中</p>
<p>光标：</p>
<ul>
<li><code>newLine</code>：移动光标到下一行的开头</li>
<li><code>backspace</code>：光标左移一列</li>
<li>字符：显示字符，光标右移一列</li>
</ul>
<h3 id="输入-Input">输入 Input</h3>
<p>比较简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">keyPressed():<br>    if 键盘被按下:<br>        return key 的代码<br>    else<br>        return 0<br><br>readChar():<br>    显示光标<br>    // 等待直到一个键被按下<br>    while (keyPressed() == 0):<br>        什么都不做<br>    c = 当前按下的键<br>    // 等待直到该键松开<br>    while (keyPressed() != 0):<br>        什么都不做<br>    在当前光标位置显示 c<br>    移动光标<br><br>readLine():<br>    str = 空字符串<br>    重复<br>        c = readChar()<br>        if (c == newLine):<br>            显示 newLine<br>            return str<br>        else if (c == backSpace):<br>            从 str 中移除最后的字符<br>            do Output.backspace()<br>        else<br>            str = str.append(c)<br>    return str<br></code></pre></td></tr></table></figure>
<h3 id="字符串处理-String-Processing">字符串处理 String Processing</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">// 将整数转化为字符串<br>int2String(val):<br>    lastDigit = val % 10<br>    c = 代表 lastDigit 的字符<br>    if (val &lt; 10)<br>        return c<br>    else<br>        return int2String(val / 10).append(c)<br><br>// 将字符串转化为整数<br>string2Int(str):<br>    val = 0<br>    for (i = 0 ... str.length) do<br>        d = str[i] 的整数值<br>        val = val * 10 + d<br>    return val<br></code></pre></td></tr></table></figure>
<p>字符串本身就是一个 <code>Array</code></p>
<h3 id="数组处理-Array-Processing">数组处理 Array Processing</h3>
<ul>
<li><code>Array.new</code> 不要作为一个 constructor，而是作为一个 function，使用 <code>Memory.alloc</code></li>
<li><code>Array.dispose</code> 使用 <code>Memory.deAlloc</code></li>
</ul>
<h3 id="Sys-类-The-Sys-Class">Sys 类 The Sys Class</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">class Sys &#123;<br>    function void init() &#123;<br>        do Math.init();<br>        do Memory.init();<br>        do Screen.init();<br>        ...<br>        do Main.main();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>
<p><code>Sys.halt</code>：使用无限循环实现</p>
</li>
<li>
<p><code>Sys.wait</code>：使用循环实现，和机器相关</p>
</li>
</ul>
<h2 id="更多乐趣-More-Fun-To-Go">更多乐趣 More Fun To Go</h2>
<p>还有很多细节是没有涉及到的，感谢两位老师，“路漫漫其修远兮，吾将上下而求索”</p>
<p>​</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B8%8C%E4%BC%AF%E6%9D%A5%E5%A4%A7%E5%AD%A6/">希伯来大学</a><a class="post-meta__tags" href="/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">体系结构</a></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/b0fa4c58.html" title="UCB CS126：概率论"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/UCB%20CS126%EF%BC%9A%E6%A6%82%E7%8E%87%E8%AE%BA.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">UCB CS126：概率论</div></div><div class="info-2"><div class="info-item-1">页面排序 PageRank 模型 网页间的链接构成一副图 如果有高名次的页面指向一个页面，则该页面有较高的名次，即 π(i)=∑j∈Xπ(j)P(j,i),i∈Xπ(i) = \sum_{j ∈ X} π(j) P(j, i), i ∈ X π(i)=j∈X∑​π(j)P(j,i),i∈X 注意其中 P(j,i)P(j, i)P(j,i) 为指向 iii 的链接，单位化后的结果 写成矩阵： π=πPπ = π P π=πP 还有一重单位化的约束： ∑i∈Xπ(i)=1\sum_{i ∈ X} π(i) = 1 i∈X∑​π(i)=1 马尔科夫链 可以用公式定义马尔科夫链： P[X(n+1)=j∣X(n)=i,X(m),m&lt;n]=P(i,j),∀i,j∈X,n≥0P[X(n+1) = j | X(n) = i, X(m), m &lt; n] = P(i, j), ∀ i, j ∈ X, n ≥ 0 P[X(n+1)=j∣X(n)=i,X(m),m&lt;n]=P(i,j),∀i,j∈X,n≥0 其中 X(n)X(n)X(n) 表示时间 nnn...</div></div></div></a><a class="pagination-related" href="/posts/a98766fe.html" title="做自己的英雄"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/%E5%9C%A8%E5%9C%B0%E4%B8%8B%E5%9F%8E%E5%AF%BB%E6%B1%82%E9%82%82%E9%80%85%E6%98%AF%E5%90%A6%E6%90%9E%E9%94%99%E4%BA%86%E4%BB%80%E4%B9%88.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">做自己的英雄</div></div><div class="info-2"><div class="info-item-1">在我刚开始看这部番的时候，我是当成普通的异世界后宫番看的简单来说就是厕纸，但当我看了后面的几季时，对这部番有了一定的改观。 第一季是传统的王道英雄故事：主角出生卑微，有自己憧憬的对象，被人嫌弃，最终让所有人都称赞。 到了第二季就有了改观，传统的故事应该是英雄救美女，而这个“美女”应当是高贵而高尚的。然而，这里的被救者却是不起眼的小人族和让人看不起的娼妇，这是对传统英雄的颠覆。 第三季异端儿篇更是我认为的剧情上的巅峰，把这种故事的扭曲和英雄的光辉发挥到了极致。为了解救那些无辜的异端儿们，他愿意舍弃“英雄”之名，为他们而战。事实上，贝尔从头到尾都没有任何转变，他依旧是那个“亚撒西”的男主，而真正的英雄也确实应该是这样的。只是人们不认可这种行为，认为英雄必须永远正确、永远站在保护他们的立场上。而创作英雄故事的人更是故意抹去了这一点，让这些事情不会发生，不会破坏那个人们心中崇高的形象。所以“英雄”之名究竟应该属于那个被称为“英雄”的人，还是那些传颂“英雄事迹”的人呢？ 第四季是硫党的福利回，没什么好说的，果然第三季已经是巅峰了。 </div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="iconfont icon-tuijian"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/f1252f66.html" title="ETH Zurich：数字设计与计算机体系结构"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-25</div><div class="info-item-2">ETH Zurich：数字设计与计算机体系结构</div></div><div class="info-2"><div class="info-item-1">引言与基础 Introduction and Basics 当前的四大方向：  安全 节省能源 低延时和可预测 AI/ML，生物，医疗，健康等的专属硬件  课程高层次目标：  了解基础 原则 惯例  基于此：  了解计算机工作 权衡不同的设计和思想 实现基于原则的硬件 在越来越复杂的系统中 debug 开发新颖的、开箱即用的设计  这些 DDCA 的原则有利于：  设计更好的硬件、软件、系统 设计中更好地取舍 了解计算机工作原理 并行、批判性思考  最重要的是：  Learning is for life, while exam study is until you pass.   机会在底层 内存中的问题：  row hammer meltdown and spectre data movement  权衡，指标 Tradeoffs, Metrics 数据移动消耗了大量的能源，尤其是在机器学习中 新的计算范式（重新思考整个栈）：  在内存中处理，在数据边处理 量子计算 安全与可靠计算机  新的加速单元与系统（算法-硬件协同设计）：  AI &amp; ML 图 &amp;...</div></div></div></a><a class="pagination-related" href="/posts/518e2799.html" title="UCB CS61C：计算机架构的伟大思想"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/UCB%20CS61C%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%B6%E6%9E%84%E7%9A%84%E4%BC%9F%E5%A4%A7%E6%80%9D%E6%83%B3.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-24</div><div class="info-item-2">UCB CS61C：计算机架构的伟大思想</div></div><div class="info-2"><div class="info-item-1">RISC-V RISC 哲学：  保持指令集小而简单，让其能更容易构建快速的硬件 通过将简单的组合在一起让软件实现复杂的操作  RISC-V 中有 32 个寄存器  序号为 x0-31 x0 的值总是为 0 可以使用序号引用，也可以使用名字  注释 #，只支持单行注释 加减的基本格式：sub x3, x4, x5 等价于 x3 = x4 - x5 立即数有不同的指令：addi x3, x4, 10，即最后一个数必须为立即数。注意到没有对应的减法的版本，因为可以通过加法实现 因为 0 非常常用，所以 x0 寄存器在硬件上设置为 0，即例如 add x0, x3, x4 的指令无效 从内存中读取数据：lw x10, 12(x15)，其中 x15 指向 int 数组 A，则 x10 = A[3]，即 12 表示字节的偏移 将数据存到内存中：sw x10, 40(x15) 除了按 word 转移数据，也支持按字节 byte 转移数据，如 lb、sb，注意 lb x10, 3(x11) 将内存中的数据复制到 x10 的低位中，使用符号扩展前面的内容 也有 unsigned 版本...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/%E5%A4%B4%E5%83%8F_%E7%81%B0%E5%A4%AA%E7%8B%BC.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Aefrivern</div><div class="author-info-description">我一定会回来的</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">180</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">235</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/aefrivern" rel="external nofollow noreferrer" target="_blank" title="icon-github"><i class="GitHub"></i></a><a class="social-icon" href="mailto:2771503468@qq.com" rel="external nofollow noreferrer" target="_blank" title="icon-youxiang"><i class="QQ邮箱"></i></a><a class="social-icon" href="https://steamcommunity.com/id/old_driver_zero" rel="external nofollow noreferrer" target="_blank" title="icon-steam"><i class="Steam"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><a class="faa-parent animated-hover"><svg class="faa-tada icon" style="height:25px;width:25px;fill:currentColor;position:relative;top:5px" aria-hidden="true"><use xlink:href="#icon-mulu"></use></svg></a><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E5%87%BD%E6%95%B0%E5%92%8C%E9%80%BB%E8%BE%91%E9%97%A8-Boolean-Functions-and-Gate-Logic"><span class="toc-number">1.</span> <span class="toc-text">布尔函数和逻辑门 Boolean Functions and Gate Logic</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91-Boolean-Logic"><span class="toc-number">1.1.</span> <span class="toc-text">布尔逻辑 Boolean Logic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E5%87%BD%E6%95%B0%E5%90%88%E6%88%90-Boolean-Functions-Synthesis"><span class="toc-number">1.2.</span> <span class="toc-text">布尔函数合成 Boolean Functions Synthesis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E9%97%A8-Logic-Gates"><span class="toc-number">1.3.</span> <span class="toc-text">逻辑门 Logic Gates</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80-Hardware-Description-Language"><span class="toc-number">1.4.</span> <span class="toc-text">硬件描述语言 Hardware Description Language</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%A8%A1%E6%8B%9F-Hardware-Simulation"><span class="toc-number">1.5.</span> <span class="toc-text">硬件模拟 Hardware Simulation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%AF%94%E7%89%B9%E6%80%BB%E7%BA%BF-Multi-bit-Buses"><span class="toc-number">1.6.</span> <span class="toc-text">多比特总线 Multi-bit Buses</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0%E5%92%8C-ALU-Boolean-Arithmetic-and-the-ALU"><span class="toc-number">2.</span> <span class="toc-text">布尔代数和 ALU Boolean Arithmetic and the ALU</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E5%AD%97-Binary-Numbers"><span class="toc-number">2.1.</span> <span class="toc-text">二进制数字 Binary Numbers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95-Binary-Addition"><span class="toc-number">2.2.</span> <span class="toc-text">二进制加法 Binary Addition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E6%95%B0-Negative-Numbers"><span class="toc-number">2.3.</span> <span class="toc-text">负数 Negative Numbers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83-ALU"><span class="toc-number">2.4.</span> <span class="toc-text">算术逻辑单元 ALU</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98-Memory"><span class="toc-number">3.</span> <span class="toc-text">内存 Memory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E9%80%BB%E8%BE%91-Sequential-Logic"><span class="toc-number">3.1.</span> <span class="toc-text">序列逻辑 Sequential Logic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8-Flip-Flops"><span class="toc-number">3.2.</span> <span class="toc-text">触发器 Flip Flops</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83-Memory-Units"><span class="toc-number">3.3.</span> <span class="toc-text">内存单元 Memory Units</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8-Counters"><span class="toc-number">3.4.</span> <span class="toc-text">计时器 Counters</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80-Machine-Language"><span class="toc-number">4.</span> <span class="toc-text">机器语言 Machine Language</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0-Elements"><span class="toc-number">4.1.</span> <span class="toc-text">元素 Elements</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%91%E5%AE%A2%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%92%8C%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80-The-Hack-Computer-and-Machine-Language"><span class="toc-number">4.2.</span> <span class="toc-text">黑客计算机和机器语言 The Hack Computer and Machine Language</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%91%E5%AE%A2%E8%AF%AD%E8%A8%80%E8%AF%A6%E8%BF%B0-Hack-Language-Specification"><span class="toc-number">4.3.</span> <span class="toc-text">黑客语言详述 Hack Language Specification</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA-Input-Output"><span class="toc-number">4.4.</span> <span class="toc-text">输入-输出 Input-Output</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B-Hack-Programming"><span class="toc-number">4.5.</span> <span class="toc-text">黑客编程 Hack Programming</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98"><span class="toc-number">4.5.1.</span> <span class="toc-text">处理寄存器和内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%94%AF"><span class="toc-number">4.5.2.</span> <span class="toc-text">分支</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">4.5.3.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3"><span class="toc-number">4.5.4.</span> <span class="toc-text">迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">4.5.5.</span> <span class="toc-text">指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84-Computer-Architecture"><span class="toc-number">5.</span> <span class="toc-text">计算机结构 Computer Architecture</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84-Von-Neumann-Architecture"><span class="toc-number">5.1.</span> <span class="toc-text">冯诺依曼结构 Von Neumann Architecture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-%E6%89%A7%E8%A1%8C%E5%BE%AA%E7%8E%AF-The-Fetch-Execute-Cycle"><span class="toc-number">5.2.</span> <span class="toc-text">获取-执行循环 The Fetch-Execute Cycle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8-Central-Processing-Unit"><span class="toc-number">5.3.</span> <span class="toc-text">中央处理器 Central Processing Unit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%91%E5%AE%A2%E8%AE%A1%E7%AE%97%E6%9C%BA-The-Hack-Computer"><span class="toc-number">5.4.</span> <span class="toc-text">黑客计算机 The Hack Computer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E5%99%A8-Assembler"><span class="toc-number">6.</span> <span class="toc-text">汇编器 Assembler</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%92%8C%E6%B1%87%E7%BC%96%E5%99%A8-Assembly-Languages-and-Assemblers"><span class="toc-number">6.1.</span> <span class="toc-text">汇编语言和汇编器 Assembly Languages and Assemblers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%91%E5%AE%A2%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%BF%BB%E8%AF%91%E8%80%85%E7%9A%84%E7%AB%8B%E5%9C%BA-The-Hack-Assembly-Language-A-Translator-s-Perspective"><span class="toc-number">6.2.</span> <span class="toc-text">黑客汇编语言：一个翻译者的立场 The Hack Assembly Language: A Translator&#39;s Perspective</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%BF%87%E7%A8%8B%EF%BC%9A%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4-The-Assembly-Process-Handling-Instructions"><span class="toc-number">6.3.</span> <span class="toc-text">汇编过程：处理指令 The Assembly Process: Handling Instructions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%BF%87%E7%A8%8B%EF%BC%9A%E5%A4%84%E7%90%86%E7%AC%A6%E5%8F%B7-The-Assembly-Process-Handling-Symbols"><span class="toc-number">6.4.</span> <span class="toc-text">汇编过程：处理符号 The Assembly Process: Handling Symbols</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E9%BB%91%E5%AE%A2%E6%B1%87%E7%BC%96%E5%99%A8%EF%BC%9A%E5%BB%BA%E8%AE%AE%E8%BD%AF%E4%BB%B6%E7%BB%93%E6%9E%84-Developing-a-Hack-Assembler-Proposed-Software-Architecture"><span class="toc-number">6.5.</span> <span class="toc-text">开发一个黑客汇编器：建议软件结构 Developing a Hack Assembler: Proposed Software Architecture</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA-I%EF%BC%9A%E6%A0%88%E7%AE%97%E6%9C%AF-Virtual-Machine-I-Stack-Arithmetic"><span class="toc-number">7.</span> <span class="toc-text">虚拟机 I：栈算术 Virtual Machine I: Stack Arithmetic</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E9%A2%84%E8%A7%88-Program-Compilation-Preview"><span class="toc-number">7.1.</span> <span class="toc-text">程序编译预览 Program Compilation Preview</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8A%BD%E8%B1%A1%EF%BC%9A%E6%A0%88-VM-Abstraction-the-Stack"><span class="toc-number">7.2.</span> <span class="toc-text">虚拟机抽象：栈 VM Abstraction: the Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8A%BD%E8%B1%A1%EF%BC%9A%E5%86%85%E5%AD%98%E6%AE%B5-VM-Abstraction-Memory-Segments"><span class="toc-number">7.3.</span> <span class="toc-text">虚拟机抽象：内存段 VM Abstraction: Memory Segments</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E7%8E%B0%EF%BC%9A%E6%A0%88-VM-Implementation-the-Stack"><span class="toc-number">7.4.</span> <span class="toc-text">虚拟机实现：栈 VM Implementation: the Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E7%8E%B0%EF%BC%9A%E5%86%85%E5%AD%98%E6%AE%B5-VM-Implementation-Memory-Segments"><span class="toc-number">7.5.</span> <span class="toc-text">虚拟机实现：内存段 VM Implementation: Memory Segments</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA-II%EF%BC%9A%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6-Virtual-Machine-II-Program-Control"><span class="toc-number">8.</span> <span class="toc-text">虚拟机 II：程序控制 Virtual Machine II: Program Control</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6-Program-Control"><span class="toc-number">8.1.</span> <span class="toc-text">程序控制 Program Control</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF-Branching"><span class="toc-number">8.2.</span> <span class="toc-text">分支 Branching</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%EF%BC%9A%E6%8A%BD%E8%B1%A1-Functions-Abstraction"><span class="toc-number">8.3.</span> <span class="toc-text">函数：抽象 Functions: Abstraction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8C%E8%BF%94%E5%9B%9E%EF%BC%9A%E5%AE%9E%E7%8E%B0%E9%A2%84%E8%A7%88-Function-Call-and-Return-Implementation-Preview"><span class="toc-number">8.4.</span> <span class="toc-text">函数调用和返回：实现预览 Function Call and Return: Implementation Preview</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8C%E8%BF%94%E5%9B%9E%EF%BC%9A%E8%BF%90%E8%A1%8C%E6%A8%A1%E6%8B%9F-Function-Call-and-Return-Run-time-Simulation"><span class="toc-number">8.5.</span> <span class="toc-text">函数调用和返回：运行模拟 Function Call and Return: Run-time Simulation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8C%E8%BF%94%E5%9B%9E%EF%BC%9A%E5%AE%9E%E7%8E%B0-Function-Call-and-Return-Implementation"><span class="toc-number">8.6.</span> <span class="toc-text">函数调用和返回：实现 Function Call and Return: Implementation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E9%BB%91%E5%AE%A2%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84-VM-%E5%AE%9E%E7%8E%B0-VM-Implementation-on-the-Hack-Platform"><span class="toc-number">8.7.</span> <span class="toc-text">在黑客平台上的 VM 实现 VM Implementation on the Hack Platform</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80-High-Level-Language"><span class="toc-number">9.</span> <span class="toc-text">高级语言 High-Level Language</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Jack-%E8%AF%AD%E8%A8%80%E6%A6%82%E8%AE%BA-The-Jack-Language-in-a-nutshell"><span class="toc-number">9.1.</span> <span class="toc-text">Jack 语言概论 The Jack Language in a nutshell</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-Object-Based-Programming"><span class="toc-number">9.2.</span> <span class="toc-text">基于对象编程 Object-Based Programming</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86-List-Processing"><span class="toc-number">9.3.</span> <span class="toc-text">列表处理 List Processing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jack-%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83%EF%BC%9A%E8%AF%AD%E6%B3%95-Jack-Language-Specification-Syntax"><span class="toc-number">9.4.</span> <span class="toc-text">Jack 语言规范：语法 Jack Language Specification: Syntax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jack-%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Jack-Language-Specification-Data-Types"><span class="toc-number">9.5.</span> <span class="toc-text">Jack 语言规范：数据类型 Jack Language Specification: Data Types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jack-%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83%EF%BC%9A%E7%B1%BB-Jack-Language-Specification-Classes"><span class="toc-number">9.6.</span> <span class="toc-text">Jack 语言规范：类 Jack Language Specification: Classes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jack-%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83%EF%BC%9A%E6%96%B9%E6%B3%95-Jack-Language-Specification-Methods"><span class="toc-number">9.7.</span> <span class="toc-text">Jack 语言规范：方法 Jack Language Specification: Methods</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Jack-%E8%AF%AD%E8%A8%80%E5%92%8C-OS-%E6%9D%A5%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-Developing-Apps-using-the-Jack-Language-and-OS"><span class="toc-number">9.8.</span> <span class="toc-text">使用 Jack 语言和 OS 来开发应用程序 Developing Apps using the Jack Language and OS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8-I%EF%BC%9A%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-Compiler-I-Syntax-Analysis"><span class="toc-number">10.</span> <span class="toc-text">编译器 I：语法分析 Compiler I: Syntax Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-Syntax-Analysis"><span class="toc-number">10.1.</span> <span class="toc-text">语法分析 Syntax Analysis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8D%E6%B1%87%E5%88%86%E6%9E%90-Lexical-Analysis"><span class="toc-number">10.2.</span> <span class="toc-text">词汇分析 Lexical Analysis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-Grammars"><span class="toc-number">10.3.</span> <span class="toc-text">语法 Grammars</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E6%A0%91-Parse-Trees"><span class="toc-number">10.4.</span> <span class="toc-text">解析树 Parse Trees</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%99%A8%E9%80%BB%E8%BE%91-Parser-Logic"><span class="toc-number">10.5.</span> <span class="toc-text">解析器逻辑 Parser Logic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jack-%E8%AF%AD%E6%B3%95-The-Jack-Grammar"><span class="toc-number">10.6.</span> <span class="toc-text">Jack 语法 The Jack Grammar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jack-%E5%88%86%E6%9E%90-The-Jack-Analysis"><span class="toc-number">10.7.</span> <span class="toc-text">Jack 分析 The Jack Analysis</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8-II%EF%BC%9A%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90-Compiler-II-Code-Generation"><span class="toc-number">11.</span> <span class="toc-text">编译器 II：代码生成 Compiler II: Code Generation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90-Code-Generation"><span class="toc-number">11.1.</span> <span class="toc-text">代码生成 Code Generation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%8F%98%E9%87%8F-Handling-Variables"><span class="toc-number">11.2.</span> <span class="toc-text">处理变量 Handling Variables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E8%A1%A8%E8%BE%BE%E5%BC%8F-Handling-Expressions"><span class="toc-number">11.3.</span> <span class="toc-text">处理表达式 Handling Expressions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%8E%A7%E5%88%B6%E6%B5%81-Handling-Flow-of-Control"><span class="toc-number">11.4.</span> <span class="toc-text">处理控制流 Handling Flow of Control</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%AF%B9%E8%B1%A1%EF%BC%9A%E4%BD%8E%E5%B1%82%E7%BA%A7%E6%96%B9%E9%9D%A2-Handling-Objects-Low-Level-Aspects"><span class="toc-number">11.5.</span> <span class="toc-text">处理对象：低层级方面 Handling Objects: Low-Level Aspects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%AF%B9%E8%B1%A1%EF%BC%9A%E6%9E%84%E9%80%A0-Handling-Objects-Construction"><span class="toc-number">11.6.</span> <span class="toc-text">处理对象：构造 Handling Objects: Construction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%AF%B9%E8%B1%A1%EF%BC%9A%E6%93%8D%E4%BD%9C-Handling-Objects-Manipulation"><span class="toc-number">11.7.</span> <span class="toc-text">处理对象：操作 Handling Objects: Manipulation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84-Handling-Arrays"><span class="toc-number">11.8.</span> <span class="toc-text">处理数组 Handling Arrays</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%A0%87%E5%87%86%E6%98%A0%E5%B0%84-Standard-Mapping-Over-the-Virtual-Machine"><span class="toc-number">11.9.</span> <span class="toc-text">对虚拟机的标准映射 Standard Mapping Over the Virtual Machine</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Operating-System"><span class="toc-number">12.</span> <span class="toc-text">操作系统 Operating System</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">12.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%88%E7%8E%87%E5%BE%88%E9%87%8D%E8%A6%81-Efficiency-Matters"><span class="toc-number">12.2.</span> <span class="toc-text">效率很重要 Efficiency Matters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E6%93%8D%E4%BD%9C-Mathematical-Operations"><span class="toc-number">12.3.</span> <span class="toc-text">数学操作 Mathematical Operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE-Memory-Access"><span class="toc-number">12.4.</span> <span class="toc-text">内存访问 Memory Access</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%AE%A1%E7%90%86-Heap-Management"><span class="toc-number">12.5.</span> <span class="toc-text">堆管理 Heap Management</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2-Graphics"><span class="toc-number">12.6.</span> <span class="toc-text">图形 Graphics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%BB%E7%BA%BF-Line-Drawing"><span class="toc-number">12.7.</span> <span class="toc-text">画线 Line Drawing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%96%87%E5%AD%97%E8%BE%93%E5%87%BA-Handling-Textual-Output"><span class="toc-number">12.8.</span> <span class="toc-text">处理文字输出 Handling Textual Output</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5-Input"><span class="toc-number">12.9.</span> <span class="toc-text">输入 Input</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86-String-Processing"><span class="toc-number">12.10.</span> <span class="toc-text">字符串处理 String Processing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86-Array-Processing"><span class="toc-number">12.11.</span> <span class="toc-text">数组处理 Array Processing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sys-%E7%B1%BB-The-Sys-Class"><span class="toc-number">12.12.</span> <span class="toc-text">Sys 类 The Sys Class</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E4%B9%90%E8%B6%A3-More-Fun-To-Go"><span class="toc-number">13.</span> <span class="toc-text">更多乐趣 More Fun To Go</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>安得广厦千万间，大庇天下寒士俱欢颜，风雨不动安如山。</div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/comments/">留点什么</a><a href="/random/">随便逛逛</a></li><li><a href="/about/">关于</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/gallery/">我的画廊</a><a href="/charts/">网站统计</a></li></ul></div></div></div></div><div class="copyright">&copy;2022 - 2025 By Aefrivern</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (true) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script></div><script async src="//at.alicdn.com/t/c/font_4031045_1yiosqv4vch.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      window.location.href = e.request.responseURL
    }
  })
})()</script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/c/font_4031045_izvon5l4fr8.js"></script><!-- hexo injector body_end end --></body></html>