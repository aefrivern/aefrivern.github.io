<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Coursera Nand2Tetris：依据基本原理构建现代计算机：从与非门到俄罗斯方块 | old-driver-zeroの小屋</title><meta name="author" content="old_driver_zero"><meta name="copyright" content="old_driver_zero"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="布尔函数和逻辑门 Boolean Functions and Gate Logic 布尔逻辑 Boolean Logic 与或非 布尔函数合成 Boolean Functions Synthesis 不同的布尔函数能表达相同的意思 所有布尔函数都可以用“与或非”表示 进一步，都可以用“与非”表示 (x OR y) &#x3D; NOT(NOT(x) AND NOT(y)) 更进一步，可以用 NAND （AN">
<meta property="og:type" content="article">
<meta property="og:title" content="Coursera Nand2Tetris：依据基本原理构建现代计算机：从与非门到俄罗斯方块">
<meta property="og:url" content="https://old-driver-zero.github.io/posts/fb3794ef.html">
<meta property="og:site_name" content="old-driver-zeroの小屋">
<meta property="og:description" content="布尔函数和逻辑门 Boolean Functions and Gate Logic 布尔逻辑 Boolean Logic 与或非 布尔函数合成 Boolean Functions Synthesis 不同的布尔函数能表达相同的意思 所有布尔函数都可以用“与或非”表示 进一步，都可以用“与非”表示 (x OR y) &#x3D; NOT(NOT(x) AND NOT(y)) 更进一步，可以用 NAND （AN">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://old-driver-zero.github.io/gallery/cover/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97.webp">
<meta property="article:published_time" content="2023-08-28T00:17:22.000Z">
<meta property="article:modified_time" content="2024-05-01T03:06:16.000Z">
<meta property="article:author" content="old_driver_zero">
<meta property="article:tag" content="希伯来大学">
<meta property="article:tag" content="体系结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://old-driver-zero.github.io/gallery/cover/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97.webp"><link rel="shortcut icon" href="/illustration/favicon.ico"><link rel="canonical" href="https://old-driver-zero.github.io/posts/fb3794ef.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"GY5EJYJ1FS","apiKey":"c443c952672ec7062840aac45536181e","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Coursera Nand2Tetris：依据基本原理构建现代计算机：从与非门到俄罗斯方块',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-01 11:06:16'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4031045_1yiosqv4vch.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/highlight.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/article title.css"><link rel="stylesheet" href="/css/card author.css"><link rel="stylesheet" href="/css/transpancy.css"><script src="/js/echarts.min.js"></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css">
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/c/font_4031045_izvon5l4fr8.js"></script><!-- hexo injector body_end end --></body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/%E5%A4%B4%E5%83%8F_%E7%81%B0%E5%A4%AA%E7%8B%BC.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">183</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-shouye-01"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shouye-01"/></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-guidang"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guidang"/></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw icon-a-16-01-01"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-a-16-01-01"/></svg><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-wenjianjia"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wenjianjia"/></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/anime/"><i class="fa-fw icon-zhifeiji"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhifeiji"/></svg><span> 二次元</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/gallery/"><i class="fa-fw icon-xiangce"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiangce"/></svg><span> 画廊</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-guanyu"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyu"/></svg><span> 关于</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/charts/"><i class="fa-fw icon-tongjichaxun"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tongjichaxun"/></svg><span> 统计</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-liuyan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyan"/></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/random/"><i class="fa-fw icon-suiji"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-suiji"/></svg><span> 随便逛逛</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/gallery/cover/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="old-driver-zeroの小屋"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/favicon.ico"><span class="site-name">old-driver-zeroの小屋</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-sousuo1"/></svg><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-shouye-01"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shouye-01"/></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-guidang"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guidang"/></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw icon-a-16-01-01"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-a-16-01-01"/></svg><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-wenjianjia"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wenjianjia"/></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/anime/"><i class="fa-fw icon-zhifeiji"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhifeiji"/></svg><span> 二次元</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/gallery/"><i class="fa-fw icon-xiangce"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiangce"/></svg><span> 画廊</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-guanyu"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyu"/></svg><span> 关于</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/charts/"><i class="fa-fw icon-tongjichaxun"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tongjichaxun"/></svg><span> 统计</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-liuyan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyan"/></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/random/"><i class="fa-fw icon-suiji"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-suiji"/></svg><span> 随便逛逛</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Coursera Nand2Tetris：依据基本原理构建现代计算机：从与非门到俄罗斯方块</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-rili"/></svg><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-28T00:17:22.000Z" title="发表于 2023-08-28 08:17:22">2023-08-28</time><span class="post-meta-separator">|</span><svg class="meta_icon post-ui-icon" style="width:13px;height:13px;position:relative;top:2px"><use xlink:href="#icon-gengxin"/></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-01T03:06:16.000Z" title="更新于 2024-05-01 11:06:16">2024-05-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><a class="faa-parent animated-hover"></a><svg class="meta_icon post-ui-icon" style="width:13px;height:13px;position:relative;top:2px"><use xlink:href="#icon-fenlei"/></svg><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-word"/></svg><span class="post-meta-label">字数总计:</span><span class="word-count">6257</span><span class="post-meta-separator">|</span><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-shizhong"/></svg><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>布尔函数和逻辑门 Boolean Functions and Gate Logic</h1>
<h2 id="布尔逻辑-Boolean-Logic">布尔逻辑 Boolean Logic</h2>
<p>与或非</p>
<h2 id="布尔函数合成-Boolean-Functions-Synthesis">布尔函数合成 Boolean Functions Synthesis</h2>
<p>不同的布尔函数能表达相同的意思</p>
<p>所有布尔函数都可以用“与或非”表示</p>
<p>进一步，都可以用“与非”表示 <code>(x OR y) = NOT(NOT(x) AND NOT(y))</code></p>
<p>更进一步，可以用 <code>NAND</code> （<code>AND</code> 的否定）表示（<code>NOR</code> 也可以）：</p>
<ul>
<li><code>NOT(x) = (x NAND x)</code></li>
<li><code>(x AND y) = NOT(x NAND y)</code></li>
</ul>
<p>故可以仅使用 <code>NAND</code> 构造整个逻辑</p>
<h2 id="逻辑门-Logic-Gates">逻辑门 Logic Gates</h2>
<p>基本逻辑门，复合逻辑门</p>
<p>将复合逻辑门看作黑盒，关心接口，不关心实现</p>
<h2 id="硬件描述语言-Hardware-Description-Language">硬件描述语言 Hardware Description Language</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs HDL">// 接口<br>CHIP Xor &#123;<br>    IN a, b;<br>    OUT out;<br><br>    PARTS:<br>    // 实现<br>    Not(in=a, out=nota);<br>    Not(in=b, out=notb);<br>    And(a=a, b=notb, out=aAndNotb);<br>    And(a=b, b=nota, out=bAndNota);<br>    Or(a=aAndNotb, b=bAndNota, out=out);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>HDL 是一种函数式语言</li>
<li>HDL 的顺序不重要</li>
<li>想要使用芯片，必须了解其接口，如 <code>Not(in= , out= )</code></li>
<li><code>partName(a=a, out=out)</code> 之类的写法很常见</li>
</ul>
<p>常见的 HDL：VHDL，Verilog</p>
<h2 id="硬件模拟-Hardware-Simulation">硬件模拟 Hardware Simulation</h2>
<p>老师专门为该课程编写的一个程序，用于测试。虽然简陋，但五脏俱全，设计非常精巧</p>
<p>在实际的硬件开发中，一般分两种岗位：</p>
<ul>
<li>系统架构师</li>
<li>开发者</li>
</ul>
<p>架构师决定使用的芯片，对于每块芯片，架构师创造：</p>
<ul>
<li>API</li>
<li>测试脚本</li>
<li>比较文件</li>
</ul>
<p>开发者根据这些要求制作</p>
<h2 id="多比特总线-Multi-bit-Buses">多比特总线 Multi-bit Buses</h2>
<p>使用起来类似数组</p>
<p>支持分成子总线，如 <code>a[0..7]=lsb, a[8..15]=msb</code></p>
<p>注意，<code>a[0]</code> 表示最右边的位</p>
<h1>布尔代数和 ALU Boolean Arithmetic and the ALU</h1>
<h2 id="二进制数字-Binary-Numbers">二进制数字 Binary Numbers</h2>
<p>二进制的表示，与十进制的转换等</p>
<h2 id="二进制加法-Binary-Addition">二进制加法 Binary Addition</h2>
<p>半加器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs HDL">CHIP HalfAdder &#123;<br>    IN a, b;    // 1-bit inputs<br>    OUT sum,    // Right bit of a + b<br>        carry;  // Left bit of a + b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>全加器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs HDL">CHIP FullAdder &#123;<br>    IN a, b, c;  // 1-bit inputs<br>    OUT sum,     // Right bit of a + b + c<br>        carry;   // Left bit of a + b + c<br>&#125;<br></code></pre></td></tr></table></figure>
<p>16 位加法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs HDL">CHIP Add16 &#123;<br>    IN a[16], b[16];<br>    OUT out[16];<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="负数-Negative-Numbers">负数 Negative Numbers</h2>
<p>将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord mathnormal">x</span></span></span></span> 表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">2^n-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>，化简得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">1 + (2^n - 1) - x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>，即取反加一</p>
<p>保证了正负零一致</p>
<h2 id="算术逻辑单元-ALU">算术逻辑单元 ALU</h2>
<p>计算两个输入的函数，并输出结果</p>
<p>接受一些控制位：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs HDL">if (zx == 1) set x = 0     // 16-bit constant<br><br>if (nx == 1) set x = !x    // bitwise not<br><br>if (zy == 1) set y = 0     // 16-bit constant<br><br>if (ny == 1) set y = !y    // bitwise not<br><br>if (f == 1)  set out = x + y  // integer 2&#x27;s complement addition<br><br>if (f == 0)  set out = x &amp; y  // bitwise and<br><br>if (no == 1) set out = !out  // bitwise no<br></code></pre></td></tr></table></figure>
<p>除了结果外，还有两个位输出一些有用的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs HDL">if (out == 0) set zr = 1<br><br>if (out &lt; 0) set ng = 1<br></code></pre></td></tr></table></figure>
<p>通过那些控制位，可以实现计算</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo separator="true">,</mo><mi>x</mi><mo>−</mo><mi>y</mi><mo separator="true">,</mo><mi>y</mi><mo>−</mo><mi>x</mi><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mo>−</mo><mi>x</mi><mo separator="true">,</mo><mo>−</mo><mi>y</mi><mo separator="true">,</mo><mo stretchy="false">!</mo><mi>x</mi><mo separator="true">,</mo><mo stretchy="false">!</mo><mi>y</mi><mo separator="true">,</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>x</mi><mi mathvariant="normal">&amp;</mi><mi>y</mi><mo separator="true">,</mo><mi>x</mi><mi mathvariant="normal">∥</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">x+y, x-y, y-x, 0, 1, -1, x, y, -x, -y, !x, !y, x+1, y+1, x-1, y-1, x\&amp;y, x\|y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mclose">!</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mclose">!</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mord">&amp;</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mord">∥</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></p>
<h1>内存 Memory</h1>
<h2 id="序列逻辑-Sequential-Logic">序列逻辑 Sequential Logic</h2>
<p>把时间离散化，可以忽略延迟</p>
<p>组合逻辑：<code>out[t] = function(in[t])</code></p>
<p>序列逻辑：<code>state[t] = function(state[t-1])</code></p>
<h2 id="触发器-Flip-Flops">触发器 Flip Flops</h2>
<p>有两种状态：记忆 0 和记忆 1</p>
<p>时钟数据触发器（DFF）：<code>out[t] = in[t-1]</code></p>
<p>所以序列逻辑的实现如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E5%BA%8F%E5%88%97%E9%80%BB%E8%BE%91%E5%AE%9E%E7%8E%B0.webp" alt="序列逻辑实现"></p>
<p>如果是时钟，则组合逻辑为 +1</p>
<p>1 bit 的寄存器，load 控制读写</p>
<h2 id="内存单元-Memory-Units">内存单元 Memory Units</h2>
<p>最基本的内存元素：register</p>
<ul>
<li>输入数据长度 w</li>
</ul>
<p>RAM 的抽象：</p>
<ul>
<li>n 个寄存器序列</li>
<li>每次只有一个寄存器选中</li>
<li>地址长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">k = \log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span></span></span></span></li>
<li>RAM 就是一个有时钟表现的序列芯片</li>
</ul>
<p>随机访问：无论 RAM 大小如何，每个寄存器都可以在相同的时间被访问</p>
<h2 id="计时器-Counters">计时器 Counters</h2>
<p>因为计算机需要跟踪获取的指令并执行下一个，此控制可以通过程序计时器实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs HDL">CHIP PC &#123;<br>    IN in[16],load,inc,reset;<br>    OUT out[16];<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>机器语言 Machine Language</h1>
<p>​</p>
<h2 id="元素-Elements">元素 Elements</h2>
<p>内存层次结构，CPU 中有寄存器</p>
<p>控制流，如循环</p>
<h2 id="黑客计算机和机器语言-The-Hack-Computer-and-Machine-Language">黑客计算机和机器语言 The Hack Computer and Machine Language</h2>
<p>构成：</p>
<ul>
<li>数据内存 RAM</li>
<li>指令内存 ROM</li>
<li>CPU</li>
<li>指令、数据、地址总线</li>
</ul>
<p>三个寄存器：</p>
<ul>
<li>D 保存一个 16 bit 的值</li>
<li>A 保存一个 16 bit 的值</li>
<li>M 代表地址为 A 的 16 bit RAM 寄存器</li>
</ul>
<p>A 指令：<code>@value</code>，其中 <code>value</code> 是一个非负十进制常数或一个代表常数的符号</p>
<p>效果：</p>
<ul>
<li>将 A 寄存器设为 <code>value</code></li>
<li>将 RAM[A] 变成选定的 RAM 寄存器</li>
</ul>
<p>C 指令：<code>dest = comp ; jump</code> 其中 <code>dest</code> 和 <code>jump</code> 是可选的</p>
<ul>
<li><code>comp = 0, 1, -1, D, A, ...</code></li>
<li><code>dest = null, M, D, MD, A, AM, AD, AMD</code></li>
<li><code>jump = null, JGT, JEQ, JGE, JLT, JNE, JLE, JMP</code></li>
</ul>
<h2 id="黑客语言详述-Hack-Language-Specification">黑客语言详述 Hack Language Specification</h2>
<p>A 指令对应二进制数</p>
<p>C 指令分为三段，一一对应</p>
<h2 id="输入-输出-Input-Output">输入-输出 Input-Output</h2>
<p>屏幕内存映射：</p>
<p>将像素 <code>(row, col)</code> 开关：</p>
<ul>
<li><code>word = Screen[32*row +col/16]</code></li>
<li><code>word = RAM[16384 + 32*row + col/16]</code></li>
<li>将 <code>word</code> 的 <code>(col % 16)</code> 位变为 0 或 1</li>
<li>将 <code>word</code> 放到 RAM 中</li>
</ul>
<p>键盘内存映射：</p>
<p>当键被按下，代码出现在其中，为相应的 ASCII 码；若没有键被按下，则为 0</p>
<h2 id="黑客编程-Hack-Programming">黑客编程 Hack Programming</h2>
<h3 id="处理寄存器和内存">处理寄存器和内存</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Hack">// RAM[17] = 10<br>@10<br>D=A<br>@17<br>M=D<br></code></pre></td></tr></table></figure>
<p>由于数字和内存写法一致，可采用以下写法区分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Hack">// RAM[17] = 10<br>@10<br>D=A<br>@R17<br>M=D<br></code></pre></td></tr></table></figure>
<p>还有一些特殊的记号，如 <code>SCREEN</code>,<code>KBD</code> 等</p>
<p>终止程序：写一个死循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs hack">@END<br>0;JMP<br></code></pre></td></tr></table></figure>
<h3 id="分支">分支</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs hack">// if R0 &gt; 0<br>//	  R1 = 1<br>// else<br>//	  R1 = 0<br>	@R0<br>	D = M<br><br>	@POSITIVE<br>	D;JGT<br><br>	@R1<br>	M = 0<br>	@END<br>	0; JMP<br><br>(POSITIVE)<br>	@R1<br>	M = 1<br><br>(END)<br>	@END<br>	0; JMP<br></code></pre></td></tr></table></figure>
<h3 id="变量">变量</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">// temp = R1<br>@R1<br>D = M<br>@temp<br>M = D<br></code></pre></td></tr></table></figure>
<h3 id="迭代">迭代</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs hack">// RAM[1] = 1 + 2 + ... + n<br>@R0<br>D = M<br>@n<br>M = D<br>@i<br>M = 1<br>@sum<br>M = 0<br>(LOOP)<br>	@i<br>	D = M<br>	@n<br>	D=D-M<br>	@STOP<br>	D;JGT // if i &gt; n goto STOP<br><br>	@sum<br>	D = M<br>	@i<br>	D = D + M<br>	@sum<br>	M = D // sum = sum + 1<br>	@i<br>	M = M + 1 // i = i + 1<br>	@LOOP<br>	0; JMP<br><br>(STOP)<br>	@sum<br>	D = M<br>	@R1<br>	M = D // RAM[1] = sum<br><br>(END)<br>	@END<br>	0; JMP<br></code></pre></td></tr></table></figure>
<h3 id="指针">指针</h3>
<p>需要用指针访问内存时，使用 <code>A=M</code>，如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs hack">@i<br>A = D + M<br>M = -1<br></code></pre></td></tr></table></figure>
<h1>计算机结构 Computer Architecture</h1>
<h2 id="冯诺依曼结构-Von-Neumann-Architecture">冯诺依曼结构 Von Neumann Architecture</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84.webp" alt="冯诺依曼结构"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E4%BF%A1%E6%81%AF%E6%B5%81.webp" alt="信息流"></p>
<h2 id="获取-执行循环-The-Fetch-Execute-Cycle">获取-执行循环 The Fetch-Execute Cycle</h2>
<p>基本 CPU 循环：从程序内存中<strong>获取</strong>一个指令并<strong>执行</strong>它</p>
<p>通过 PC 控制指令的顺序执行或跳出</p>
<p>程序和数据存在一起，可能产生冲突，其中一个解决方法是用多路复用器：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E6%8C%87%E4%BB%A4%E5%AF%84%E5%AD%98%E5%99%A8.webp" alt></p>
<p>但是这里使用的是简单的将程序和数据放在内存的不同部分</p>
<h2 id="中央处理器-Central-Processing-Unit">中央处理器 Central Processing Unit</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/CPU%E6%8E%A5%E5%8F%A3.webp" alt="CPU接口"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/CPU%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.webp" alt="CPU内部结构"></p>
<p>指令分为 A 和 C 两种</p>
<p>具体的控制位详见代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs hack">CHIP CPU &#123;<br><br>    IN  inM[16],         // M value input  (M = contents of RAM[A])<br>        instruction[16], // Instruction for execution<br>        reset;           // Signals whether to re-start the current<br>                         // program (reset==1) or continue executing<br>                         // the current program (reset==0).<br><br>    OUT outM[16],        // M value output<br>        writeM,          // Write to M?<br>        addressM[15],    // Address in data memory (of M)<br>        pc[15];          // address of next instruction<br><br>    PARTS:<br>    // Put your code here:<br>    // 第一个 Mux16<br>    Mux16(a=instruction, b=ALUout, sel=instruction[15], out=ia);<br><br>    // ARegister<br>    And(a=instruction[15], b=instruction[5], out=a1);<br>    Not(in=instruction[15], out=a2);<br>    Or(a=a1, b=a2, out=inARegister);<br>    ARegister(in=ia, load=inARegister, out=ARegisterOut, out[0..14]=addressM);<br><br>    // 第二个 Mux16<br>    And(a=instruction[15], b=instruction[12], out=mux2);<br>    Mux16(a=ARegisterOut, b=inM, sel=mux2, out=ALUin);<br><br>    // DRegister<br>    And(a=instruction[15], b=instruction[4], out=inDRegister);<br>    DRegister(in=ALUout, load=inDRegister, out=DRegisterOut);<br><br>    // ALU<br>    And(a=instruction[15], b=instruction[11], out=zx);<br>    And(a=instruction[15], b=instruction[10], out=nx);<br>    And(a=instruction[15], b=instruction[9], out=zy);<br>    And(a=instruction[15], b=instruction[8], out=ny);<br>    And(a=instruction[15], b=instruction[7], out=f);<br>    And(a=instruction[15], b=instruction[6], out=no);<br>    ALU(x=DRegisterOut, y=ALUin, zx=zx, nx=nx, zy=zy, ny=ny, f=f, no=no, out=ALUout, out=outM, zr=zr, ng=ng);<br><br>    // write<br>    And(a=instruction[15], b=instruction[3], out=writeM);<br><br>    // PC<br>    // 分解出大于、小于、等于<br>    And(a=instruction[15], b=instruction[0], out=greater);<br>    And(a=instruction[15], b=instruction[1], out=equal);<br>    And(a=instruction[15], b=instruction[2], out=less);<br><br>    // 正数<br>    Not(in=ng, out=nng);<br>    Not(in=zr, out=nzr);<br>    And(a=nng, b=nzr, out=ps);<br><br>    // 分别判断是否满足条件<br>    And(a=less, b=ng, out=isLess);<br>    And(a=equal, b=zr, out=isEqual);<br>    And(a=greater, b=ps, out=isGreater);<br><br>    Or(a=isLess, b=isEqual, out=part);<br>    Or(a=part, b=isGreater, out=load);<br><br>    PC(in=ARegisterOut, load=load, inc=true, reset=reset, out[0..14]=pc);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="黑客计算机-The-Hack-Computer">黑客计算机 The Hack Computer</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E5%86%85%E5%AD%98%E5%AE%9E%E7%8E%B0.webp" alt="内存实现"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E9%BB%91%E5%AE%A2%E8%AE%A1%E7%AE%97%E6%9C%BA.webp" alt="黑客计算机"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E8%AF%BE%E7%A8%8B%E7%BB%93%E6%9E%84.webp" alt="课程结构"></p>
<h1>汇编器 Assembler</h1>
<h2 id="汇编语言和汇编器-Assembly-Languages-and-Assemblers">汇编语言和汇编器 Assembly Languages and Assemblers</h2>
<p>汇编器是软件，是硬件上的第一层软件</p>
<p>重复直到文件结束：</p>
<ul>
<li>读取下一个汇编语言命令</li>
<li>分成不同域</li>
<li>对每个域查找二进制代码</li>
<li>把代码组合成一个简单的机器语言命令</li>
<li>输出机器语言命令</li>
</ul>
<p>用符号表将变量名和预先定义的常量映射为数字地址</p>
<h2 id="黑客汇编语言：一个翻译者的立场-The-Hack-Assembly-Language-A-Translator’s-Perspective">黑客汇编语言：一个翻译者的立场 The Hack Assembly Language: A Translator’s Perspective</h2>
<ul>
<li>
<p>空格：</p>
<ul>
<li>空行 / 缩进</li>
<li>行内注释</li>
<li>行间注释</li>
</ul>
</li>
<li>
<p>指令：</p>
<ul>
<li>
<p>A 指令</p>
</li>
<li>
<p>C 指令</p>
</li>
</ul>
</li>
<li>
<p>符号：</p>
<ul>
<li>预先定义的符号</li>
<li>标签声明 <code>(label)</code></li>
<li>变量声明 <code>@variableName</code></li>
</ul>
</li>
</ul>
<h2 id="汇编过程：处理指令-The-Assembly-Process-Handling-Instructions">汇编过程：处理指令 The Assembly Process: Handling Instructions</h2>
<p>A 指令 <code>@value</code>：</p>
<ul>
<li>如果是一个数字，则生成等价的 15 bit 二进制常数</li>
<li>如果是符号，则见后</li>
</ul>
<p>C 指令：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E7%BF%BB%E8%AF%91C%E6%8C%87%E4%BB%A4.webp" alt="翻译C指令"></p>
<h2 id="汇编过程：处理符号-The-Assembly-Process-Handling-Symbols">汇编过程：处理符号 The Assembly Process: Handling Symbols</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E7%AC%A6%E5%8F%B7%E8%A1%A8.webp" alt="一图胜千言"></p>
<h2 id="开发一个黑客汇编器：建议软件结构-Developing-a-Hack-Assembler-Proposed-Software-Architecture">开发一个黑客汇编器：建议软件结构 Developing a Hack Assembler: Proposed Software Architecture</h2>
<p><code>parsing</code></p>
<p><code>coding</code></p>
<h1>虚拟机 I：栈算术 Virtual Machine I: Stack Arithmetic</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E8%AF%BE%E7%A8%8B%E8%AE%A1%E5%88%92.webp" alt="课程计划"></p>
<h2 id="程序编译预览-Program-Compilation-Preview">程序编译预览 Program Compilation Preview</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E4%B8%A4%E5%B1%82%E7%BC%96%E8%AF%91.webp" alt="两层编译"></p>
<h2 id="虚拟机抽象：栈-VM-Abstraction-the-Stack">虚拟机抽象：栈 VM Abstraction: the Stack</h2>
<p><code>push</code>,<code>pop</code> 操作</p>
<p>对栈使用函数：</p>
<ul>
<li>pop 参数</li>
<li>计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></li>
<li>push 结果</li>
</ul>
<h2 id="虚拟机抽象：内存段-VM-Abstraction-Memory-Segments">虚拟机抽象：内存段 VM Abstraction: Memory Segments</h2>
<p>因为变量有多种，故内存也有分段：</p>
<p><code>push segment i</code>：</p>
<ul>
<li><code>segment</code>：argument, local, static, constant, this, that, pointer, temp</li>
<li><code>i</code>：非负正数（该内存段中的地址）</li>
</ul>
<p><code>pop segment i</code>：</p>
<ul>
<li><code>segment</code>：argument, local, static, this, that, pointer, temp</li>
<li><code>i</code>：非负正数（该内存段中的地址）</li>
</ul>
<h2 id="虚拟机实现：栈-VM-Implementation-the-Stack">虚拟机实现：栈 VM Implementation: the Stack</h2>
<p>指针操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">D = *p 	// D = 23<br><br>p--    	// RAM[0] = 256<br>D = *p 	// D = 19<br></code></pre></td></tr></table></figure>
<p>简单来说，就是 <code>push constant i</code> -&gt; <code>*SP = i, SP++</code></p>
<h2 id="虚拟机实现：内存段-VM-Implementation-Memory-Segments">虚拟机实现：内存段 VM Implementation: Memory Segments</h2>
<p>对于 <code>local</code> 之类，存储一个指向该内存段首地址的指针 <code>LCL</code></p>
<p><code>pop local i</code> -&gt; <code>addr = LCL + i, SP--, *addr = *SP</code></p>
<p><code>push local i</code> -&gt; <code>addr = LCL + i, *SP = *addr, SP++</code></p>
<p><code>argument</code>, <code>this</code>, <code>that</code> 同理</p>
<p><code>const</code> 比较简单：<code>push constant i</code> -&gt; <code>*SP = i, SP++</code></p>
<p><code>static</code> 要存在全局，所以 <code>static i</code> -&gt; <code>Foo.i</code></p>
<p><code>temp</code> 只有 8 个，<code>push temp i</code> -&gt; <code>addr = 5 + i, *SP = *addr, SP++</code>，<code>pop</code> 同理</p>
<p><code>pointer</code> 用于区分 this 和 that：<code>push pointer 0/1</code> -&gt; <code>*SP = THIS/THAT, SP++</code></p>
<h1>虚拟机 II：程序控制 Virtual Machine II: Program Control</h1>
<h2 id="程序控制-Program-Control">程序控制 Program Control</h2>
<p>分支控制：</p>
<ul>
<li><code>goto label</code></li>
<li><code>if-goto label</code></li>
<li><code>label label</code></li>
</ul>
<p>函数控制：</p>
<ul>
<li><code>call functionName nArgs</code></li>
<li><code>function functionName nVars</code></li>
<li><code>return</code></li>
</ul>
<h2 id="分支-Branching">分支 Branching</h2>
<p>其中 <code>if-goto label</code> 是当 <code>cond = pop</code> 时，跳转到 <code>label</code></p>
<h2 id="函数：抽象-Functions-Abstraction">函数：抽象 Functions: Abstraction</h2>
<p>从 caller 来看，相当于把参数转化为了一个结果</p>
<p>从 callee 来看，相当于创造了一个新的空间，<code>argument</code> 和 <code>local</code> 预先分配好了，栈起初是空的</p>
<p>故：</p>
<p><code>call</code>：</p>
<ul>
<li>把参数传递给被调函数</li>
<li>决定在 caller 代码中返回的地址</li>
<li>保存 caller 的返回地址，栈，内存段</li>
<li>跳到执行被调函数</li>
</ul>
<p><code>return</code>：</p>
<ul>
<li>返回计算出的值给 caller</li>
<li>循环利用被调函数使用的内存资源</li>
<li>恢复 caller 的栈和内存段</li>
<li>跳到 caller 代码的返回地址</li>
</ul>
<h2 id="函数调用和返回：实现预览-Function-Call-and-Return-Implementation-Preview">函数调用和返回：实现预览 Function Call and Return: Implementation Preview</h2>
<p>函数的调用链：栈</p>
<p>函数调用的三个过程对内存的操作</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/call.webp" alt="call"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/function.webp" alt="function"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/return.webp" alt="return"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E5%85%A8%E5%B1%80%E6%A0%88.webp" alt="全局栈实现了调用链"></p>
<h2 id="函数调用和返回：运行模拟-Function-Call-and-Return-Run-time-Simulation">函数调用和返回：运行模拟 Function Call and Return: Run-time Simulation</h2>
<h2 id="函数调用和返回：实现-Function-Call-and-Return-Implementation">函数调用和返回：实现 Function Call and Return: Implementation</h2>
<p>处理 <code>call functionName nArgs</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs vm">push returnAddress<br>push LCL<br>push ARG<br>push THIS<br>push THAT<br>ARG = SP-5-nArgs<br>LCL = SP<br>goto functionName<br>(returnAddress)<br></code></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/call%E5%AE%9E%E7%8E%B0.webp" alt="call实现"></p>
<p>处理 <code>function functionName nVars</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs vm">(functionName)<br>	repeat nVars times:<br>	push 0<br></code></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/function%E5%AE%9E%E7%8E%B0.webp" alt="function实现"></p>
<p>处理 <code>return</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs vm">endFrame = LCL<br>retAddr = *(endFrame - 5)<br>*ARG = pop()<br>SP = ARG + 1<br>THAT = *(endFrame - 1)<br>THIS = *(endFrame - 2)<br>ARG = *(endFrame - 3)<br>LCL = *(endFrame - 4)<br>goto retAddr<br></code></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/return%E5%AE%9E%E7%8E%B0.webp" alt="return实现"></p>
<h2 id="在黑客平台上的-VM-实现-VM-Implementation-on-the-Hack-Platform">在黑客平台上的 VM 实现 VM Implementation on the Hack Platform</h2>
<p>引导：</p>
<ul>
<li>
<p>VM 程序中其中一个叫 <code>Main.vm</code>，该文件中的一个函数叫 <code>main</code></p>
</li>
<li>
<p>当 VM 实现运行时，第一个执行无参数的函数 <code>Sys.init</code></p>
</li>
<li>
<p><code>Sys.init</code> 调用 <code>Main.main</code>，进入无限循环</p>
</li>
</ul>
<h1>高级语言 High-Level Language</h1>
<h2 id="Jack-语言概论-The-Jack-Language-in-a-nutshell">Jack 语言概论 The Jack Language in a nutshell</h2>
<p>Jack 语言是类似 Java 的语言，面向对象，但不支持继承</p>
<p>必须有一个类 <code>Main</code>，其必须有 <code>main</code> 函数，程序的进入点是 <code>Main.main</code></p>
<p>Jack 中的 <code>Array</code> 是没有类型的</p>
<p>操作系统：</p>
<ul>
<li><code>Keyboard.readInt</code></li>
<li><code>Output.printString</code></li>
<li><code>Output.printInt</code></li>
</ul>
<p>数据类型：</p>
<ul>
<li>原始：
<ul>
<li><code>int</code></li>
<li><code>char</code></li>
<li><code>boolean</code></li>
</ul>
</li>
<li>类的类型：
<ul>
<li>操作系统：<code>Array</code>、<code>String</code></li>
<li>程序扩展</li>
</ul>
</li>
</ul>
<h2 id="基于对象编程-Object-Based-Programming">基于对象编程 Object-Based Programming</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">/** Represents the Fraction type and related operations. */<br>class Fraction &#123;<br>   field int numerator, denominator;  // field = property = member variable.<br><br>   /** Constructs a (reduced) fraction from the given numerator and denominator. */<br>   constructor Fraction new(int x, int y) &#123;<br>      let numerator = x;<br>      let denominator = y;<br>      do reduce();   // reduces the fraction<br>      return this;   // a constructor is expected to return a reference to the new object<br>   &#125;<br><br>   // Reduces this fraction.<br>   method void reduce() &#123;<br>      var int g;<br>      let g = Fraction.gcd(numerator, denominator);<br>      if (g &gt; 1) &#123;<br>         let numerator = numerator / g;<br>         let denominator = denominator / g;<br>      &#125;<br>      return;<br>   &#125;<br><br>   /** Accessors. */<br>   method int getNumerator() &#123; return numerator; &#125;<br>   method int getDenominator() &#123; return denominator; &#125;<br><br>   /** Returns the sum of this fraction and the other one. */<br>   method Fraction plus(Fraction other) &#123;<br>      var int sum;<br>      let sum = (numerator * other.getDenominator()) + (other.getNumerator() * denominator);<br>      return Fraction.new(sum, denominator * other.getDenominator());<br>   &#125;<br><br>   // More fraction-related methods (minus, times, div, etc.) can be added here.<br><br>   /** Disposes this fraction. */<br>   method void dispose() &#123;<br>      do Memory.deAlloc(this);  // uses an OS routine to recycle the memory held by the object<br>      return;<br>   &#125;<br><br>   /** Prints this fraction in the format x/y. */<br>   method void print() &#123;<br>      do Output.printInt(numerator);<br>      do Output.printString(&quot;/&quot;);<br>      do Output.printInt(denominator);<br>      return;<br>   &#125;<br><br>   // Computes the greatest common divisor of the given integers.<br>   function int gcd(int a, int b) &#123;<br>      var int r;<br>      while (~(b = 0)) &#123;             // applies Euclid&#x27;s algorithm<br>         let r = a - (b * (a / b));  // r = remainder of the integer division a/b<br>         let a = b; let b = r;<br>      &#125;<br>      return a;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>还有调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">// Computes the sum of 2/3 and 1/5.<br>class Main &#123;<br>   function void main() &#123;<br>      var Fraction a, b, c;<br>      let a = Fraction.new(2,3);<br>      let b = Fraction.new(1,5);<br>      let c = a.plus(b);  // Computes c = a + b<br>      do c.print();       // Prints &quot;13/15&quot;<br>      return;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>已经比较详细了，不必多说</p>
<p>注意几点：</p>
<ul>
<li><code>field</code> 相当于私有的成员变量</li>
<li><code>function</code> 相当于 Java 中的 <code>static</code> 函数</li>
<li><code>this</code> 是地址，<code>constructor</code> 必须显式返回 <code>this</code></li>
<li>任何函数都必须 <code>return</code>，其中 <code>void</code> 函数必须显式 <code>return</code></li>
<li>由于没有垃圾收集，所以必须显式 <code>dispose</code></li>
</ul>
<h2 id="列表处理-List-Processing">列表处理 List Processing</h2>
<p>定义：</p>
<ul>
<li><code>null</code></li>
<li>或一个元素 + list</li>
</ul>
<h2 id="Jack-语言规范：语法-Jack-Language-Specification-Syntax">Jack 语言规范：语法 Jack Language Specification: Syntax</h2>
<p>语法元素：</p>
<ul>
<li>空格，注释</li>
<li>关键字</li>
<li>符号</li>
<li>常数</li>
<li>标识符</li>
</ul>
<h2 id="Jack-语言规范：数据类型-Jack-Language-Specification-Data-Types">Jack 语言规范：数据类型 Jack Language Specification: Data Types</h2>
<p>类型转换：</p>
<ul>
<li>字符和整数可以相互转换</li>
<li>整数可赋值给数组名，被当成内存地址对待</li>
<li>一个对象可以转化为一个数组，反之亦然</li>
</ul>
<h2 id="Jack-语言规范：类-Jack-Language-Specification-Classes">Jack 语言规范：类 Jack Language Specification: Classes</h2>
<p>Jack 的标准库/OS 有 8 个类：<code>Math</code>、<code>String</code>、<code>Array</code>、<code>Output</code>、<code>Screen</code>、<code>Keyboard</code>、<code>Memory</code>、<code>Sys</code></p>
<h2 id="Jack-语言规范：方法-Jack-Language-Specification-Methods">Jack 语言规范：方法 Jack Language Specification: Methods</h2>
<p><code>let</code>：必须在赋值中使用：<code>let x = 0</code></p>
<p><code>do</code>：必须被用于在表达式外调用函数或方法：<code>do reduce()</code></p>
<p>语句的主体必须在括号内，即使只有一条语句</p>
<p>所有的子过程都必须以 <code>return</code> 结尾</p>
<p>运算符没有优先级：<code> 2 + 3 * 4 = 20</code>，<code>2 + (3 * 4) = 14</code></p>
<p>弱类型</p>
<h2 id="使用-Jack-语言和-OS-来开发应用程序-Developing-Apps-using-the-Jack-Language-and-OS">使用 Jack 语言和 OS 来开发应用程序 Developing Apps using the Jack Language and OS</h2>
<p>文字输出：23 行，每行 64 个字符</p>
<p>详见官网的手册</p>
<h1>编译器 I：语法分析 Compiler I: Syntax Analysis</h1>
<h2 id="语法分析-Syntax-Analysis">语法分析 Syntax Analysis</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/Jack%E7%BC%96%E8%AF%91%E5%99%A8%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4.webp" alt="Jack编译器开发步骤"></p>
<h2 id="词汇分析-Lexical-Analysis">词汇分析 Lexical Analysis</h2>
<p>将输入的代码分解成一个个基本组成（<strong>tokens</strong>），如</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/tokenizer.webp" alt="tokenizer"></p>
<h2 id="语法-Grammars">语法 Grammars</h2>
<p><strong>语法</strong>是描述 tokens 是如何组合的规则，如</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/Jack%20grammar.webp" alt="Jack grammar"></p>
<h2 id="解析树-Parse-Trees">解析树 Parse Trees</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E8%A7%A3%E6%9E%90%E6%A0%91.webp" alt="解析树"></p>
<h2 id="解析器逻辑-Parser-Logic">解析器逻辑 Parser Logic</h2>
<ul>
<li>遵守规则的右边，解析对应的输入</li>
<li>如果右边是一个不终止的规则 xxx，则调用 <code>compileXXX</code></li>
<li>递归调用</li>
</ul>
<p>LL grammar：可以被递归下降的解析器没有回调解析（简单来说就是没有“歧义”）</p>
<p>LL(k) parser：需要看最多 k 个 tokens 才能确定规则的解析器</p>
<h2 id="Jack-语法-The-Jack-Grammar">Jack 语法 The Jack Grammar</h2>
<p>注意如果一个 token 是 varName 时，要向后看，因为可能有多种情况</p>
<h2 id="Jack-分析-The-Jack-Analysis">Jack 分析 The Jack Analysis</h2>
<p>当碰到极个别非终止元素（<code>type</code>、<code>class name</code>、<code>subroutine name</code>、<code>variable name</code>、<code>statement</code>、<code>subroutine call</code>）时，不需要标记，因为 <code>varName: identifier</code></p>
<h1>编译器 II：代码生成 Compiler II: Code Generation</h1>
<h2 id="代码生成-Code-Generation">代码生成 Code Generation</h2>
<h2 id="处理变量-Handling-Variables">处理变量 Handling Variables</h2>
<p>在变量声明时，对类中的变量和函数中的变量分别生成一张符号表，注意任何函数符号表中都会自带一个 this 指针</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E5%8F%98%E9%87%8F%E5%90%8D%E7%AC%A6%E5%8F%B7%E8%A1%A8.webp" alt="符号表"></p>
<p>在变量使用时，先在子过程层级的符号表中查找，若找不到，则查找类层级</p>
<p>对于嵌套的作用域，可以把符号表连成一个链表</p>
<h2 id="处理表达式-Handling-Expressions">处理表达式 Handling Expressions</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E8%A1%A8%E8%BE%BE%E5%BC%8F.webp" alt="表达式"></p>
<p>可以看出，后缀表达式是最适合的</p>
<p>但是我们不需要建立表达式树，观察中缀表达式和后缀表达式的关系，可以得出：</p>
<p><code>codeWrite(exp):</code></p>
<ul>
<li>如果 <code>exp</code> 是整数 <code>n</code> -&gt; <code>push n</code></li>
<li>变量 <code>var</code> -&gt; <code>push var</code></li>
<li><code>exp1 op exp2</code> -&gt; <code>codeWrite(exp1); codeWrite(exp2); op</code></li>
<li><code>op exp</code> -&gt; <code>codeWrite(exp); op</code></li>
<li><code>f(exp1, exp2, ...)</code> -&gt; <code>codeWrite(exp1); codeWrite(exp1); ... call f</code></li>
</ul>
<p><em>再次重申 Jack 语言是没有操作符优先级的</em></p>
<h2 id="处理控制流-Handling-Flow-of-Control">处理控制流 Handling Flow of Control</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E7%BC%96%E8%AF%91if%E8%AF%AD%E5%8F%A5.webp" alt="编译if语句"></p>
<p><code>while</code> 则更简单：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E7%BC%96%E8%AF%91while%E8%AF%AD%E5%8F%A5.webp" alt="编译while语句"></p>
<p><em>注意处理多个 if-while 和嵌套 if-while</em></p>
<h2 id="处理对象：低层级方面-Handling-Objects-Low-Level-Aspects">处理对象：低层级方面 Handling Objects: Low-Level Aspects</h2>
<ul>
<li>高级 OO 程序创建和操作对象和数组</li>
<li>中级 VM 程序在虚拟内存段上操作</li>
<li>低级机器程序直接在 RAM 上操作</li>
</ul>
<p><strong>而编译的难题就在于建立桥梁</strong></p>
<ul>
<li>对象数据通过 <code>this</code> 段访问</li>
<li>数组数据通过 <code>that</code> 段访问</li>
<li>在使用这些段之前，必须先用 <code>pointer</code> 锚定</li>
</ul>
<h2 id="处理对象：构造-Handling-Objects-Construction">处理对象：构造 Handling Objects: Construction</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E7%BC%96%E8%AF%91%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.webp" alt="编译构造函数"></p>
<h2 id="处理对象：操作-Handling-Objects-Manipulation">处理对象：操作 Handling Objects: Manipulation</h2>
<p>将 OO 风格转为过程风格：<code>p1.distance(p2)</code> -&gt; <code>distance(p1, p2)</code></p>
<p>因为每个方法都需要访问对象的 <code>fields</code>，即通过 <code>this i</code> 访问第 <code>i</code> 个 <code>field</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E7%BC%96%E8%AF%91%E6%96%B9%E6%B3%95.webp" alt="编译方法"></p>
<p>对于 <code>void</code> 方法，返回一个 <code>constant 0</code>，并在调用后立刻 <code>pop temp 0</code> 释放掉</p>
<h2 id="处理数组-Handling-Arrays">处理数组 Handling Arrays</h2>
<p>将数组名赋予内存地址，使用 <code>that</code> 访问数组的位置，如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs vm">// arr[2] = 17<br>push arr<br>push 2<br>add<br>pop pointer 1<br>push 17<br>pop that 0<br></code></pre></td></tr></table></figure>
<p><em>注意和对象不同，that 指向的是数组中的某一个元素</em></p>
<p>对于更复杂一些的情况（例如两边都有数组），则使用 <code>temp</code> 暂存右边的值，所以正确的写法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">//arr[expression1]=expression2,<br>push arr<br>计算并 push expression1 的值<br>add<br>计算并 push expression2 的值<br>pop temp 0 // temp 0 = expression2, 栈顶值为 arr[expression1] 的地址<br>pop pointer1<br>push temp 0<br>pop that e<br></code></pre></td></tr></table></figure>
<p>这个方案也适用于多重数组嵌套</p>
<h2 id="对虚拟机的标准映射-Standard-Mapping-Over-the-Virtual-Machine">对虚拟机的标准映射 Standard Mapping Over the Virtual Machine</h2>
<p>文件和子过程：</p>
<ul>
<li>每个文件 <code>fileName.jack</code> 被编译为 <code>fileName.vm</code></li>
<li>每个 <code>fileName.jack</code> 中的子过程 <code>subName</code> 被编译为 VM 函数 <code>fileName.subName</code></li>
<li>一个 k 个参数的 <code>constructor</code> 或 <code>function</code> 被编译为有 k 个参数的 VM 函数</li>
<li>一个有 k 个参数的 Jack <code>method</code>被编译为有 k+1 个参数的 VM 函数</li>
</ul>
<p>变量：</p>
<ul>
<li><code>local</code> 变量映射到虚拟段 <code>local</code></li>
<li><code>argument</code> 变量映射到虚拟段 <code>argument</code></li>
<li><code>static</code> 变量映射到虚拟段 <code>static</code></li>
<li><code>field</code> 变量：
<ul>
<li>假设 <code>pointer 0</code> 为 <code>this</code> 对象</li>
<li>该对象的第 i 个 field 映射到 <code>this i</code></li>
</ul>
</li>
</ul>
<p>数组：</p>
<ul>
<li>将 <code>pointer 1</code> 设为地址 <code>arr + i</code></li>
<li>通过 <code>this 0</code> 访问</li>
</ul>
<p>编译子过程：</p>
<ul>
<li><code>method</code>：设置 <code>this</code> 段的地址为 <code>argument 0</code></li>
<li><code>constructor</code>：
<ul>
<li>对新的对象分配空间，设置 <code>this</code> 为新的对象地址</li>
<li>返回 <code>this</code></li>
</ul>
</li>
<li><code>void</code>：返回 <code>constant 0</code></li>
</ul>
<p>调用子过程：将参数放入栈中，调用子过程</p>
<ul>
<li>如果是 <code>method</code>，则先将该对象的引用放入，再放入参数并调用</li>
<li>如果是 <code>void</code>，则在结束后 <code>pop</code> 掉</li>
</ul>
<p>常数：</p>
<ul>
<li><code>null</code> -&gt; <code>constant 0</code></li>
<li><code>false</code> -&gt; <code>constant 0</code></li>
<li><code>true</code> -&gt; <code>constant -1</code></li>
</ul>
<h1>操作系统 Operating System</h1>
<h2 id="操作系统-Operating-System">操作系统 Operating System</h2>
<p>包括的内容：</p>
<ul>
<li>游戏时间分析</li>
<li>资源管理</li>
<li>处理输入</li>
<li>向量图形</li>
<li>文字输出</li>
<li>类型转换</li>
<li>字符串处理</li>
</ul>
<h2 id="效率很重要-Efficiency-Matters">效率很重要 Efficiency Matters</h2>
<p>对于乘法，使用二进制的乘法竖式计算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">// 计算 x * y<br>multiply(x, y):<br>	sum = 0<br>	shiftedX = x<br>	for i = 0 ... w - 1 do<br>		if ((y 的第 i 位) == 1)<br>			sum = sum + shiftedX<br>		shiftedX = shiftedX * 2<br>	return sum<br></code></pre></td></tr></table></figure>
<ul>
<li>
<p>该算法正比于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>=</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">w = \log_2 N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p>
</li>
<li>
<p>对于负数，该算法同样有效</p>
</li>
<li>
<p>对于溢出，该算法总是返回正确答案 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace></mspace><mspace width="0.6666666666666666em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><msup><mn>2</mn><mn>16</mn></msup></mspace></mrow><annotation encoding="application/x-tex">\mod 2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span></p>
</li>
</ul>
<p>对于其中的获取第 i 位的操作，定义一个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">function boolean bit(int x, int i)<br></code></pre></td></tr></table></figure>
<p>初始化 <code>Math</code> 类时生成一个数组，存入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">2^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span>，使用该数组来实现 <code>bit(x, i)</code></p>
<h2 id="数学操作-Mathematical-Operations">数学操作 Mathematical Operations</h2>
<p>对于除法，一种方法同样是模拟除法的竖式</p>
<p>这里给出第二种方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">// 计算 x / y<br>divide(x, y):<br>	if (y &gt; x) return 0<br>	q = divide(x, 2 * y)<br>	if ((x - 2 * q * y) &lt; y)<br>		return 2 * q<br>	else<br>		return 2 * q + 1<br></code></pre></td></tr></table></figure>
<p>该算法的基本思想是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">/</mi><mn>7</mn><mo>=</mo><mn>2</mn><mo>∗</mo><mo stretchy="false">(</mo><mn>50</mn><mi mathvariant="normal">/</mi><mn>7</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mo>∗</mo><mo stretchy="false">(</mo><mn>2</mn><mo>∗</mo><mo stretchy="false">(</mo><mn>25</mn><mi mathvariant="normal">/</mi><mn>7</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">100 / 7 = 2 * (50 / 7) = 2 * (2 * (25 / 7)) = ...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">/</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mord">0</span><span class="mord">/</span><span class="mord">7</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord">5</span><span class="mord">/</span><span class="mord">7</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.10556em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></p>
<ul>
<li>
<p>运行时间正比于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">\log_2 N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p>
</li>
<li>
<p>处理负数时，计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>x</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">∣</mi><mi>y</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|x| / |y|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord">/</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">∣</span></span></span></span>，再设置符号</p>
</li>
<li>
<p>处理溢出：当 y 变成负数时，溢出可以被检测到，故将第一句改为 <code>if (y &gt; x || y &lt; 0) return 0</code></p>
</li>
</ul>
<p>平方根：反函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">x^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 很容易计算，故策略为找到一个使得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>y</mi><mn>2</mn></msup><mo>≤</mo><mi>x</mi><mo>&lt;</mo><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">y^2 ≤ x &lt; (y+1)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>，通过二分搜索 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>…</mo><msup><mn>2</mn><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 … 2^{n/2} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9713299999999999em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">// 计算函数 y = sqrt(x)<br>sqrt(x):<br>	y = 0<br>	for j = n / 2 - 1 ... 0 do<br>		if (y + 2^j)^2 &lt;= x then y = y + 2^j<br>	return y<br></code></pre></td></tr></table></figure>
<p>对于溢出，将 <code>(y + 2^j)^2 &lt;= x</code> 改为 <code>(y + 2^j)^2 &lt;= x &amp;&amp; (y + 2^j)^2 &gt; 0</code></p>
<h2 id="内存访问-Memory-Access">内存访问 Memory Access</h2>
<p>直接设置数组名指针为 0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">class Memory &#123;<br>	static array ram;<br><br>	function void init() &#123;<br>		let ram = 0;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="堆管理-Heap-Management">堆管理 Heap Management</h2>
<p>将可用的内存段连成一个链表</p>
<ul>
<li><code>alloc(size)</code>：寻找合适大小的内存段，将其从段中移除，交给客户</li>
<li><code>dealloc(object)</code>：将该对象连到链表中</li>
</ul>
<p>当然，这样做到最后就会有很多碎片内存段</p>
<p>实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">static Array heap;<br>let heap = 2048<br></code></pre></td></tr></table></figure>
<p>使用 <code>heap</code> 数组实现，地址 <code>arr</code> 的内存段的 <code>next</code> 和 <code>size</code> 可以通过 <code>heap[adr - 1]</code> 和 <code>heap[addr - 2]</code> 实现</p>
<h2 id="图形-Graphics">图形 Graphics</h2>
<p>向量图保存图形的画法，放大后不失真；位图保存像素，放大后失真</p>
<p>设置某一个像素颜色的命令与之前的类似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">function void drawPixel(int x, int y) &#123;<br>	address = 32 * y + x / 16<br>	value = Memory.peek[16384 + address]<br>	设置 value 的第 (x % 16) 位为当前颜色<br>	do Memory.poke(address, value)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="画线-Line-Drawing">画线 Line Drawing</h2>
<p>大概是近似方格覆盖线，其中决定是向上覆盖方格还是向右覆盖方格由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>b</mi><mi>a</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{b}{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{dy}{dx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 的大小关系决定</p>
<p>但每次计算太耗时，令 <code>diff = a * dy - b * dx</code>，观察每次 <code>a</code> 和 <code>b</code> 的改变，可以得出 <code>diff</code> 的改变</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">a = 0; b = 0; diff = 0;<br>while ((a &lt;= dx) &amp;&amp; (b &lt;= dy))<br>	drawPixel(x + a, y + b);<br>	if (diff &lt; 0) &#123;a = a + 1; diff = diff + dy;&#125;<br>	else &#123;b = b + 1; diff = diff - dx;&#125;<br></code></pre></td></tr></table></figure>
<p>画圆：将实心圆转化为从上往下画一条条水平线，线的左右端点位置可以通过勾股定理得出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">drawCircle(x, y, r)<br>	for each dy = -r to r do:<br>		drawLine(x - sqrt(r^2 - dy^2), y + dy, x + sqrt(r^2 - dy^2), y + dy)<br></code></pre></td></tr></table></figure>
<p>空心圆则只需要画两个像素点即可</p>
<p>注意：</p>
<ul>
<li>
<p>屏幕的原点在左上角</p>
</li>
<li>
<p>将算法推广到能画任何方向的线段</p>
</li>
<li>
<p>对于水平和竖直方向的线做特殊优化</p>
</li>
<li>
<p>对于溢出，限制 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>≤</mo><mn>181</mn></mrow><annotation encoding="application/x-tex">r ≤ 181</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">8</span><span class="mord">1</span></span></span></span></p>
</li>
</ul>
<h2 id="处理文字输出-Handling-Textual-Output">处理文字输出 Handling Textual Output</h2>
<ul>
<li>每个字符占据了固定大小的 11px 高，8px 宽的框架</li>
<li>右边有两个空列，底部有一个空行</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/%E5%AD%97%E7%AC%A6%E9%9B%86.webp" alt="字符集"></p>
<p>在初始化时预先加载到内存中</p>
<p>光标：</p>
<ul>
<li><code>newLine</code>：移动光标到下一行的开头</li>
<li><code>backspace</code>：光标左移一列</li>
<li>字符：显示字符，光标右移一列</li>
</ul>
<h2 id="输入-Input">输入 Input</h2>
<p>比较简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">keyPressed():<br>	if 键盘被按下:<br>		return key 的代码<br>	else<br>		return 0<br><br>readChar():<br>	显示光标<br>	// 等待直到一个键被按下<br>	while (keyPressed() == 0):<br>		什么都不做<br>	c = 当前按下的键<br>	// 等待直到该键松开<br>	while (keyPressed() != 0):<br>		什么都不做<br>	在当前光标位置显示 c<br>	移动光标<br><br>readLine():<br>	str = 空字符串<br>	重复<br>		c = readChar()<br>		if (c == newLine):<br>			显示 newLine<br>			return str<br>		else if (c == backSpace):<br>			从 str 中移除最后的字符<br>			do Output.backspace()<br>		else<br>			str = str.append(c)<br>	return str<br></code></pre></td></tr></table></figure>
<h2 id="字符串处理-String-Processing">字符串处理 String Processing</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">// 将整数转化为字符串<br>int2String(val):<br>	lastDigit = val % 10<br>	c = 代表 lastDigit 的字符<br>	if (val &lt; 10)<br>		return c<br>	else<br>		return int2String(val / 10).append(c)<br><br>// 将字符串转化为整数<br>string2Int(str):<br>	val = 0<br>	for (i = 0 ... str.length) do<br>		d = str[i] 的整数值<br>		val = val * 10 + d<br>	return val<br></code></pre></td></tr></table></figure>
<p>字符串本身就是一个 <code>Array</code></p>
<h2 id="数组处理-Array-Processing">数组处理 Array Processing</h2>
<ul>
<li><code>Array.new</code> 不要作为一个 constructor，而是作为一个 function，使用 <code>Memory.alloc</code></li>
<li><code>Array.dispose</code> 使用 <code>Memory.deAlloc</code></li>
</ul>
<h2 id="Sys-类-The-Sys-Class">Sys 类 The Sys Class</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jack">class Sys &#123;<br>	function void init() &#123;<br>		do Math.init();<br>		do Memory.init();<br>		do Screen.init();<br>		...<br>		do Main.main();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>
<p><code>Sys.halt</code>：使用无限循环实现</p>
</li>
<li>
<p><code>Sys.wait</code>：使用循环实现，和机器相关</p>
</li>
</ul>
<h1>更多乐趣 More Fun To Go</h1>
<p>还有很多细节是没有涉及到的，感谢两位老师，“路漫漫其修远兮，吾将上下而求索”</p>
<p>​</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B8%8C%E4%BC%AF%E6%9D%A5%E5%A4%A7%E5%AD%A6/">希伯来大学</a><a class="post-meta__tags" href="/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">体系结构</a></div><div class="post_share"><div class="social-share" data-image="/gallery/cover/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/1185a02e.html" title="意料之外，情理之中"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/%E6%AC%A7%E4%BA%A8%E5%88%A9.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">意料之外，情理之中</div></div></a></div><div class="next-post pull-right"><a href="/posts/b0fa4c58.html" title="UCB CS126：概率论"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/UCB%20CS126%EF%BC%9A%E6%A6%82%E7%8E%87%E8%AE%BA.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">UCB CS126：概率论</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="iconfont icon-tuijian"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/f1252f66.html" title="ETH Zurich：数字设计与计算机体系结构"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-25</div><div class="title">ETH Zurich：数字设计与计算机体系结构</div></div></a></div><div><a href="/posts/518e2799.html" title="UCB CS61C：计算机架构的伟大思想"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/UCB%20CS61C%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%B6%E6%9E%84%E7%9A%84%E4%BC%9F%E5%A4%A7%E6%80%9D%E6%83%B3.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-24</div><div class="title">UCB CS61C：计算机架构的伟大思想</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/%E5%A4%B4%E5%83%8F_%E7%81%B0%E5%A4%AA%E7%8B%BC.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">old_driver_zero</div><div class="author-info__description">我一定会回来的</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">183</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/old-driver-zero" target="_blank" title="GitHub" rel="external nofollow noopener noreferrer"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-github"/></svg></a><a class="social-icon faa-parent animated-hover" href="mailto:2771503468@qq.com" target="_blank" title="QQ邮箱" rel="external nofollow noopener noreferrer"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"/></svg></a><a class="social-icon faa-parent animated-hover" href="https://steamcommunity.com/id/old_driver_zero" target="_blank" title="Steam" rel="external nofollow noopener noreferrer"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-steam"/></svg></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><a class="faa-parent animated-hover"><svg class="faa-tada icon" style="height:25px;width:25px;fill:currentColor;position:relative;top:5px" aria-hidden="true"><use xlink:href="#icon-mulu"/></svg></a><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">布尔函数和逻辑门 Boolean Functions and Gate Logic</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91-Boolean-Logic"><span class="toc-number">1.1.</span> <span class="toc-text">布尔逻辑 Boolean Logic</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E5%87%BD%E6%95%B0%E5%90%88%E6%88%90-Boolean-Functions-Synthesis"><span class="toc-number">1.2.</span> <span class="toc-text">布尔函数合成 Boolean Functions Synthesis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E9%97%A8-Logic-Gates"><span class="toc-number">1.3.</span> <span class="toc-text">逻辑门 Logic Gates</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80-Hardware-Description-Language"><span class="toc-number">1.4.</span> <span class="toc-text">硬件描述语言 Hardware Description Language</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%A8%A1%E6%8B%9F-Hardware-Simulation"><span class="toc-number">1.5.</span> <span class="toc-text">硬件模拟 Hardware Simulation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%AF%94%E7%89%B9%E6%80%BB%E7%BA%BF-Multi-bit-Buses"><span class="toc-number">1.6.</span> <span class="toc-text">多比特总线 Multi-bit Buses</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">布尔代数和 ALU Boolean Arithmetic and the ALU</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E5%AD%97-Binary-Numbers"><span class="toc-number">2.1.</span> <span class="toc-text">二进制数字 Binary Numbers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95-Binary-Addition"><span class="toc-number">2.2.</span> <span class="toc-text">二进制加法 Binary Addition</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9F%E6%95%B0-Negative-Numbers"><span class="toc-number">2.3.</span> <span class="toc-text">负数 Negative Numbers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83-ALU"><span class="toc-number">2.4.</span> <span class="toc-text">算术逻辑单元 ALU</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">内存 Memory</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E9%80%BB%E8%BE%91-Sequential-Logic"><span class="toc-number">3.1.</span> <span class="toc-text">序列逻辑 Sequential Logic</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8-Flip-Flops"><span class="toc-number">3.2.</span> <span class="toc-text">触发器 Flip Flops</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83-Memory-Units"><span class="toc-number">3.3.</span> <span class="toc-text">内存单元 Memory Units</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8-Counters"><span class="toc-number">3.4.</span> <span class="toc-text">计时器 Counters</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">机器语言 Machine Language</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%B4%A0-Elements"><span class="toc-number">4.1.</span> <span class="toc-text">元素 Elements</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%91%E5%AE%A2%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%92%8C%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80-The-Hack-Computer-and-Machine-Language"><span class="toc-number">4.2.</span> <span class="toc-text">黑客计算机和机器语言 The Hack Computer and Machine Language</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%91%E5%AE%A2%E8%AF%AD%E8%A8%80%E8%AF%A6%E8%BF%B0-Hack-Language-Specification"><span class="toc-number">4.3.</span> <span class="toc-text">黑客语言详述 Hack Language Specification</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA-Input-Output"><span class="toc-number">4.4.</span> <span class="toc-text">输入-输出 Input-Output</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B-Hack-Programming"><span class="toc-number">4.5.</span> <span class="toc-text">黑客编程 Hack Programming</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98"><span class="toc-number">4.5.1.</span> <span class="toc-text">处理寄存器和内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF"><span class="toc-number">4.5.2.</span> <span class="toc-text">分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">4.5.3.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3"><span class="toc-number">4.5.4.</span> <span class="toc-text">迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">4.5.5.</span> <span class="toc-text">指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">计算机结构 Computer Architecture</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84-Von-Neumann-Architecture"><span class="toc-number">5.1.</span> <span class="toc-text">冯诺依曼结构 Von Neumann Architecture</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-%E6%89%A7%E8%A1%8C%E5%BE%AA%E7%8E%AF-The-Fetch-Execute-Cycle"><span class="toc-number">5.2.</span> <span class="toc-text">获取-执行循环 The Fetch-Execute Cycle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8-Central-Processing-Unit"><span class="toc-number">5.3.</span> <span class="toc-text">中央处理器 Central Processing Unit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%91%E5%AE%A2%E8%AE%A1%E7%AE%97%E6%9C%BA-The-Hack-Computer"><span class="toc-number">5.4.</span> <span class="toc-text">黑客计算机 The Hack Computer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">汇编器 Assembler</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%92%8C%E6%B1%87%E7%BC%96%E5%99%A8-Assembly-Languages-and-Assemblers"><span class="toc-number">6.1.</span> <span class="toc-text">汇编语言和汇编器 Assembly Languages and Assemblers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%91%E5%AE%A2%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%BF%BB%E8%AF%91%E8%80%85%E7%9A%84%E7%AB%8B%E5%9C%BA-The-Hack-Assembly-Language-A-Translator%E2%80%99s-Perspective"><span class="toc-number">6.2.</span> <span class="toc-text">黑客汇编语言：一个翻译者的立场 The Hack Assembly Language: A Translator’s Perspective</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%BF%87%E7%A8%8B%EF%BC%9A%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4-The-Assembly-Process-Handling-Instructions"><span class="toc-number">6.3.</span> <span class="toc-text">汇编过程：处理指令 The Assembly Process: Handling Instructions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%BF%87%E7%A8%8B%EF%BC%9A%E5%A4%84%E7%90%86%E7%AC%A6%E5%8F%B7-The-Assembly-Process-Handling-Symbols"><span class="toc-number">6.4.</span> <span class="toc-text">汇编过程：处理符号 The Assembly Process: Handling Symbols</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E9%BB%91%E5%AE%A2%E6%B1%87%E7%BC%96%E5%99%A8%EF%BC%9A%E5%BB%BA%E8%AE%AE%E8%BD%AF%E4%BB%B6%E7%BB%93%E6%9E%84-Developing-a-Hack-Assembler-Proposed-Software-Architecture"><span class="toc-number">6.5.</span> <span class="toc-text">开发一个黑客汇编器：建议软件结构 Developing a Hack Assembler: Proposed Software Architecture</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">虚拟机 I：栈算术 Virtual Machine I: Stack Arithmetic</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E9%A2%84%E8%A7%88-Program-Compilation-Preview"><span class="toc-number">7.1.</span> <span class="toc-text">程序编译预览 Program Compilation Preview</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8A%BD%E8%B1%A1%EF%BC%9A%E6%A0%88-VM-Abstraction-the-Stack"><span class="toc-number">7.2.</span> <span class="toc-text">虚拟机抽象：栈 VM Abstraction: the Stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8A%BD%E8%B1%A1%EF%BC%9A%E5%86%85%E5%AD%98%E6%AE%B5-VM-Abstraction-Memory-Segments"><span class="toc-number">7.3.</span> <span class="toc-text">虚拟机抽象：内存段 VM Abstraction: Memory Segments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E7%8E%B0%EF%BC%9A%E6%A0%88-VM-Implementation-the-Stack"><span class="toc-number">7.4.</span> <span class="toc-text">虚拟机实现：栈 VM Implementation: the Stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E7%8E%B0%EF%BC%9A%E5%86%85%E5%AD%98%E6%AE%B5-VM-Implementation-Memory-Segments"><span class="toc-number">7.5.</span> <span class="toc-text">虚拟机实现：内存段 VM Implementation: Memory Segments</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">虚拟机 II：程序控制 Virtual Machine II: Program Control</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6-Program-Control"><span class="toc-number">8.1.</span> <span class="toc-text">程序控制 Program Control</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF-Branching"><span class="toc-number">8.2.</span> <span class="toc-text">分支 Branching</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%EF%BC%9A%E6%8A%BD%E8%B1%A1-Functions-Abstraction"><span class="toc-number">8.3.</span> <span class="toc-text">函数：抽象 Functions: Abstraction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8C%E8%BF%94%E5%9B%9E%EF%BC%9A%E5%AE%9E%E7%8E%B0%E9%A2%84%E8%A7%88-Function-Call-and-Return-Implementation-Preview"><span class="toc-number">8.4.</span> <span class="toc-text">函数调用和返回：实现预览 Function Call and Return: Implementation Preview</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8C%E8%BF%94%E5%9B%9E%EF%BC%9A%E8%BF%90%E8%A1%8C%E6%A8%A1%E6%8B%9F-Function-Call-and-Return-Run-time-Simulation"><span class="toc-number">8.5.</span> <span class="toc-text">函数调用和返回：运行模拟 Function Call and Return: Run-time Simulation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8C%E8%BF%94%E5%9B%9E%EF%BC%9A%E5%AE%9E%E7%8E%B0-Function-Call-and-Return-Implementation"><span class="toc-number">8.6.</span> <span class="toc-text">函数调用和返回：实现 Function Call and Return: Implementation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E9%BB%91%E5%AE%A2%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84-VM-%E5%AE%9E%E7%8E%B0-VM-Implementation-on-the-Hack-Platform"><span class="toc-number">8.7.</span> <span class="toc-text">在黑客平台上的 VM 实现 VM Implementation on the Hack Platform</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">高级语言 High-Level Language</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Jack-%E8%AF%AD%E8%A8%80%E6%A6%82%E8%AE%BA-The-Jack-Language-in-a-nutshell"><span class="toc-number">9.1.</span> <span class="toc-text">Jack 语言概论 The Jack Language in a nutshell</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-Object-Based-Programming"><span class="toc-number">9.2.</span> <span class="toc-text">基于对象编程 Object-Based Programming</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86-List-Processing"><span class="toc-number">9.3.</span> <span class="toc-text">列表处理 List Processing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Jack-%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83%EF%BC%9A%E8%AF%AD%E6%B3%95-Jack-Language-Specification-Syntax"><span class="toc-number">9.4.</span> <span class="toc-text">Jack 语言规范：语法 Jack Language Specification: Syntax</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Jack-%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Jack-Language-Specification-Data-Types"><span class="toc-number">9.5.</span> <span class="toc-text">Jack 语言规范：数据类型 Jack Language Specification: Data Types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Jack-%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83%EF%BC%9A%E7%B1%BB-Jack-Language-Specification-Classes"><span class="toc-number">9.6.</span> <span class="toc-text">Jack 语言规范：类 Jack Language Specification: Classes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Jack-%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83%EF%BC%9A%E6%96%B9%E6%B3%95-Jack-Language-Specification-Methods"><span class="toc-number">9.7.</span> <span class="toc-text">Jack 语言规范：方法 Jack Language Specification: Methods</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Jack-%E8%AF%AD%E8%A8%80%E5%92%8C-OS-%E6%9D%A5%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-Developing-Apps-using-the-Jack-Language-and-OS"><span class="toc-number">9.8.</span> <span class="toc-text">使用 Jack 语言和 OS 来开发应用程序 Developing Apps using the Jack Language and OS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">编译器 I：语法分析 Compiler I: Syntax Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-Syntax-Analysis"><span class="toc-number">10.1.</span> <span class="toc-text">语法分析 Syntax Analysis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%8D%E6%B1%87%E5%88%86%E6%9E%90-Lexical-Analysis"><span class="toc-number">10.2.</span> <span class="toc-text">词汇分析 Lexical Analysis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-Grammars"><span class="toc-number">10.3.</span> <span class="toc-text">语法 Grammars</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E6%A0%91-Parse-Trees"><span class="toc-number">10.4.</span> <span class="toc-text">解析树 Parse Trees</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%99%A8%E9%80%BB%E8%BE%91-Parser-Logic"><span class="toc-number">10.5.</span> <span class="toc-text">解析器逻辑 Parser Logic</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Jack-%E8%AF%AD%E6%B3%95-The-Jack-Grammar"><span class="toc-number">10.6.</span> <span class="toc-text">Jack 语法 The Jack Grammar</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Jack-%E5%88%86%E6%9E%90-The-Jack-Analysis"><span class="toc-number">10.7.</span> <span class="toc-text">Jack 分析 The Jack Analysis</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">编译器 II：代码生成 Compiler II: Code Generation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90-Code-Generation"><span class="toc-number">11.1.</span> <span class="toc-text">代码生成 Code Generation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%8F%98%E9%87%8F-Handling-Variables"><span class="toc-number">11.2.</span> <span class="toc-text">处理变量 Handling Variables</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E8%A1%A8%E8%BE%BE%E5%BC%8F-Handling-Expressions"><span class="toc-number">11.3.</span> <span class="toc-text">处理表达式 Handling Expressions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%8E%A7%E5%88%B6%E6%B5%81-Handling-Flow-of-Control"><span class="toc-number">11.4.</span> <span class="toc-text">处理控制流 Handling Flow of Control</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%AF%B9%E8%B1%A1%EF%BC%9A%E4%BD%8E%E5%B1%82%E7%BA%A7%E6%96%B9%E9%9D%A2-Handling-Objects-Low-Level-Aspects"><span class="toc-number">11.5.</span> <span class="toc-text">处理对象：低层级方面 Handling Objects: Low-Level Aspects</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%AF%B9%E8%B1%A1%EF%BC%9A%E6%9E%84%E9%80%A0-Handling-Objects-Construction"><span class="toc-number">11.6.</span> <span class="toc-text">处理对象：构造 Handling Objects: Construction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%AF%B9%E8%B1%A1%EF%BC%9A%E6%93%8D%E4%BD%9C-Handling-Objects-Manipulation"><span class="toc-number">11.7.</span> <span class="toc-text">处理对象：操作 Handling Objects: Manipulation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84-Handling-Arrays"><span class="toc-number">11.8.</span> <span class="toc-text">处理数组 Handling Arrays</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%A0%87%E5%87%86%E6%98%A0%E5%B0%84-Standard-Mapping-Over-the-Virtual-Machine"><span class="toc-number">11.9.</span> <span class="toc-text">对虚拟机的标准映射 Standard Mapping Over the Virtual Machine</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">操作系统 Operating System</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Operating-System"><span class="toc-number">12.1.</span> <span class="toc-text">操作系统 Operating System</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%88%E7%8E%87%E5%BE%88%E9%87%8D%E8%A6%81-Efficiency-Matters"><span class="toc-number">12.2.</span> <span class="toc-text">效率很重要 Efficiency Matters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E6%93%8D%E4%BD%9C-Mathematical-Operations"><span class="toc-number">12.3.</span> <span class="toc-text">数学操作 Mathematical Operations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE-Memory-Access"><span class="toc-number">12.4.</span> <span class="toc-text">内存访问 Memory Access</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E7%AE%A1%E7%90%86-Heap-Management"><span class="toc-number">12.5.</span> <span class="toc-text">堆管理 Heap Management</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2-Graphics"><span class="toc-number">12.6.</span> <span class="toc-text">图形 Graphics</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%BB%E7%BA%BF-Line-Drawing"><span class="toc-number">12.7.</span> <span class="toc-text">画线 Line Drawing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%96%87%E5%AD%97%E8%BE%93%E5%87%BA-Handling-Textual-Output"><span class="toc-number">12.8.</span> <span class="toc-text">处理文字输出 Handling Textual Output</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5-Input"><span class="toc-number">12.9.</span> <span class="toc-text">输入 Input</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86-String-Processing"><span class="toc-number">12.10.</span> <span class="toc-text">字符串处理 String Processing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86-Array-Processing"><span class="toc-number">12.11.</span> <span class="toc-text">数组处理 Array Processing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sys-%E7%B1%BB-The-Sys-Class"><span class="toc-number">12.12.</span> <span class="toc-text">Sys 类 The Sys Class</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">更多乐趣 More Fun To Go</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>不必要做的事不做，必须做的一律从简</div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/comments/">留点什么</a><a href="/random/">随便逛逛</a></li><li><a href="/about/">关于</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/gallery/">我的画廊</a><a href="/charts/">网站统计</a></li></ul></div></div></div></div><div class="copyright">&copy;2022 - 2024 By old_driver_zero</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async src="//at.alicdn.com/t/c/font_4031045_1yiosqv4vch.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.22.0/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.63.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.12.0"></script></div></div></html>