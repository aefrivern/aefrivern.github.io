<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>UCB CS61B：数据结构与算法 | old-driver-zeroの小屋</title><meta name="author" content="old_driver_zero"><meta name="copyright" content="old_driver_zero"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="介绍 先来个Helloword： public class Helloworld &amp;#123;     public static void main(String[] args) &amp;#123;         System.out.println(&quot;Hello world&quot;);     &amp;#125; &amp;#125;  Java 的特点：  所有代码都必须在类里面 语句组用大括号"><meta property="og:type" content="article"><meta property="og:title" content="UCB CS61B：数据结构与算法"><meta property="og:url" content="https://old-driver-zero.github.io/posts/7ea0cbe4.html"><meta property="og:site_name" content="old-driver-zeroの小屋"><meta property="og:description" content="介绍 先来个Helloword： public class Helloworld &amp;#123;     public static void main(String[] args) &amp;#123;         System.out.println(&quot;Hello world&quot;);     &amp;#125; &amp;#125;  Java 的特点：  所有代码都必须在类里面 语句组用大括号"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://old-driver-zero.github.io/gallery/cover/UCB%20CS61B%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.webp"><meta property="article:published_time" content="2023-01-30T06:22:44.000Z"><meta property="article:modified_time" content="2023-03-29T05:44:27.194Z"><meta property="article:author" content="old_driver_zero"><meta property="article:tag" content="Java"><meta property="article:tag" content="计算机科学"><meta property="article:tag" content="UC Berkeley"><meta property="article:tag" content="数据结构"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://old-driver-zero.github.io/gallery/cover/UCB%20CS61B%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.webp"><link rel="shortcut icon" href="/illustration/favicon.ico"><link rel="canonical" href="https://old-driver-zero.github.io/posts/7ea0cbe4.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//hm.baidu.com"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?da75f0595ffd5e578744142f5a6a471e";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>const GLOBAL_CONFIG={root:"/",algolia:{appId:"GY5EJYJ1FS",apiKey:"c443c952672ec7062840aac45536181e",indexName:"blog",hits:{per_page:10},languages:{input_placeholder:"搜索文章",hits_empty:"找不到您查询的内容：${query}",hits_stats:"找到 ${hits} 条结果，用时 ${time} 毫秒"}},localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:void 0,copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!0,post:!0},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1,percent:{toc:!0,rightside:!1}}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"UCB CS61B：数据结构与算法",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-03-29 13:44:27"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)})),e.getCSS=(e,t=!1)=>new Promise(((o,n)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=e,t&&(a.id=t),a.onerror=n,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,o())},document.head.appendChild(a)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/pointer.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/transpancy.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/scrollbar.css"><link rel="stylesheet" href="/css/barber-shop.css"><link rel="stylesheet" href="/css/one graph flow.css"><link rel="stylesheet" href="/css/navigation bar.css"><link rel="stylesheet" href="/css/neon light at night.css"><link rel="stylesheet" href="/css/article title.css"><link rel="stylesheet" href="/css/wide screen.css"><link rel="stylesheet" href="/css/card author.css"><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><script src="https://npm.elemecdn.com/echarts@4.9.0/map/js/china.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"><style>#recent-posts>.recent-post-item>.recent-post-info>.article-meta-wrap>.tags:before{content:"\A";white-space:pre}#recent-posts>.recent-post-item>.recent-post-info>.article-meta-wrap>.tags>.article-meta__separator{display:none}</style><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload='this.media="screen"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/%E5%A4%B4%E5%83%8F_%E7%81%B0%E5%A4%AA%E7%8B%BC.webp" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i> <span>画廊</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div><div class="menus_item"><a class="site-page" href="/charts/"><i class="fa-fw fas fa-bar-chart"></i> <span>统计</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comments"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/random/"><i class="fa-fw fas fa-random"></i> <span>随便逛逛</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('/gallery/cover/UCB%20CS61B%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="old-driver-zeroの小屋"><span class="site-name">old-driver-zeroの小屋</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i> <span>画廊</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div><div class="menus_item"><a class="site-page" href="/charts/"><i class="fa-fw fas fa-bar-chart"></i> <span>统计</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comments"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/random/"><i class="fa-fw fas fa-random"></i> <span>随便逛逛</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">UCB CS61B：数据结构与算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-30T06:22:44.000Z" title="发表于 2023-01-30 14:22:44">2023-01-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-29T05:44:27.194Z" title="更新于 2023-03-29 13:44:27">2023-03-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">1w</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>49分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><link rel="stylesheet" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>介绍</h1><p>先来个<code>Helloword</code>：</p><pre><code class="language-Java">public class Helloworld &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;Hello world&quot;);
    &#125;
&#125;
</code></pre><p>Java 的特点：</p><ol><li>所有代码都必须在类里面</li><li>语句组用大括号，语句末用分号</li><li>变量使用前先声明</li><li>变量类型是确定的，且不可变（静态语言）</li><li>注意<code>public</code>，<code>private</code>等</li><li>函数参数需要声明类型，返回值也是</li><li>所有 Java 中的函数都是<strong>方法</strong></li></ol><p>确定变量类型的优点：</p><ul><li>运行速度快</li><li>可读性强</li><li>减少类型错误</li></ul><p>缺点：</p><ul><li>代码复杂</li></ul><h1>类 class 的使用</h1><p>假如有这样一个类：</p><pre><code class="language-Java">public class Dog &#123;
    public int weight;

    public Dog(int startingweight) &#123;
        weight = startingweight;
    &#125;

    public static void makeNoise_static() &#123;
        System.out.println(&quot;bark&quot;);
    &#125;

    public void makeNoise_non_static() &#123;
        if (weight &lt; 10)
            System.out.println(&quot;bark&quot;);
        else
            System.out.println(&quot;woof&quot;);
    &#125;
&#125;
</code></pre><p>使用如下：</p><pre><code class="language-Java">public class Doglauncher &#123;
    public static void main(String[] args) &#123;
        Dog smallDog; // 声明一个 Dog 变量
        new Dog(20); // 实例化对象
        smallDog = new Dog(5); // 同时 实例化对象 并 赋值
        Dog hugeDog = new Dog(150); // 同时 声明 实例化 并 赋值
    &#125;
&#125;
</code></pre><h2 id="static-静态">static 静态</h2><ul><li>static 方法用类名调用，如<code>Dog.makeNoise_static()</code></li><li>non-static 方法用实例化名称调用，如<code>smalldog.makeNoise_static()</code></li><li>static 方法不能访问实例化变量，如<code>makeNoise_non_static</code>中不能使用变量<code>weight</code></li></ul><p>为什么要使用 static 方法？</p><p>对于<code>Math</code>类来说，往往不需要实例化，如使用<code>x=Math.round(5.6)</code>比<code>Math m = new Math(); x = m.round(x);</code>更自然</p><p>可以同时拥有 static method 和 non-static method：</p><pre><code class="language-Java">public static Dog maxDog(Dog d1, Dog d2) &#123;
    if (d1.weight &gt; d2.weight) &#123;
        return d1;
    &#125;
    return d2;
&#125;

public Dog maxDog(Dog d2) &#123;
    if (weight &gt; d2.weight) &#123;
        return this;
    &#125;
    return d2;
&#125;
</code></pre><p>静态变量：<code>public static String name = &quot;dog&quot;;</code></p><h1>测试 Test</h1><p>可以使用<code>junit</code>：</p><pre><code class="language-Java">public class Test &#123;
    public static String stringMax(String a, String b) &#123;
        if (a.compareTo(b) &lt; 0)
            return b;
        return a;
    &#125;

    public static void testStringMax() &#123;
        String[] input = &#123; &quot;a&quot;, &quot;b&quot; &#125;;
        String expected = &quot;a&quot;;

        String actual = stringMax(input[0], input[1]);
        org.junit.Assert.assertEquals(expected, actual);
    &#125;

    public static void main(String[] args) &#123;
        testStringMax();
    &#125;
&#125;
</code></pre><h1>引用 Reference</h1><pre><code class="language-Java">public static void main(String[] args) &#123;
    Dog a = new Dog(5);
    Dog b = a;
    b.weight = 10;
    System.out.println(a.weight);
    System.out.println(b.weight);
&#125;
</code></pre><p>输出均为 10，表示<code>b</code>只是<code>a</code>的一个引用，并不是复制了一份</p><h1>SLList 单链表、嵌套类、哨兵 Sentinel 节点</h1><pre><code class="language-Java">public class SLList &#123;
    // sentinel.next是链表的第一个元素
    private IntNode sentinel;
    private int size;

    private static class IntNode &#123;
        int item;
        IntNode next;

        IntNode(int i, IntNode n) &#123;
            item = i;
            next = n;
        &#125;
    &#125;

    public SLList() &#123;
        sentinel = new IntNode(-1, null);
        size = 0;
    &#125;

    public SLList(int x) &#123;
        sentinel = new IntNode(-1, null);
        sentinel.next = new IntNode(x, null);
        size = 1;
    &#125;

    public void addFirst(int x) &#123;
        sentinel.next = new IntNode(x, sentinel.next);
        size += 1;
    &#125;

    public int getFirst() &#123;
        return sentinel.next.item;
    &#125;

    public void addLast(int x) &#123;
        IntNode p = sentinel;
        while (p.next != null) &#123;
            p = p.next;
        &#125;
        p.next = new IntNode(x, null);
        size += 1;
    &#125;

    public int size() &#123;
        return size;
    &#125;
&#125;
</code></pre><p>其中的<strong>不变量 invariants</strong>有：</p><ul><li>sentinel 总是指向一个 sentinel 节点</li><li>第一个节点永远是 sentinel</li><li>size 变量永远是元素总数</li></ul><h1>DLLists 双向链表、Array 数组、Generic 泛型</h1><h2 id="双向链表-DLLists">双向链表 DLLists</h2><p>解决特殊情况的方法：</p><ol><li>在链表末端也加入一个哨兵；</li><li>使用循环链表</li></ol><h2 id="泛型-Generic">泛型 Generic</h2><p>在类名称后面添加<code>&lt;Type_name&gt;</code>，在把相应的类型名改为<code>Type_name</code>，但注意在声明时要指定类型名，如<code>SLList&lt;String&gt; L = new SLList&lt;String&gt;(&quot;hello&quot;);</code></p><p>声明或实例化时，使用引用类型：<br><code>int</code>→<code>Integer</code>、<code>double</code>→<code>Double</code>、<code>char</code>→<code>Character</code>、<code>boolean</code>→<code>Boolean</code>、<code>long</code>→<code>Long</code></p><h2 id="数组-Array">数组 Array</h2><p>有以下几种实例化方法：</p><ul><li><code>x = new int[3];</code></li><li><code>y = new int[]&#123;1,2,3,4,5&#125;;</code></li><li><code>int []z = &#123;7,8,9&#125;;</code></li></ul><p>和类一样，<code>x=y;</code>表示<code>x</code>更改为<code>y</code>的引用，数组复制为：</p><p><code>System.arraycopy(b, 0, x, 3, 2)</code>从<code>b[0]</code>开始复制 2 个元素到<code>x[3]</code>及其后面</p><p>多维数组：<code>int[][] matrix = new int[4][4];</code></p><h1>AList</h1><p>Alist 是用数组重设大小实现的快速访问其中某个元素的动态数组</p><pre><code class="language-Java">public class AList&lt;Item_type&gt; &#123;
    private Item_type[] items;
    private int size;

    public AList() &#123;
        size = 0;
        items = (Item_type[]) new Object[100];
    &#125;

    private void resize(int capacity) &#123;
        Item_type[] a = (Item_type[]) new Object[capacity];// 不允许泛型数组，只能先创造一个对象，再强制转化为Item_type
        System.arraycopy(items, 0, a, 0, size);
        items = a;
    &#125;

    public void addLast(Item_type x) &#123;
        if (size == items.length)
            resize(size * 2);// 当数组存满时倍增大小
        items[size] = x;
        size += 1;
    &#125;

    public Item_type removeLast() &#123;
        Item_type x = getLast();
        size -= 1;
        return x;
    &#125;

    public Item_type deleteLast() &#123;
        Item_type returnItem = getLast();
        items[size - 1] = null; // 当一个对象失去最后一个引用时，会被当作垃圾收集并释放内存
        size -= 1;
        return returnItem;
    &#125;

    public Item_type getLast() &#123;
        return items[size - 1];
    &#125;

    public Item_type get(int i) &#123;
        return items[i];
    &#125;

    public int size() &#123;
        return size;
    &#125;
&#125;
</code></pre><h1>继承 Inheritance</h1><p><strong>签名 signature</strong>指函数名和参数等</p><p><strong>覆盖 overriding</strong>是说子类和父类有一样签名的方法</p><p><strong>重载 overloading</strong>是说有相同名字但不同签名的方法</p><pre><code class="language-Java">public interface Animal &#123;
    public void makenoise();
&#125;
public class Pig implements Animal &#123;

    // 这是覆盖 overriding
    @Override //可加可不加，但加了有利于查错
    public void makenoise() &#123;
        System.out.println(&quot;onik&quot;);
    &#125;

    // 这是重载 overloading
    public void makenoise(Pig a) &#123;
        System.out.println(&quot;oniks&quot;);
    &#125;
&#125;
</code></pre><h2 id="接口继承-Interface-Inheritance-和-实现继承-Implement-Inheritance">接口继承 Interface Inheritance 和 实现继承 Implement Inheritance</h2><pre><code class="language-Java">public interface List&lt;Item_type&gt; &#123;

    /* 以下这些是接口继承 Interface Inheritance： */
    public void addLast(Item_type x);

    public int size();

    public Item_type getFirst();

    public Item_type get(int i);

    /* 这是实现继承 Implement Inheritance： */
    default public void print() &#123;
        for (int i = 0; i &lt; size(); i++) &#123;
            System.out.print(get(i) + &quot; &quot;);
        &#125;
        System.out.println();
    &#125;

    public static void main(String[] args) &#123;
        List&lt;Integer&gt; L1 = new SLList&lt;Integer&gt;();// 可以用子类的实例化
        L1.addLast(10);
        L1.addLast(11);
        L1.addLast(12);
        L1.print();

        List&lt;Integer&gt; L2 = new AList&lt;Integer&gt;();
        L2.addLast(10);
        L2.addLast(11);
        L2.addLast(12);
        L2.print(); // Alist中没有print()，却能使用
    &#125;
&#125;

public class SLList&lt;Item_type&gt; implements List&lt;Item_type&gt; &#123;

    /*此处省略大量代码*/

    // 因为SLList的特殊性，使用List中的print()方法效率低下，所以重载
    @Override
    public void print() &#123;
        IntNode p = sentinel.next;
        while (p != null) &#123;
            System.out.print(p.item + &quot; &quot;);
            p = p.next;
        &#125;
        System.out.println();
    &#125;
&#125;
</code></pre><p>实现继承破坏了<strong>封装 Encapsulation</strong></p><h2 id="静态类型-Static-Type-和动态类型-Dynamic-Type">静态类型 Static Type 和动态类型 Dynamic Type</h2><p><strong>静态类型 Static Type</strong>：变量声明时的类型，永不改变；</p><p><strong>动态类型 Dynamic Type</strong>：运行时的类型，由实例化时和<code>=</code>赋值时决定</p><p>代码在编译时使用静态类型，在运行时使用动态类型</p><pre><code class="language-Java">public interface Animal &#123;
    default void greet (Animal a) &#123;
        print(&quot;hello animal&quot;);
    &#125;
    default void sniff (Animal a) &#123;
        print(&quot;sniff animal&quot;);
    &#125;
    default void praise (Animal a) &#123;
        print(&quot;cool animal&quot;);
    &#125;
&#125;
public class Dog implements Animal &#123;
    @Override
    void sniff(Animal a) &#123;
        print(&quot;dog sniff animal&quot;);
    &#125;
    void praise(Dog a) &#123;
        print(&quot;cool dog&quot;);
    &#125;
&#125;
</code></pre><p><code>Animal a = new Dog();</code><br><code>Dog d = new Dog();</code></p><table><thead><tr><th>代码</th><th>编译的接口</th><th>运行</th></tr></thead><tbody><tr><td><code>a.greet(d);</code></td><td><code>greet(Animal a)</code></td><td><code>&quot;hello animal&quot;</code></td></tr><tr><td><code>a.sniff(d);</code></td><td><code>sniff(Animal a)</code></td><td><code>&quot;dog sniff animal&quot;</code></td></tr><tr><td><code>d.praise(d);</code></td><td><code>praise(Dog a)</code></td><td><code>&quot;cool dog&quot;</code></td></tr><tr><td><code>a.praise(d);</code></td><td><code>praise(Animal a)</code></td><td><code>&quot;cool animal&quot;</code></td></tr></tbody></table><p>Java 中已经有了<code>list</code>，<code>ArrayList</code>、<code>LinkedList</code>等都是其一种实现形式</p><pre><code class="language-Java">java.util.List&lt;Integer&gt; L = new java.util.ArrayList&lt;&gt;();
L.add(5);
L.add(6);
L.add(7);
System.out.print(L);
</code></pre><h1>延伸 Extend</h1><pre><code class="language-Java">public class RotatingSLList&lt;Item_type&gt; extends SLList&lt;Item_type&gt; &#123;
    public void rotate() &#123;
        Item_type oldBack = removeLast();
        addFirst(oldBack);
    &#125;

    public static void main(String[] args) &#123;
        RotatingSLList&lt;Integer&gt; L = new RotatingSLList&lt;&gt;();
        L.addLast(10);
        L.addLast(11);
        L.addLast(12);
        L.rotate();
        L.print();
    &#125;
&#125;
</code></pre><p>其中<code>RotatingSLList</code>拥有父类<code>SLList</code>的所有成员，并增加了<code>rotate</code></p><pre><code class="language-Java">public class VengefulSLList&lt;Item_type&gt; extends SLList&lt;Item_type&gt; &#123;
    private SLList&lt;Item_type&gt; deletedItems;

    public VengefulSLList() &#123;
        // super();可加可不加，若不加，默认先执行超类的constructor
        deletedItems = new SLList&lt;Item_type&gt;();
    &#125;

    @Override
    public Item_type removeLast() &#123;
        Item_type oldBack = super.removeLast(); // 使用超类的removeLast()
        deletedItems.addLast(oldBack);
        return oldBack;
    &#125;
&#125;
</code></pre><p>Java 中每一个类型都是 Object 的<strong>子孙 descendant</strong>，都有<code>equal()</code>、<code>toString()</code>等成员函数</p><h1>高阶函数 Higher Order Function</h1><p>可以使用一个类来实现：</p><pre><code class="language-Java">public interface IntUnaryFunction &#123;
    int apply(int x);
&#125;
public class TenX implements IntUnaryFunction &#123;

    // 返回10 * x
    public int apply(int x) &#123;
        return 10 * x;
    &#125;
&#125;
public class HigherOrderFunction &#123;
    public static int do_twice(IntUnaryFunction f, int x) &#123;
        return f.apply(f.apply(x));
    &#125;

    public static void main(String[] args) &#123;
        IntUnaryFunction tenX = new TenX();
        System.out.print(do_twice(tenX, 2));
    &#125;
&#125;
</code></pre><p>显性实现：</p><pre><code class="language-Python">def print_larger(x, y, compare, stringify):
    if compare(x, y):
        return stringify(x)
    return stringify(y)
</code></pre><p><strong>子类型多态 Subtype Polymorphism</strong>实现：</p><pre><code class="language-Python">def print_larger(x, y):
    if x.largerThan(x):
        return x.str()
    return y.str()
</code></pre><p>类似的，在 Java 中，使用一个接口类来实现：</p><pre><code class="language-Java">/* 提供一个接口 */
public interface Comparable&lt;T&gt; &#123;
    public int compareTo(T obj);
&#125;

public class Dog implements Comparable&lt;Dog&gt; &#123;
    private String name;
    public int size;

    public Dog(String n, int s) &#123;
        name = n;
        size = s;
    &#125;

    // 重载Dog类型的实现
    public int compareTo(Dog other) &#123;
        return size - other.size;
    &#125;
&#125;

//调用通用手段
public class Maximizer &#123;
    public static Comparable max(Comparable[] items) &#123;
        int maxDex = 0;
        for (int i = 0; i &lt; items.length; i += 1)
            if (items[i].compareTo(items[maxDex]) &gt; 0)
                maxDex = i;
        return items[maxDex];
    &#125;
&#125;

//可以使用
public class DogLauncher &#123;
    public static void main(String[] args) &#123;
        Dog d1 = new Dog(&quot;aaa&quot;, 16);
        Dog d2 = new Dog(&quot;ezsu&quot;, 19);
        Dog d3 = new Dog(&quot;iu&quot;, 6);
        Dog[] dogs = new Dog[] &#123; d1, d2, d3 &#125;;
        Dog d = (Dog) Maximizer.max(dogs);
        System.out.println(d.size);
    &#125;
&#125;
</code></pre><p>也可以使用内置的<code>Comparator</code>：</p><pre><code class="language-Java">import java.util.Comparator;

public class Dog &#123;
    public String name;
    private int size;

    public Dog(String n, int s) &#123;
        name = n;
        size = s;
    &#125;

    public int compareTo(Dog other) &#123;
        return size - other.size;
    &#125;

    private static class NameComparator implements Comparator&lt;Dog&gt; &#123;
        public int compare(Dog a, Dog b) &#123;
            return a.name.compareTo(b.name);
        &#125;
    &#125;

    public static Comparator&lt;Dog&gt; getNameComparator() &#123;
        return new NameComparator();
    &#125;
&#125;

public class DogLauncher &#123;
    public static void main(String[] args) &#123;
        Dog d1 = new Dog(&quot;aaa&quot;, 16);
        Dog d2 = new Dog(&quot;ezsu&quot;, 19);

        Comparator&lt;Dog&gt; nc = Dog.getNameComparator();
        if (nc.compare(d1, d2) &gt; 0)
            System.out.println(d1.name);
        else
            System.out.println(d2.name);
    &#125;
&#125;
</code></pre><h1>异常 Exceptions、迭代器 Iterators 和 特殊对象方法</h1><pre><code class="language-Java">Set&lt;Integer&gt; javaset = new HashSet&lt;&gt;();
javaset.add(256);
javaset.add(42);
javaset.add(378);

for (int i : javaset)
    System.out.println(i);
// 实质为迭代器
Iterator&lt;Integer&gt; seer = javaset.iterator();
while (seer.hasNext())
    System.out.println(seer.next());
</code></pre><pre><code class="language-Java">
// import java.util.ArrayList;
import java.util.Iterator;
// import java.util.List;

public class ArraySet&lt;T&gt; implements Iterable&lt;T&gt; &#123; // 注意要引入接口Iterable
    private T[] items;
    private int size;

    public ArraySet() &#123;
        items = (T[]) new Object[100];
        size = 0;
    &#125;

    public static &lt;T&gt; ArraySet&lt;T&gt; of(T... stuff) &#123; // ...表示任意数量的元素
        ArraySet&lt;T&gt; returnSet = new ArraySet&lt;&gt;();
        for (T x : stuff)
            returnSet.add(x);
        return returnSet;
    &#125;

    public boolean contains(T x) &#123;
        for (int i = 0; i &lt; size; i += 1)
            if (x.equals(items[i]))
                return true;
        return false;
    &#125;

    public void add(T x) &#123;
        if (x == null) &#123;
            throw new IllegalArgumentException(&quot;无法添加null到ArraySet中&quot;); // 对输入null的抛出异常
        &#125;
        if (contains(x))
            return;
        items[size] = x;
        size += 1;
    &#125;

    public int size() &#123;
        return size;
    &#125;

    // 用与之前NameCompare相似的方法实现
    private class ArraySetIterator implements Iterator&lt;T&gt; &#123;
        private int wizPos;

        public ArraySetIterator() &#123;
            wizPos = 0;
        &#125;

        public boolean hasNext() &#123;
            return wizPos &lt; size;
        &#125;

        public T next() &#123;
            T returnItem = items[wizPos];
            wizPos += 1;
            return returnItem;
        &#125;
    &#125;

    public Iterator&lt;T&gt; iterator() &#123;
        return new ArraySetIterator();
    &#125;

    @Override
    public String toString() &#123;
        // 对于字符串s，s += 某个字符串 的速度很慢（实质为复制和重建），所以改用StringBuilder
        StringBuilder returnString = new StringBuilder(&quot;&#123;&quot;);
        for (int i = 0; i &lt; size - 1; i += 1) &#123;
            returnString.append(items[i].toString());
            returnString.append(&quot;, &quot;);
        &#125;
        returnString.append(items[size - 1].toString());
        returnString.append(&quot;&#125;&quot;);
        return returnString.toString();

        /*
         * 还有一种类似于Python中join函数的简便方法
         * List&lt;String&gt; listOfItems = new ArrayList&lt;&gt;();
         * for (T x : this)
         * listOfItems.add(x.toString());
         * return String.join(&quot;, &quot;, listOfItems);
         */
    &#125;

    @Override
    public boolean equals(Object other) &#123; // 注意接口是 Object other
        if (other == null)
            return false;
        if (this == other) // 对自身相等的优化
            return true;
        if (other.getClass() != getClass())
            return false;
        ArraySet&lt;T&gt; o = (ArraySet&lt;T&gt;) other;
        if (o.size != size) // 对于大小不同的集合的优化
            return false;
        for (T item : this)
            if (!o.contains(item))
                return false;
        return true;
    &#125;

    public static void main(String[] args) &#123;
        ArraySet&lt;Integer&gt; s = new ArraySet&lt;&gt;();
        s.add(256);
        s.add(42);
        s.add(378);

        ArraySet&lt;Integer&gt; s2 = ArraySet.of(378, 42, 256);
        s2.add(256);
        s2.add(42);
        s2.add(378);

        for (int i : s) // 可以使用缩写了
            System.out.println(i);

        System.out.println(s);// 自动调用toString()方法

        System.out.println(s.equals(1));
        System.out.println(s.equals(s2));
    &#125;
&#125;
</code></pre><h1>Project 2: Gitlet</h1><p>这是我写过的最长的代码，总共 1153 行；这也是我看过的最长的英语文档，光是说明就有 14181 个词；这也是我收获最大的项目，在 CS61A 中，我所做的工作不过是在已经基本完成的项目代码上添加一些东西，而且这些东西的具体实现方法都已经有了详细的说明，那时，我就一直想知道自己什么时候才能独立完成像那样的项目，而在 CS61B 的这个 project 中，我做到了。</p><p>从对整个问题的一脸茫然，到摸索其中的基本原理，再到写设计文档时的混乱思绪，再到写代码时一行行地改进、一遍遍地调试，再到反复阅读要求考虑特殊情况和算法效率，最后完成对代码的优化。这一个 project 带给我的好处远远不止于此。</p><p>先附上成就感满满的满分截图：</p><p>![满分！][1]</p><h2 id="设计文档">设计文档</h2><h3 id="类与数据结构">类与数据结构</h3><ol><li><p><strong>Main</strong></p><p>程序的切入点，接收命令行的参数并相应地调用 <code>Repository</code> 中的函数，并检查参数是否能正确调用函数，该类仅仅起到检查参数并调用对应函数的效果</p></li><li><p><strong>Repository</strong></p><p>程序的主要部分，实现了命令行要求的功能、维护持久化、添加错误信息等</p><p>该类将所有对文件的具体逻辑阻隔到 <code>Blob</code> 中</p><ul><li><code>public static final File CWD = new File(System.getProperty(&quot;user.dir&quot;));</code> 当前工作目录，对于其它的文件对象很有用</li><li><code>public static final File GITLET_DIR = join(CWD, &quot;.gitlet&quot;);</code> 隐藏的 <code>.gitlet</code> 目录，当前所有对文件的维护都是在此目录中进行的</li><li><code>public static final File LOCAL_GITLET_DIR = join(CWD, &quot;.gitlet&quot;);</code> 与前面的类似，但是在处理远程操作时，需要使用这个作为本地的工作目录</li><li><code>private static final Stage STAGE = new Stage();</code> 暂存区的实例，用于维护其中的文件</li></ul><p>这些域都是静态的，因为我不需要实例化 <code>Repository</code> 类，该类仅仅适用于存放函数</p></li><li><p><strong>Blob</strong></p><p>该类代表储存在文件中的每个 blob，因为每个 blob 都有一个独特的 sha1，就使用它来当作对象序列化的文件名称</p><ul><li><code>static final File BLOBS_FOLDER = join(Repository.GITLET_DIR, &quot;blobs&quot;);</code>序列化后的 blob 储存的位置，因为所有 blob 都存在同一个地方，所以是<code>static</code>的</li><li><code>private final byte[] contents</code>blob 储存的内容</li><li><code>private final String blobId</code>blob 的 id，这些 id 是独特的</li></ul></li><li><p><strong>Commit</strong></p><p>此类代表储存在文件中的每个 commit 信息，因为每个 commit 都有一个独特的 sha1，用其当作序列化的文件名称</p><ul><li><code>static final File COMMIT_FOLDER = join(Repository.GITLET_DIR, &quot;commits&quot;);</code>序列化后的 commit 储存的位置，因为所有 commit 都存在同一个地方，所以是<code>static</code>的</li><li><code>private final String message</code> commit 信息</li><li><code>private final Date timestamp</code> commit 的时间</li><li><code>private final String commitId</code> commit 的 id，这些 id 是独特的</li><li><code>private final String firstParentId</code> commit 的第一个父亲的 id</li><li><code>private final String secondParentId</code> commit 第二个父亲的 id，只有 merge 后的 commit 有</li><li><code>private HashMap&lt;String, String&gt; blobs</code> commit 中储存的 blob 名字映射到 blobId，便于查找文件名对应的文件</li></ul></li><li><p><strong>Stage</strong></p><p>用于维护 <code>add</code> 和 <code>rm</code> 等操作的暂存区</p><ul><li><code>protected TreeMap&lt;String, String&gt; stagedFiles;</code> 暂存的文件列表</li><li><code>protected TreeSet&lt;String&gt; removedFiles;</code> 被移除的文件的文件名</li><li><code>public static final File STAGING_AREA = join(GITLET_DIR, &quot;staging area&quot;);</code> 暂存文件所在文件夹</li><li><code>public static final File STAGE_FILE = join(GITLET_DIR, &quot;stage&quot;);</code> 存放暂存文件信息的文件路径</li></ul></li><li><p><strong>Branch</strong></p><p>维护对分支的添加、删除和持久化的类</p><ul><li><code>protected static File HEADS_FOLDER = join(GITLET_DIR, &quot;heads&quot;);</code> 存放各 branch 的 HEADs 的文件夹</li><li><code>protected static File CURRENT_BRANCH = join(GITLET_DIR, &quot;current branch&quot;);</code> 存放当前 branch 名称的文件</li></ul><p>这些域都是静态的，因为我不需要实例化 <code>Branch</code> 类，该类仅仅适用于存放函数</p></li><li><p><strong>Remote</strong></p><p>维护对远程仓库的添加、删除和持久化的类</p><ul><li><code>public static final File REMOTE_FOLDER = join(LOCAL_GITLET_DIR, &quot;remote&quot;);</code> 存放远程 gitlet 路径的文件夹</li></ul><p>这些域都是静态的，因为我不需要实例化 <code>Remote</code> 类，该类仅仅适用于存放函数</p></li><li><p><strong>Utils</strong></p><p>题目提供的类，包含了有用的序列化操作</p><ul><li><code>static final int UID_LENGTH = 40</code> SHA-1 的 16 进制长度，用于检查是否合法</li></ul></li><li><p><strong>GitletException</strong></p><p>通用化 gitlet 中的错误</p></li></ol><h3 id="算法">算法</h3><p>![merge操作的几种情况汇总][2]</p><p><code>merge</code> 操作是公认的最为困难的操作了，情况非常复杂，分成几个部分</p><p>在查找 <code>splitPoint</code> 时，通过维护两个 commit 的所有祖先节点信息（包括 commitId 和同该 commit 的距离），搜索两者的祖先中共同的祖先，且其与两者的距离之和最小，则该祖先为最近公共祖先，即 <code>splitPoint</code> ，此算法满足时间复杂度要求</p><h3 id="持久化">持久化</h3><p>目录结构如下：</p><ul><li>.gitlet &lt;==== 所有持久化数据都存储在此<ul><li>blobs &lt;==== 所有的 blob 都存在这个目录<ul><li>blobId1 &lt;==== 每个单独的 blob 实例</li><li>blobId2</li><li>…</li><li>blobIdN</li></ul></li><li>commits &lt;==== 所有的 commit 都存在这个目录<ul><li>commitId1 &lt;==== 每个单独的 commit 实例</li><li>commitId2</li><li>…</li><li>commitIdN</li></ul></li><li>heads &lt;==== 所有的头指针都存在这个目录<ul><li>master &lt;==== 每个分支的 head 实例</li></ul></li><li>staging area &lt;==== 所有 add 操作添加还没有 commit 的 blob 都暂存在这个目录<ul><li>blobId1 &lt;==== 每个单独的 blob 实例</li><li>blobId2</li><li>…</li><li>blobIdN</li></ul></li><li>remote &lt;==== 所有的远程仓库的位置都记录在这个目录<ul><li>origin &lt;==== 每个远程仓库的位置</li></ul></li></ul></li></ul><ol><li><p><strong><code>init</code></strong></p><ul><li><code>Repository</code> 类将会创建这些文件夹：<code>.gitlet</code>、<code>.commits</code>、<code>.blobs</code>、<code>heads</code>、<code>remote</code></li><li><code>Commit</code> 类将会创建第一个节点并序列化写入到名称为 commitId 的文件中</li><li><code>Branch</code><ul><li>创建主分支文件，并将第一个 commit 的 commitId 写入到该文件中</li><li>创建当前分支文件，并将主分支名称写入到该分支文件中</li></ul></li></ul></li><li><p><strong><code>add [file name]</code></strong></p><ul><li>如果该文件和当前 commit 中的文件相同：<ul><li>若 <code>staging area</code> 中没有该文件，无事发生</li><li>若 <code>staging area</code> 中有该文件，删除该文件</li></ul></li><li>若不同，则添加该文件到 <code>staging area</code> 中</li></ul></li><li><p><strong><code>commit [message]</code></strong></p><ul><li>将 <code>staging area</code> 中的文件移动到 <code>blobs</code> 中</li><li>创建一个新的 commit</li><li>将 commitId 写入到当前分支的文件中</li></ul></li><li><p><strong><code>rm [file name]</code></strong></p><ul><li>如果 <code>staging area</code> 中有该文件，则移除该文件</li><li>如果该文件存在于当前目录中，则删除该文件</li></ul></li><li><p><strong><code>checkout -- [file name]</code></strong> 和 <strong><code>checkout [commit id] -- [file name]</code></strong></p><p>从 commit 处获取文件的 blob，并将该 blob 中的内容复制到指定文件中</p></li><li><p><strong><code>checkout [branch name]</code></strong></p><p>类似，但是恢复 commit 中的所有文件</p></li><li><p><strong><code>branch [branch name]</code></strong></p><ul><li><code>Branch</code> 类中创建该分支文件</li><li>将当前 commit 的 commitId 写入到该文件中</li></ul></li><li><p><strong><code>rm-branch [branch name]</code></strong></p><p><code>Branch</code> 类中删除该分支文件</p></li><li><p><strong><code>reset [commit id]</code></strong></p><p>类似于 <code>checkout [branch name]</code> 的操作，但多了一步向当前分支的文件中写入 commitId</p></li><li><p><strong><code>merge [branch name]</code></strong></p><p>情况很复杂，不再赘述</p></li><li><p><strong><code>add-remote [remote name] [name of remote directory]/.gitlet</code></strong></p><p><code>Remote</code> 类创建 remote name 的文件，并将目录写入其中</p></li><li><p><strong><code>rm-remote [remote name]</code></strong></p><p><code>Remote</code> 类删除 remote name 的文件</p></li><li><p><strong><code>push [remote name] [remote branch name]</code></strong></p><ul><li>将本地 gitlet 的所有 commit 文件都复制到远程仓库所在目录中</li><li>向远程仓库的当前分支的文件中写入最新的 commitId</li></ul></li><li><p><strong><code>fetch [remote name] [remote branch name]</code></strong></p><ul><li>将远程 gitlet 的所有 commit 和 blob 文件都复制到本地仓库</li><li>新建名称为 <code>[remote name]-[remote branch name]</code> 的分支文件</li><li>向该文件中写入远程仓库的最新的 commitId</li></ul></li><li><p><strong><code>pull [remote name] [remote branch name]</code></strong></p><p>同 <code>fetch</code> + <code>merge</code> 操作</p></li></ol><h2 id="代码">代码</h2><h3 id="Main">Main</h3><pre><code class="language-Java">package gitlet;

/** Driver class for Gitlet, a subset of the Git version-control system.
 *  @author old-driver-zero
 */
public class Main &#123;

    /** Usage: java gitlet.Main ARGS, where ARGS contains
     *  &lt;COMMAND&gt; &lt;OPERAND1&gt; &lt;OPERAND2&gt; ...
     */
    public static void main(String[] args) &#123;
        if (args.length == 0) &#123;
            throwException(&quot;Please enter a command.&quot;);
        &#125;
        String command = args[0];
        switch (command) &#123;
            case &quot;init&quot; -&gt; &#123;
                validArgs(args, 0);
                Repository.init();
            &#125;
            case &quot;add&quot; -&gt; &#123;
                validArgs(args, 1);
                isInitialized();
                Repository.add(args[1]);
            &#125;
            case &quot;commit&quot; -&gt; &#123;
                if (args.length == 1 || args[1].equals(&quot;&quot;)) &#123;
                    throwException(&quot;Please enter a commit message.&quot;);
                &#125;
                validArgs(args, 1);
                isInitialized();
                Repository.commit(args[1]);
            &#125;
            case &quot;rm&quot; -&gt; &#123;
                validArgs(args, 1);
                isInitialized();
                Repository.rm(args[1]);
            &#125;
            case &quot;log&quot; -&gt; &#123;
                validArgs(args, 0);
                isInitialized();
                Repository.log();
            &#125;
            case &quot;global-log&quot; -&gt; &#123;
                validArgs(args, 0);
                isInitialized();
                Repository.globalLog();
            &#125;
            case &quot;find&quot; -&gt; &#123;
                validArgs(args, 1);
                isInitialized();
                Repository.find(args[1]);
            &#125;
            case &quot;status&quot; -&gt; &#123;
                validArgs(args, 0);
                isInitialized();
                Repository.status();
            &#125;
            case &quot;checkout&quot; -&gt; &#123;
                isInitialized();
                if (args[1].equals(&quot;--&quot;)) &#123; // 第一种情况：从 HEAD 处恢复文件
                    validArgs(args, 2);
                    Repository.restore(args[2]);
                &#125; else if (args.length == 2) &#123; // 第三种情况：从 branchName 处恢复所有文件
                    Repository.switchTo(args[1]);
                &#125; else if (args[2].equals(&quot;--&quot;)) &#123; // 第二种情况：从 commitId 处恢复文件
                    validArgs(args, 3);
                    Repository.restore(args[1], args[3]);
                &#125; else &#123;
                    throwException(&quot;Incorrect operands.&quot;);
                &#125;
            &#125;
            case &quot;branch&quot; -&gt; &#123;
                isInitialized();
                validArgs(args, 1);
                Repository.branch(args[1]);
            &#125;
            case &quot;rm-branch&quot; -&gt; &#123;
                isInitialized();
                validArgs(args, 1);
                Repository.rmBranch(args[1]);
            &#125;
            case  &quot;reset&quot; -&gt; &#123;
                isInitialized();
                validArgs(args, 1);
                Repository.reset(args[1]);
            &#125;
            case &quot;merge&quot; -&gt; &#123;
                isInitialized();
                validArgs(args, 1);
                Repository.merge(args[1]);
            &#125;
            case &quot;add-remote&quot; -&gt; &#123;
                isInitialized();
                validArgs(args, 2);
                Repository.addRemote(args[1], args[2]);
            &#125;
            case &quot;rm-remote&quot; -&gt; &#123;
                isInitialized();
                validArgs(args, 1);
                Repository.rmRemote(args[1]);
            &#125;
            case &quot;push&quot; -&gt; &#123;
                isInitialized();
                validArgs(args, 2);
                Repository.push(args[1], args[2]);
            &#125;
            case &quot;fetch&quot; -&gt; &#123;
                isInitialized();
                validArgs(args, 2);
                Repository.fetch(args[1], args[2]);
            &#125;
            case &quot;pull&quot; -&gt; &#123;
                isInitialized();
                validArgs(args, 2);
                Repository.pull(args[1], args[2]);
            &#125;
            default -&gt; throwException(&quot;No command with that name exists.&quot;);
        &#125;
    &#125;

    // 抛出错误信息
    public static void throwException(String msg) &#123;
        System.out.println(msg);
        System.exit(0);
    &#125;

    // 检查参数数量是否正确并抛出错误
    private static void validArgs(String[] args, int operandNum) &#123;
        if (args.length - 1 != operandNum) &#123;
            throwException(&quot;Incorrect operands.&quot;);
        &#125;
    &#125;

    // 检查是否存在 gitlet 并抛出错误
    private static void isInitialized() &#123;
        if (!Repository.GITLET_DIR.exists()) &#123;
            Main.throwException(&quot;Not in an initialized Gitlet directory.&quot;);
        &#125;
    &#125;
&#125;
</code></pre><h3 id="Repository">Repository</h3><pre><code class="language-Java">package gitlet;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.*;

import static gitlet.Blob.BLOBS_FOLDER;
import static gitlet.Branch.HEADS_FOLDER;
import static gitlet.Commit.COMMIT_FOLDER;
import static gitlet.Main.throwException;
import static gitlet.Remote.REMOTE_FOLDER;
import static gitlet.Stage.STAGING_AREA;
import static gitlet.Utils.*;


/** Represents a gitlet repository.
 *  does at a high level.
 *
 *  @author old-driver-zero
 */
public class Repository &#123;
    /*
      List all instance variables of the Repository class here with a useful
      comment above them describing what that variable represents and how that
      variable is used. We've provided two examples for you.
     */
    public static final File CWD = new File(System.getProperty(&quot;user.dir&quot;)); // 当前工作目录
    public static final File LOCAL_GITLET_DIR = join(CWD, &quot;.gitlet&quot;); // 本地 gitlet 文件夹目录
    protected static File GITLET_DIR = join(CWD, &quot;.gitlet&quot;); // 当前 gitlet 文件夹目录
    private static final Stage STAGE = new Stage(); //暂存区

    // 初始化仓库
    public static void init() &#123;
        if (GITLET_DIR.exists()) &#123;
            throwException(&quot;A Gitlet version-control system &quot;
                    + &quot;already exists in the current directory.&quot;);
        &#125;
        // 创建.gitlet, blobs, commits, heads, stage area 文件夹
        GITLET_DIR.mkdir();
        BLOBS_FOLDER.mkdir();
        COMMIT_FOLDER.mkdir();
        HEADS_FOLDER.mkdir();
        STAGING_AREA.mkdir();
        REMOTE_FOLDER.mkdir();

        // 创建空 commit 并将当前头指针指向该 commit
        Commit initCommit = new Commit();
        initCommit.save();

        Branch.create(&quot;master&quot;);
        Branch.setCurrentBranch(&quot;master&quot;);
        Branch.setCurrentBranchHead(initCommit);
    &#125;

    // 向暂存区中添加文件
    public static void add(String fileName) &#123;
        File file = join(CWD, fileName);
        if (!file.exists()) &#123;
            throwException(&quot;File does not exist.&quot;);
        &#125;
        Blob addBlob = new Blob(file);

        STAGE.add(addBlob, fileName);
        if (!currentCommit().isModified(addBlob, fileName)) &#123;
            STAGE.remove(fileName);
        &#125;
    &#125;

    // 从暂存区和当前 commit 中删除文件
    public static void rm(String fileName) &#123;
        if (STAGE.isStaged(fileName)) &#123; // 如果已经被暂存，则释放该文件
            STAGE.remove(fileName);
        &#125; else if (currentCommit().isTracked(fileName)) &#123; // 如果在当前 commit 中，则添加到 removed 名单中
            STAGE.stageForRemoval(fileName);
            File file = join(CWD, fileName);
            if (file.exists()) &#123;
                file.delete();
            &#125;
        &#125; else &#123; // 两者都不满足，抛出错误
            throwException(&quot;No reason to remove the file.&quot;);
        &#125;
    &#125;

    // 创建一个新的 commit 并移动当前指针
    public static void commit(String message) &#123;
        Commit newCommit = new Commit(STAGE, message);
        newCommit.save();
        STAGE.clear();

        Branch.setCurrentBranchHead(newCommit);
    &#125;

    // 从最新到最旧打印 commit 信息
    public static void log() &#123;
        Commit cur = currentCommit();
        StringBuilder s = new StringBuilder();
        while (cur != null) &#123;
            System.out.println(cur);
            s.append(cur);
            cur = cur.getFirstFather();
        &#125;
        writeContents(join(GITLET_DIR, &quot;log.txt&quot;), s.toString());
    &#125;

    // 无序打印所有 commit 信息
    public static void globalLog() &#123;
        for (Commit commit : Commit.getAllCommits()) &#123;
            System.out.println(commit);
        &#125;
    &#125;

    // 根据 commit 信息查找对应的 commitId
    public static void find(String message) &#123;
        boolean findOne = false;
        for (Commit commit : Commit.getAllCommits()) &#123;
            if (commit.getMessage().equals(message)) &#123;
                System.out.println(commit.getCommitId());
                findOne = true;
            &#125;
        &#125;
        if (!findOne) &#123;
            throwException(&quot;Found no commit with that message.&quot;);
        &#125;
    &#125;

    // 打印当前分支、暂存文件、标记为删除、修改但未暂存、untracked 的文件的状态
    public static void status() &#123;
        System.out.println(&quot;=== Branches ===&quot;);
        for (String branch : Branch.getAllBranches()) &#123;
            if (branch.equals(Branch.getCurrentBranch())) &#123;
                System.out.print(&quot;*&quot;);
            &#125;
            System.out.println(branch);
        &#125;
        System.out.println();

        System.out.println(&quot;=== Staged Files ===&quot;);
        System.out.println(STAGE.stagedFilesNames());

        System.out.println(&quot;=== Removed Files ===&quot;);
        System.out.println(STAGE.removedFilesNames());

        System.out.println(&quot;=== Modifications Not Staged For Commit ===&quot;);
        List&lt;String&gt; modifications = new ArrayList&lt;&gt;();
        List&lt;String&gt; list = plainFilenamesIn(CWD);
        if (list != null) &#123;
            Collections.sort(list);
        &#125;
        Commit currentCommit = currentCommit();
        if (list != null) &#123;
            for (String fileName : list) &#123;
                Blob file = new Blob(join(CWD, fileName));
                // 情况1：被 track，修改了未暂存
                if (currentCommit.isTracked(fileName) &amp;&amp; currentCommit.isModified(file, fileName)
                        &amp;&amp; !STAGE.isStaged(fileName)) &#123;
                    modifications.add(fileName + &quot; (modified)&quot;);
                &#125; else if (STAGE.isStaged(fileName) &amp;&amp; STAGE.isModified(file, fileName)) &#123;
                    // 情况2：暂存后又修改了
                    modifications.add(fileName + &quot; (modified)&quot;);
                &#125;
            &#125;
        &#125;
        // 情况3：暂存了，但又被删除了
        for (String fileName : STAGE.stagedFiles.keySet()) &#123;
            File file = join(CWD, fileName);
            if (!file.exists()) &#123;
                modifications.add(fileName + &quot; (deleted)&quot;);
            &#125;
        &#125;
        // 情况4：被 track，工作区中被删除了，但为暂存为删除
        for (String fileName : currentCommit.blobs.keySet()) &#123;
            File file = join(CWD, fileName);
            if (!file.exists() &amp;&amp; !STAGE.isRemoved(fileName)) &#123;
                modifications.add(fileName + &quot; (deleted)&quot;);
            &#125;
        &#125;
        Collections.sort(modifications);
        for (String modification : modifications) &#123;
            System.out.println(modification);
        &#125;
        System.out.println();

        System.out.println(&quot;=== Untracked Files ===&quot;);
        if (list != null) &#123;
            for (String fileName : list) &#123;
                if (!currentCommit.isTracked(fileName) &amp;&amp; !STAGE.isStaged(fileName)) &#123;
                    // 情况1：未被 track，未被暂存，但出现在工作区中
                    System.out.println(fileName);
                &#125; else if (STAGE.isRemoved(fileName)) &#123;
                    // 情况2：被暂存为删除，但出现在工作区中
                    System.out.println(fileName);
                &#125;
            &#125;
        &#125;
        System.out.println();
    &#125;

    // 第一种情况：从 HEAD 处恢复文件
    public static void restore(String fileName) &#123;
        currentCommit().restore(fileName, CWD);
    &#125;

    // 通过 commitId 的简写来获取完整的 commitId
    private static String getFullCommitId(String commitId) &#123;
        for (Commit commit : Commit.getAllCommits()) &#123;
            String thisId = commit.getCommitId();
            if (thisId.startsWith(commitId)) &#123;
                return thisId;
            &#125;
        &#125;
        throwException(&quot;No commit with that id exists.&quot;);
        return commitId;
    &#125;

    // 第二种情况：从 commitId 处恢复文件
    public static void restore(String commitId, String fileName) &#123;
        if (commitId.length() &lt; UID_LENGTH) &#123;
            commitId = getFullCommitId(commitId);
        &#125;
        Commit commit = Commit.fromFile(commitId);
        commit.restore(fileName, CWD);
    &#125;

    // 从选定 commitId 的 commit 中恢复所有文件
    private static void restoreFrom(String commitId) &#123;
        if (commitId.length() &lt; UID_LENGTH) &#123;
            commitId = getFullCommitId(commitId);
        &#125;
        List&lt;String&gt; list = plainFilenamesIn(CWD);
        Commit switchToBranch = Commit.fromFile(commitId);
        checkUntrackedFile(switchToBranch.getCommitId()); // 检查是否有 untracked 的文件会被覆盖
        if (list != null) &#123;
            for (String fileName : list) &#123;
                File file = join(CWD, fileName);
                // 所有当前分支被 tracked，目标分支未 tracked 的文件都删除
                if (currentCommit().isTracked(fileName) &amp;&amp; !switchToBranch.isTracked(fileName)) &#123;
                    file.delete();
                &#125;
            &#125;
        &#125;
        for (String fileName : switchToBranch.blobs.keySet()) &#123; // 从 switchToBranch 中恢复所有文件
            switchToBranch.restore(fileName, CWD);
        &#125;
        STAGE.clear(); // 清理 stage
    &#125;

    // 从 branch 中恢复所有文件并切换到该 branch
    public static void switchTo(String branchName) &#123;
        if (!Branch.exist(branchName)) &#123;
            throwException(&quot;No such branch exists.&quot;);
        &#125;
        if (branchName.equals(Branch.getCurrentBranch())) &#123;
            throwException(&quot;No need to checkout the current branch.&quot;);
        &#125;
        restoreFrom(Branch.getCommit(branchName).getCommitId());
        Branch.setCurrentBranch(branchName); // 修改当前 branch
    &#125;

    // 创建一个新 branch
    public static void branch(String branchName) &#123;
        if (Branch.exist(branchName)) &#123;
            throwException(&quot;A branch with that name already exists.&quot;);
        &#125;
        Branch.create(branchName);
        Branch.setBranchHead(branchName, currentCommit());
    &#125;

    // 移除给定的 branch
    public static void rmBranch(String branchName) &#123;
        if (!Branch.exist(branchName)) &#123;
            throwException(&quot;A branch with that name does not exist.&quot;);
        &#125;
        if (branchName.equals(Branch.getCurrentBranch())) &#123;
            throwException(&quot;Cannot remove the current branch.&quot;);
        &#125;
        Branch.remove(branchName);
    &#125;

    // 将所有文件恢复到 commitId 的状态并调整当前 branch 指向的 commit
    public static void reset(String commitId) &#123;
        restoreFrom(commitId);
        Branch.setCurrentBranchHead(Commit.fromFile(commitId));
    &#125;

    // 获取分裂点，即最近公共祖先
    private static Commit splitPoint(Commit branchA, Commit branchB) &#123;
        HashMap&lt;String, Integer&gt; ancestorA = branchA.ancestor(0);
        HashMap&lt;String, Integer&gt; ancestorB = branchB.ancestor(0);
        int minLength = Integer.MAX_VALUE;
        Commit splitPoint = new Commit();
        for (String commitId : ancestorA.keySet()) &#123;
            if (ancestorB.containsKey(commitId) &amp;&amp; minLength &gt; ancestorA.get(commitId)) &#123;
                minLength = ancestorA.get(commitId);
                splitPoint = Commit.fromFile(commitId);
            &#125;
        &#125;
        return splitPoint;
    &#125;

    // 合并当前 branch 和 branchName 的 branch
    public static void merge(String branchName) &#123;
        if (!STAGE.isEmpty()) &#123;
            throwException(&quot;You have uncommitted changes.&quot;);
        &#125;
        if (!Branch.exist(branchName)) &#123;
            throwException(&quot;A branch with that name does not exist.&quot;);
        &#125;
        if (branchName.equals(Branch.getCurrentBranch())) &#123;
            throwException(&quot;Cannot merge a branch with itself.&quot;);
        &#125;
        Commit givenCommit = Branch.getCommit(branchName);
        Commit currentCommit = currentCommit();
        checkUntrackedFile(givenCommit.getCommitId());
        Commit splitPoint = splitPoint(currentCommit, givenCommit);
        if (splitPoint.equals(givenCommit)) &#123;
            throwException(&quot;Given branch is an ancestor of the current branch.&quot;);
        &#125;
        if (splitPoint.equals(currentCommit)) &#123;
            switchTo(branchName);
            throwException(&quot;Current branch fast-forwarded.&quot;);
        &#125;
        Commit newCommit = new Commit(currentCommit, givenCommit,
                &quot;Merged &quot; + branchName + &quot; into &quot; + Branch.getCurrentBranch() + &quot;.&quot;);
        Set&lt;String&gt; fileNames = Commit.fileNames(currentCommit, givenCommit, splitPoint);
        boolean conflict = false;
        for (String fileName : fileNames) &#123;
            Blob currentFile = Blob.fromFile(currentCommit.blobs.get(fileName));
            Blob givenFile = Blob.fromFile(givenCommit.blobs.get(fileName));
            if (!splitPoint.isTracked(fileName) &amp;&amp; !givenCommit.isTracked(fileName)) &#123;
                // 情况4：只出现在当前 branch
                newCommit.add(fileName, currentCommit);
            &#125; else if (!splitPoint.isTracked(fileName) &amp;&amp; !currentCommit.isTracked(fileName)) &#123;
                // 情况5：只出现在 given branch
                newCommit.add(fileName, givenCommit);
                givenCommit.restore(fileName, CWD);
            &#125; else if (!splitPoint.isModified(currentFile, fileName)
                    &amp;&amp; !givenCommit.isTracked(fileName)) &#123;
                // 情况6：当前 branch 中的文件未修改，given branch 中已删除
                File removedFile = join(CWD, fileName);
                removedFile.delete();
            &#125; else if (splitPoint.isModified(givenFile, fileName)
                    || currentCommit.isTracked(fileName)) &#123;
                // 情况7：given branch 中的文件未修改，当前 branch 中已删除
                if (splitPoint.isModified(givenFile, fileName)
                    &amp;&amp; !splitPoint.isModified(currentFile, fileName)) &#123;
                    // 情况1：given branch 修改了，当前 branch 未修改
                    newCommit.add(fileName, givenCommit);
                    givenCommit.restore(fileName, CWD);
                &#125; else if (splitPoint.isModified(currentFile, fileName)
                        &amp;&amp; !splitPoint.isModified(givenFile, fileName)) &#123;
                    // 情况2：当前的修改了，given branch 未修改
                    newCommit.add(fileName, currentCommit);
                &#125; else if (splitPoint.isModified(currentFile, fileName)
                    &amp;&amp; splitPoint.isModified(givenFile, fileName)) &#123;
                    // 情况3：两者都修改了
                    if (!currentFile.equals(givenFile)) &#123;
                        // 两者修改内容不一样，冲突
                        conflict = true;
                        String newContents = &quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n&quot;
                                + currentFile.getContents() + &quot;=======\n&quot;
                                + givenFile.getContents() + &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n&quot;;
                        writeContents(join(CWD, fileName), newContents);
                        Blob blob = new Blob(join(CWD, fileName));
                        blob.store();
                        newCommit.blobs.put(fileName, blob.getBlobId());
                    &#125;
                &#125;
            &#125;
        &#125;
        if (conflict) &#123;
            System.out.println(&quot;Encountered a merge conflict.&quot;);
        &#125;
        newCommit.calc();
        newCommit.save();
        Branch.setCurrentBranchHead(newCommit);
    &#125;

    // 添加名称为 remoteName 的远程 gitlet，其位置为 dest
    public static void addRemote(String remoteName, String dest) &#123;
        if (Remote.existRemote(remoteName)) &#123;
            throwException(&quot;A remote with that name already exists.&quot;);
        &#125;
        Remote.createRemote(remoteName, dest);
    &#125;

    // 移除名称为 remoteName 的远程 gitlet
    public static void rmRemote(String remoteName) &#123;
        if (!Remote.existRemote(remoteName)) &#123;
            throwException(&quot;A remote with that name does not exist.&quot;);
        &#125;
        Remote.removeRemote(remoteName);
    &#125;

    // 将当前 commits 推送到远程 gitlet 的 branch 上
    public static void push(String remoteName, String remoteBranchName) &#123;
        GITLET_DIR = Remote.getRemoteDir(remoteName);
        if (!GITLET_DIR.exists()) &#123;
            throwException(&quot;Remote directory not found.&quot;);
        &#125;
        if (!Branch.exist(remoteBranchName)) &#123;
            branch(remoteBranchName);
            return;
        &#125;
        Commit remoteCommit = Branch.getCommit(remoteBranchName);
        changeCurrentDir(LOCAL_GITLET_DIR);
        Commit currentCommit = currentCommit();
        List&lt;Commit&gt; commits = new ArrayList&lt;&gt;();
        while (!currentCommit.equals(remoteCommit)) &#123;
            if (currentCommit.getFirstFather() == null) &#123;
                throwException(&quot;Please pull down remote changes before pushing.&quot;);
            &#125;
            commits.add(currentCommit);
            currentCommit = currentCommit.getFirstFather();
        &#125;
        changeCurrentDir(Remote.getRemoteDir(remoteName));
        for (Commit commit : commits) &#123;
            commit.save();
        &#125;
        Branch.setBranchHead(remoteBranchName, commits.get(0));
    &#125;

    // 将 sourceDir 文件夹中所有的文件都复制到 destDir文件夹中
    private static void copyAllFiles(File sourceDir, File destDir) &#123;
        List&lt;String&gt; fileNames = plainFilenamesIn(sourceDir);
        File source, dest;
        if (fileNames != null) &#123;
            for (String fileName : fileNames) &#123;
                source = join(sourceDir, fileName);
                dest = join(destDir, fileName);
                if (!dest.exists()) &#123;
                    try &#123;
                        Files.copy(source.toPath(), dest.toPath());
                    &#125; catch (IOException e) &#123;
                        throw new RuntimeException(e);
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;

    // 从远程 gitlet 的 branch 上获取所有 commit 信息和相应的 blobs
    public static void fetch(String remoteName, String remoteBranchName) &#123;
        GITLET_DIR = Remote.getRemoteDir(remoteName);
        if (!GITLET_DIR.exists()) &#123;
            throwException(&quot;Remote directory not found.&quot;);
        &#125;
        if (!Branch.exist(remoteBranchName)) &#123;
            throwException(&quot;That remote does not have that branch.&quot;);
        &#125;
        copyAllFiles(COMMIT_FOLDER, join(LOCAL_GITLET_DIR, &quot;commits&quot;));
        copyAllFiles(BLOBS_FOLDER, join(LOCAL_GITLET_DIR, &quot;blobs&quot;));
        Commit commit = Branch.getCommit(remoteBranchName);
        changeCurrentDir(LOCAL_GITLET_DIR);
        String newBranch = remoteName + &quot;/&quot; + remoteBranchName;
        Branch.create(newBranch);
        Branch.setBranchHead(newBranch, commit);
    &#125;

    // 修改当前 gitlet 所在目录
    private static void changeCurrentDir(File dir) &#123;
        GITLET_DIR = dir;
        Branch.HEADS_FOLDER = join(GITLET_DIR, &quot;heads&quot;);
        Branch.CURRENT_BRANCH = join(GITLET_DIR, &quot;current branch&quot;);
        COMMIT_FOLDER = join(Repository.GITLET_DIR, &quot;commits&quot;);
        BLOBS_FOLDER = join(Repository.GITLET_DIR, &quot;blobs&quot;);
    &#125;

    // 从远处 gitlet 获取文件并与当前分支合并
    public static void pull(String remoteName, String remoteBranchName) &#123;
        fetch(remoteName, remoteBranchName);
        merge(remoteName + &quot;/&quot; + remoteBranchName);
    &#125;

    // 检查 untracked 的文件
    private static void checkUntrackedFile(String commitId) &#123;
        List&lt;String&gt; list = plainFilenamesIn(CWD);
        Commit switchToBranch = Commit.fromFile(commitId);
        if (list != null) &#123;
            for (String fileName : list) &#123;
                if (!currentCommit().isTracked(fileName) &amp;&amp; switchToBranch.isTracked(fileName)) &#123;
                    throwException(&quot;There is an untracked file in the way;&quot;
                            + &quot; delete it, or add and commit it first.&quot;);
                &#125;
            &#125;
        &#125;
    &#125;

    // 获取当前 branch 的 commit
    private static Commit currentCommit() &#123;
        return Branch.getCommit(Branch.getCurrentBranch());
    &#125;
&#125;
</code></pre><h3 id="Remote">Remote</h3><pre><code class="language-Java">package gitlet;

import java.io.File;
import java.io.IOException;

import static gitlet.Repository.LOCAL_GITLET_DIR;
import static gitlet.Utils.*;

public class Remote &#123;
    public static final File REMOTE_FOLDER = join(LOCAL_GITLET_DIR, &quot;remote&quot;); // 存放远程 gitlet 路径的文件夹

    // 获取 remoteName 的远程 gitlet 的目录
    public static File getRemoteDir(String remoteName) &#123;
        return readObject(join(REMOTE_FOLDER, remoteName), File.class);
    &#125;

    // 判断某个远程 gitlet 是否被添加
    public static boolean existRemote(String remoteName) &#123;
        return join(REMOTE_FOLDER, remoteName).exists();
    &#125;

    // 创建一个新远程 gitlet 的文件
    public static void createRemote(String remoteName, String dest) &#123;
        try &#123;
            String[] splitName = dest.split(&quot;/&quot;);
            File dir = new File(&quot;&quot;);
            for (String name : splitName) &#123;
                dir = join(dir, name);
            &#125;
            join(REMOTE_FOLDER, remoteName).createNewFile();
            writeObject(join(REMOTE_FOLDER, remoteName), dir);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;

    // 移除某个远程 gitlet
    public static void removeRemote(String remoteName) &#123;
        join(REMOTE_FOLDER, remoteName).delete();
    &#125;
&#125;
</code></pre><h3 id="Commit">Commit</h3><pre><code class="language-Java">package gitlet;


import java.io.File;
import java.io.Serializable;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.*;

import static gitlet.Main.throwException;
import static gitlet.Utils.*;

/** Represents a gitlet commit object.
 *  does at a high level.
 *
 *  @author old-driver-zero
 */
public class Commit implements Serializable &#123;
    /**
     *
     * List all instance variables of the Commit class here with a useful
     * comment above them describing what that variable represents and how that
     * variable is used. We've provided one example for `message`.
     */
    static File COMMIT_FOLDER = join(Repository.GITLET_DIR, &quot;commits&quot;); // commit 文件夹路径

    static final DateFormat DATE_FORMAT =
            new SimpleDateFormat(&quot;EEE MMM dd HH:mm:ss yyyy Z&quot;, Locale.US); // 时间戳格式化

    /** The message of this Commit. */
    private final String message; // 信息
    private final String timestamp; // 时间戳
    private String commitId; // sha1码
    private final String firstParentId; // 第一个父亲的 commitId
    private final String secondParentId; // 第二个父亲的 commitId

    protected final HashMap&lt;String, String&gt; blobs; // commit 中包含的所有文件，key 为文件名，value 为 blobId

    // 初始化第一个空 commit
    public Commit() &#123;
        timestamp = DATE_FORMAT.format(new Date(0));
        message = &quot;initial commit&quot;;
        firstParentId = null;
        secondParentId = null;
        blobs = new HashMap&lt;&gt;();
        commitId = sha1(timestamp, message, blobs.toString());
    &#125;

    // 初始化 firstParent 和 SecondParent 合并后的 commit 信息
    public Commit(Commit firstParent, Commit secondParent, String mergeMessage) &#123;
        timestamp = DATE_FORMAT.format(new Date());
        firstParentId = firstParent.commitId;
        secondParentId = secondParent.commitId;
        message = mergeMessage;
        blobs = new HashMap&lt;&gt;();
    &#125;

    // 计算 commitId
    public void calc() &#123;
        commitId = sha1(timestamp, message, firstParentId, secondParentId, blobs.toString());
    &#125;

    // 根据 staged 信息和本次 commit 的信息来创建一个commit
    public Commit(Stage stage, String message) &#123;
        timestamp = DATE_FORMAT.format(new Date());
        this.message = message;
        Commit currentCommit = Branch.getCommit(Branch.getCurrentBranch());
        assert currentCommit != null;
        firstParentId = currentCommit.commitId;
        secondParentId = null;
        blobs = currentCommit.blobs;
        // 添加被暂存的文件
        if (stage.isEmpty()) &#123;
            throwException(&quot;No changes added to the commit.&quot;);
        &#125;
        for (String name : stage.stagedFiles.keySet()) &#123;
            String fileName = stage.stagedFiles.get(name);
            blobs.put(name, fileName);
            File origin = join(Stage.STAGING_AREA, fileName);
            File dest = join(Blob.BLOBS_FOLDER, fileName);
            origin.renameTo(dest);
        &#125;
        // 移除被标记为移除的文件
        for (String name : stage.removedFiles) &#123;
            blobs.remove(name);
        &#125;
        commitId = sha1(timestamp, message, firstParentId, blobs.toString());
    &#125;

    // 返回所有的 commits
    public static Iterable&lt;Commit&gt; getAllCommits() &#123;
        List&lt;String&gt; list = plainFilenamesIn(COMMIT_FOLDER);
        List&lt;Commit&gt; commits = new ArrayList&lt;&gt;();
        if (list != null) &#123;
            for (String name : list) &#123;
                commits.add(Commit.fromFile(name));
            &#125;
        &#125;
        return commits;
    &#125;

    // 保存该 commit
    public void save() &#123;
        File dest = join(COMMIT_FOLDER, commitId);
        writeObject(dest, this);
    &#125;

    // 从文件夹中通过 commitId 读取 commit
    public static Commit fromFile(String commitId) &#123;
        File commitFile = join(COMMIT_FOLDER, commitId);
        if (!commitFile.exists()) &#123;
            throwException(&quot;No commit with that id exists.&quot;);
        &#125;
        return readObject(commitFile, Commit.class);
    &#125;

    // 向 commit 中添加对文件的引用
    public void add(String fileName, Commit commit) &#123;
        blobs.put(fileName, commit.blobs.get(fileName));
    &#125;

    // 获取 commitId
    public String getCommitId() &#123;
        return commitId;
    &#125;

    // commit 中是否修改了某文件
    public boolean isModified(Blob blob, String fileName) &#123;
        if (blob.isEmpty()) &#123;
            return isTracked(fileName);
        &#125;
        return !blobs.containsKey(fileName) || !blobs.get(fileName).equals(blob.getBlobId());
//        return !blobs.containsValue(blob.getBlobId());
    &#125;

    // 文件名是否被 tracked
    public boolean isTracked(String fileName) &#123;
        return blobs.containsKey(fileName);
    &#125;

    // 获取 commit 的第一个父亲 commit
    public Commit getFirstFather() &#123;
        if (firstParentId == null) &#123;
            return null;
        &#125;
        return fromFile(firstParentId);
    &#125;

    // 获取 commit 的第一个父亲 commit
    public Commit getSecondFather() &#123;
        if (secondParentId == null) &#123;
            return null;
        &#125;
        return fromFile(secondParentId);
    &#125;

    // 获取某 commit 的所有祖先及其距离该 commit 的距离
    public HashMap&lt;String, Integer&gt; ancestor(int depth) &#123;
        HashMap&lt;String, Integer&gt; ancestor = new HashMap&lt;&gt;();
        Commit cur = this;
        while (cur != null) &#123;
            ancestor.put(cur.getCommitId(), depth++);
            if (cur.getSecondFather() != null) &#123;
                ancestor.putAll(cur.getSecondFather().ancestor(depth));
            &#125;
            cur = cur.getFirstFather();
        &#125;
        return ancestor;
    &#125;

    // 获取多个 commit 中储存的文件的文件名
    public static HashSet&lt;String&gt; fileNames(Commit ... args) &#123;
        HashSet&lt;String&gt; fileNames = new HashSet&lt;&gt;();
        for (Commit commit : args) &#123;
            fileNames.addAll(commit.blobs.keySet());
        &#125;
        return fileNames;
    &#125;

    @Override
    public boolean equals(Object obj) &#123;
        if (obj == null) &#123;
            return false;
        &#125;
        if (obj.getClass() != getClass()) &#123;
            return false;
        &#125;
        if (obj == this) &#123;
            return true;
        &#125;
        Commit other = (Commit) obj;
        return commitId.equals(other.getCommitId());
    &#125;

    @Override
    public int hashCode() &#123;
        return commitId.hashCode();
    &#125;

    // 按照格式输出 commit 中的信息
    public String toString() &#123;
        return &quot;===\n&quot; + &quot;commit &quot; + commitId + '\n'
                + &quot;Date: &quot; + timestamp + '\n' + message + '\n';
    &#125;

    // 将 commit 中的文件恢复到指定路径
    public void restore(String fileName, File dest) &#123;
        if (!isTracked(fileName)) &#123;
            throwException(&quot;File does not exist in that commit.&quot;);
        &#125;
        writeContents(join(dest, fileName), Blob.fromFile(blobs.get(fileName)).getContents());
    &#125;

    // 获取 commit 信息
    public String getMessage() &#123;
        return message;
    &#125;
&#125;
</code></pre><h3 id="stage">stage</h3><pre><code class="language-Java">package gitlet;

import java.io.File;
import java.io.Serializable;
import java.util.*;

import static gitlet.Repository.GITLET_DIR;
import static gitlet.Utils.*;

public class Stage implements Serializable &#123;
    protected TreeMap&lt;String, String&gt; stagedFiles; // 暂存的文件列表
    protected TreeSet&lt;String&gt; removedFiles; // 被移除的文件的文件名
    public static final File STAGING_AREA = join(GITLET_DIR, &quot;staging area&quot;); // 暂存文件所在文件夹
    public static final File STAGE_FILE = join(GITLET_DIR, &quot;stage&quot;); // 存放暂存文件信息的文件路径

    // 从文件中恢复 stage 若没有，则新建一个 stage
    public Stage() &#123;
        if (!STAGE_FILE.exists()) &#123;
            stagedFiles = new TreeMap&lt;&gt;();
            removedFiles = new TreeSet&lt;&gt;();
            return;
        &#125;
        Stage tmp = readObject(STAGE_FILE, getClass());
        stagedFiles = tmp.stagedFiles;
        removedFiles = tmp.removedFiles;
    &#125;

    // 暂存 addBlob 并维护暂存的文件列表
    public void add(Blob addBlob, String fileName) &#123;
        stagedFiles.put(fileName, addBlob.getBlobId());
        removedFiles.remove(fileName);
        addBlob.store();
        save();
    &#125;

    // 从暂存区中移除以 fileName 为文件名的文件
    public void remove(String fileName) &#123;
        join(STAGING_AREA, stagedFiles.get(fileName)).delete();
        stagedFiles.remove(fileName);
        save();
    &#125;

    // 检查 stage 中是否有添加或删除的文件
    public boolean isEmpty() &#123;
        return stagedFiles.isEmpty() &amp;&amp; removedFiles.isEmpty();
    &#125;

    // stage 中是否暂存了文件名
    public boolean isStaged(String fileName) &#123;
        return stagedFiles.containsKey(fileName);
    &#125;

    // stage 中暂存的文件是否被修改
    public boolean isModified(Blob file, String fileName) &#123;
        return !stagedFiles.containsKey(fileName)
                || !stagedFiles.get(fileName).equals(file.getBlobId());
    &#125;

    // 添加移除的状态
    public void stageForRemoval(String fileName) &#123;
        removedFiles.add(fileName);
        save();
    &#125;

    // stage 中是否移除了文件名
    public boolean isRemoved(String fileName) &#123;
        return removedFiles.contains(fileName);
    &#125;

    // 清空 stage 记录的信息
    public void clear() &#123;
        List&lt;String&gt; list = plainFilenamesIn(STAGING_AREA);
        if (list != null) &#123;
            for (String blobId : list) &#123;
                File file = join(STAGING_AREA, blobId);
                file.delete();
            &#125;
        &#125;
        removedFiles = new TreeSet&lt;&gt;();
        stagedFiles = new TreeMap&lt;&gt;();
        save();
    &#125;

    // 保存 stage 的状态
    private void save() &#123;
        writeObject(STAGE_FILE, this);
    &#125;

    // 获取暂存的文件的文件名
    public String stagedFilesNames() &#123;
        StringBuilder list = new StringBuilder();
        for (String name : stagedFiles.keySet()) &#123;
            list.append(name).append(&quot;\n&quot;);
        &#125;
        return list.toString();
    &#125;

    // 获取被移除的文件的文件名
    public String removedFilesNames() &#123;
        StringBuilder list = new StringBuilder();
        for (String name : removedFiles) &#123;
            list.append(name).append(&quot;\n&quot;);
        &#125;
        return list.toString();
    &#125;
&#125;
</code></pre><h3 id="Branch">Branch</h3><pre><code class="language-Java">package gitlet;

import java.io.File;
import java.io.IOException;
import java.util.Collections;
import java.util.List;

import static gitlet.Repository.GITLET_DIR;
import static gitlet.Utils.*;

public class Branch &#123;
    protected static File HEADS_FOLDER = join(GITLET_DIR, &quot;heads&quot;); // 存放各 branch 的 HEADs 的文件夹
    protected static File CURRENT_BRANCH = join(GITLET_DIR, &quot;current branch&quot;); // 存放当前 branch 名称的文件

    // 通过 branch 名称获取 commit
    public static Commit getCommit(String branchName) &#123;
        if (branchName == null) &#123;
            return null;
        &#125;
        branchName = branchName.replace('/', '-');
        return Commit.fromFile(readContentsAsString(join(HEADS_FOLDER, branchName)));
    &#125;

    // 设置当前的 branch 为 branchName
    public static void setCurrentBranch(String branchName) &#123;
        writeContents(CURRENT_BRANCH, branchName);
    &#125;

    // 设置当前 branch 的 HEAD 为 commit
    public static void setCurrentBranchHead(Commit commit) &#123;
        setBranchHead(getCurrentBranch(), commit);
    &#125;

    // 设置 branchName 的 HEAD 为 commitId
    public static void setBranchHead(String branchName, Commit commit) &#123;
        branchName = branchName.replace('/', '-');
        writeContents(join(HEADS_FOLDER, branchName), commit.getCommitId());
    &#125;

    // 获取当前 branch 的名称
    public static String getCurrentBranch() &#123;
        return readContentsAsString(CURRENT_BRANCH);
    &#125;

    // 判断某个 branch 是否存在
    public static boolean exist(String branchName) &#123;
        branchName = branchName.replace('/', '-');
        return join(HEADS_FOLDER, branchName).exists();
    &#125;

    // 创建一个新分支的文件
    public static void create(String branchName) &#123;
        try &#123;
            branchName = branchName.replace('/', '-');
            join(HEADS_FOLDER, branchName).createNewFile();
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;

    // 返回所有的 branches 的名字
    public static Iterable&lt;String&gt; getAllBranches() &#123;
        List&lt;String&gt; list = plainFilenamesIn(Branch.HEADS_FOLDER);
        if (list != null) &#123;
            Collections.sort(list);
        &#125;
        return list;
    &#125;

    // 移除某个 branch
    public static void remove(String branchName) &#123;
        join(HEADS_FOLDER, branchName).delete();
    &#125;
&#125;
</code></pre><h3 id="Blob">Blob</h3><pre><code class="language-Java">package gitlet;

import java.io.File;
import java.io.Serializable;
import java.nio.charset.StandardCharsets;

import static gitlet.Utils.*;

public class Blob implements Serializable &#123;
    static File BLOBS_FOLDER = join(Repository.GITLET_DIR, &quot;blobs&quot;); // blob 存放的文件夹位置
    private final byte[] contents; // blob 内容
    private final String blobId; // blob 的 sha1

    // 新建一个空 blob
    public Blob() &#123;
        contents = new byte[0];
        blobId = sha1(contents);
    &#125;

    // 利用 file 文件创建一个 blob
    public Blob(File file) &#123;
        contents = readContents(file);
        blobId = sha1(contents);
    &#125;

    // 获取 blobId
    public String getBlobId() &#123;
        return blobId;
    &#125;

    // 以 UTF-8 的字符串形式获取 blob 储存的文件内容
    public String getContents() &#123;
        return new String(contents, StandardCharsets.UTF_8);
    &#125;

    // 暂存 blob
    public void store() &#123;
        writeObject(join(Stage.STAGING_AREA, blobId), this);
    &#125;

    // 使用 blobId 获取 blob
    public static Blob fromFile(String id) &#123;
        if (id == null) &#123;
            return new Blob();
        &#125;
        return readObject(join(BLOBS_FOLDER, id), Blob.class);
    &#125;

    // 是否是空 blob
    public boolean isEmpty() &#123;
        return contents.length == 0;
    &#125;

    @Override
    public boolean equals(Object obj) &#123;
        if (obj == null) &#123;
            return false;
        &#125;
        if (obj.getClass() != getClass()) &#123;
            return false;
        &#125;
        if (obj == this) &#123;
            return true;
        &#125;
        Blob other = (Blob) obj;
        return blobId.equals(other.getBlobId());
    &#125;

    @Override
    public int hashCode() &#123;
        return blobId.hashCode();
    &#125;
&#125;
</code></pre><p>[1]: /illustration/UCB CS61B：数据结构与算法/gitlet autograder.webp<br>[2]: /illustration/UCB CS61B：数据结构与算法/merge.webp</p></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/">计算机科学</a><a class="post-meta__tags" href="/tags/UC-Berkeley/">UC Berkeley</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="/gallery/cover/UCB%20CS61B%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/e2e4b4ce.html" title="Coursera Algorithms I：算法（第一部分）"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/Coursera%20Algorithms%20I%EF%BC%9A%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Coursera Algorithms I：算法（第一部分）</div></div></a></div><div class="next-post pull-right"><a href="/posts/dd378ae0.html" title="Stanford CS106L：标准C++程序设计"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/Stanford%20CS106L%EF%BC%9A%E6%A0%87%E5%87%86C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Stanford CS106L：标准C++程序设计</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/e7a99a5e.html" title="UCB CS61A：计算机的构造与解释"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/UCB%20CS61A%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E8%A7%A3%E9%87%8A.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-14</div><div class="title">UCB CS61A：计算机的构造与解释</div></div></a></div><div><a href="/posts/a13c1dba.html" title="Coursera Algorithms II：算法（第二部分）"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/Coursera%20Algorithms%20II%EF%BC%9A%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-10</div><div class="title">Coursera Algorithms II：算法（第二部分）</div></div></a></div><div><a href="/posts/e2e4b4ce.html" title="Coursera Algorithms I：算法（第一部分）"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/Coursera%20Algorithms%20I%EF%BC%9A%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-03</div><div class="title">Coursera Algorithms I：算法（第一部分）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="card-info-avatar"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/%E5%A4%B4%E5%83%8F_%E7%81%B0%E5%A4%AA%E7%8B%BC.webp" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-status-box"><div class="author-status"><g-emoji class="g-emoji" alias="palm_tree" fallback-src="https://lskypro.acozycotage.net/LightPicture/2022/12/fe1dc0402e623096.jpg">🐟</g-emoji><span>认真摸鱼中 + `'` alt="avatar")</span></div></div></div><div class="author-info__name">old_driver_zero</div><div class="author-info__description">一个幽灵</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/old-driver-zero" target="_blank" title="Github" rel="external nofollow noopener noreferrer"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2771503468@qq.com" target="_blank" title="Email" rel="external nofollow noopener noreferrer"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">类 class 的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#static-%E9%9D%99%E6%80%81"><span class="toc-number">2.1.</span> <span class="toc-text">static 静态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">测试 Test</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">引用 Reference</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">SLList 单链表、嵌套类、哨兵 Sentinel 节点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">DLLists 双向链表、Array 数组、Generic 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-DLLists"><span class="toc-number">6.1.</span> <span class="toc-text">双向链表 DLLists</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B-Generic"><span class="toc-number">6.2.</span> <span class="toc-text">泛型 Generic</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-Array"><span class="toc-number">6.3.</span> <span class="toc-text">数组 Array</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">AList</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">继承 Inheritance</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF-Interface-Inheritance-%E5%92%8C-%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF-Implement-Inheritance"><span class="toc-number">8.1.</span> <span class="toc-text">接口继承 Interface Inheritance 和 实现继承 Implement Inheritance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B-Static-Type-%E5%92%8C%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B-Dynamic-Type"><span class="toc-number">8.2.</span> <span class="toc-text">静态类型 Static Type 和动态类型 Dynamic Type</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">延伸 Extend</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">高阶函数 Higher Order Function</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">异常 Exceptions、迭代器 Iterators 和 特殊对象方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">Project 2: Gitlet</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3"><span class="toc-number">12.1.</span> <span class="toc-text">设计文档</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">12.1.1.</span> <span class="toc-text">类与数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">12.1.2.</span> <span class="toc-text">算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">12.1.3.</span> <span class="toc-text">持久化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">12.2.</span> <span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Main"><span class="toc-number">12.2.1.</span> <span class="toc-text">Main</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Repository"><span class="toc-number">12.2.2.</span> <span class="toc-text">Repository</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Remote"><span class="toc-number">12.2.3.</span> <span class="toc-text">Remote</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Commit"><span class="toc-number">12.2.4.</span> <span class="toc-text">Commit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stage"><span class="toc-number">12.2.5.</span> <span class="toc-text">stage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Branch"><span class="toc-number">12.2.6.</span> <span class="toc-text">Branch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Blob"><span class="toc-number">12.2.7.</span> <span class="toc-text">Blob</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By old_driver_zero</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["head > title","#config-diff","#body-wrap","#rightside-config-hide","#web_bg","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.tocScrollFn&&window.removeEventListener("scroll",window.tocScrollFn),window.scrollCollect&&window.removeEventListener("scroll",scrollCollect),document.getElementById("rightside").style.cssText="opacity: ''; transform: ''",window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),"object"==typeof disqusjs&&disqusjs.destroy()})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div><script data-pjax>function butterfly_clock_anzhiyu_injector_config(){var a=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载butterfly_clock_anzhiyu"),a&&a.insertAdjacentHTML("afterbegin",'<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>')}for(var elist="null".split(","),cpage=location.pathname,epage="/",qweather_key="74c5cb8e65744f1bbe7fb1559fbdd043",gaud_map_key="cf64c8eaa23edd1a2aaf59cbb9797620",baidu_ak_key="undefined",flag=0,clock_rectangle="113.34532,23.15624",clock_default_rectangle_enable="false",i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_clock_anzhiyu_injector_config()</script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>function butterfly_categories_card_injector_config(){var a=document.getElementById("recent-posts");console.log("已挂载butterfly_categories_card"),a.insertAdjacentHTML("afterbegin",'<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(/gallery/cover/工具.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/读书笔记/&quot;);" href="javascript:void(0);">读书笔记</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr">工欲善其事，必先利其器。——《论语·卫灵公》</span></li><li class="categoryBar-list-item" style="background:url(/gallery/cover/ACG杂谈.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/ACG杂谈/&quot;);" href="javascript:void(0);">ACG杂谈</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr">让我带你去吧,这个小镇,愿望实现的地方。——《CLANNAD》</span></li><li class="categoryBar-list-item" style="background:url(/gallery/cover/学习笔记.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/学习笔记/&quot;);" href="javascript:void(0);">学习笔记</a><span class="categoryBar-list-count">9</span><span class="categoryBar-list-descr">吾生也有涯，而知也无涯。以有涯随无涯，殆已!——《庄子．养生主》</span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/工具/&quot;);" href="javascript:void(0);">工具</a><span class="categoryBar-list-count">6</span><span class="categoryBar-list-descr"></span></li></ul></div></div>')}document.getElementById("recent-posts")&&"/"===location.pathname&&butterfly_categories_card_injector_config()</script><script data-pjax>function butterfly_swiper_injector_config(){var a=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),a.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2f57a694.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/正则表达式.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-10-31</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2f57a694.html&quot;);" href="javascript:void(0);" alt="">正则表达式</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2f57a694.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d36531a7.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/多变量微积分（积分部分）.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-11-16</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d36531a7.html&quot;);" href="javascript:void(0);" alt="">多变量微积分（积分部分）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d36531a7.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/3b308caa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/魔法少女小圆.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/3b308caa.html&quot;);" href="javascript:void(0);" alt="">在失去希望的世界里，会开出怎样的花朵？</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/3b308caa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/374b54d5.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/喜羊羊与灰太狼.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-12-03</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/374b54d5.html&quot;);" href="javascript:void(0);" alt="">随风远去的童年</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/374b54d5.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="undefined".split(","),cpage=location.pathname,epage="all",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_swiper_injector_config()</script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","1s"),arr[i].setAttribute("data-wow-delay","0s"),arr[i].setAttribute("data-wow-offset","100"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><script async>window.onload=function(){var e=document.createElement("script"),t=document.getElementsByTagName("script")[0];e.type="text/javascript",e.async=!0,e.src="/sw-register.js?v="+Date.now(),t.parentNode.insertBefore(e,t)}</script></body></html>