<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++ 入门（下） | Aefrivern的小屋</title><meta name="author" content="Aefrivern"><meta name="copyright" content="Aefrivern"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="关联型容器 Associative Containers 关联型容器通常需要键满足 &lt;，否则可以自定义一个： bool compareIsbn(const Sales_data &amp;lhs, const Sales_data &amp;rhs) &#123;    return lhs.isbn() &lt; rhs.isbn();&#125;multiset&lt;Sales_dat">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 入门（下）">
<meta property="og:url" content="https://aefrivern.github.io/posts/8724ba9a.html">
<meta property="og:site_name" content="Aefrivern的小屋">
<meta property="og:description" content="关联型容器 Associative Containers 关联型容器通常需要键满足 &lt;，否则可以自定义一个： bool compareIsbn(const Sales_data &amp;lhs, const Sales_data &amp;rhs) &#123;    return lhs.isbn() &lt; rhs.isbn();&#125;multiset&lt;Sales_dat">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://aefrivern.github.io/gallery/cover/C++%20%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%8B%EF%BC%89.webp">
<meta property="article:published_time" content="2024-04-10T08:24:19.000Z">
<meta property="article:modified_time" content="2024-11-23T05:54:13.000Z">
<meta property="article:author" content="Aefrivern">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://aefrivern.github.io/gallery/cover/C++%20%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%8B%EF%BC%89.webp"><link rel="shortcut icon" href="/illustration/favicon.ico"><link rel="canonical" href="https://aefrivern.github.io/posts/8724ba9a.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"GY5EJYJ1FS","apiKey":"c443c952672ec7062840aac45536181e","indexName":"blog","hitsPerPage":6,"languages":{"input_placeholder":"搜索文章","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++ 入门（下）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4031045_1yiosqv4vch.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/highlight.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/hexo-butterfly-article-double-row.css"><script src="/js/echarts.min.js"></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image: url(/gallery/wallpaper/wallpaper.webp);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/%E5%A4%B4%E5%83%8F_%E7%81%B0%E5%A4%AA%E7%8B%BC.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">171</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">226</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye-01"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-a-16-01-01"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-wenjianjia"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/anime/"><i class="fa-fw iconfont icon-zhifeiji"></i><span> 二次元</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw iconfont icon-xiangce"></i><span> 画廊</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyu"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/charts/"><i class="fa-fw iconfont icon-tongjichaxun"></i><span> 统计</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw iconfont icon-liuyan"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/random/"><i class="fa-fw iconfont icon-suiji"></i><span> 随便逛逛</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/gallery/cover/C++ 入门（下）.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Aefrivern的小屋</span></a><a class="nav-page-title" href="/"><span class="site-name">C++ 入门（下）</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-sousuo1"></use></svg><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye-01"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-a-16-01-01"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-wenjianjia"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/anime/"><i class="fa-fw iconfont icon-zhifeiji"></i><span> 二次元</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw iconfont icon-xiangce"></i><span> 画廊</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyu"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/charts/"><i class="fa-fw iconfont icon-tongjichaxun"></i><span> 统计</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw iconfont icon-liuyan"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/random/"><i class="fa-fw iconfont icon-suiji"></i><span> 随便逛逛</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C++ 入门（下）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-10T08:24:19.000Z" title="发表于 2024-04-10 16:24:19">2024-04-10</time><span class="post-meta-separator">|</span><svg class="meta_icon post-ui-icon" style="width:13px;height:13px;position:relative;top:2px"><use xlink:href="#icon-gengxin"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-23T05:54:13.000Z" title="更新于 2024-11-23 13:54:13">2024-11-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><a class="faa-parent animated-hover"></a><svg class="meta_icon post-ui-icon" style="width:13px;height:13px;position:relative;top:2px"><use xlink:href="#icon-fenlei"></use></svg><a class="post-meta-categories" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-word"></use></svg><span class="post-meta-label">总字数:</span><span class="word-count">5346</span><span class="post-meta-separator">|</span><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="关联型容器-Associative-Containers">关联型容器 Associative Containers</h2>
<p>关联型容器通常需要键满足 <code>&lt;</code>，否则可以自定义一个：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compareIsbn</span><span class="hljs-params">(<span class="hljs-type">const</span> Sales_data &amp;lhs, <span class="hljs-type">const</span> Sales_data &amp;rhs)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">isbn</span>() &lt; rhs.<span class="hljs-built_in">isbn</span>();<br>&#125;<br><span class="hljs-function">multiset&lt;Sales_data, <span class="hljs-title">decltype</span><span class="hljs-params">(compareIsbn)</span>*&gt; <span class="hljs-title">bookstore</span><span class="hljs-params">(compareIsbn)</span></span>;<br></code></pre></td></tr></table></figure>
<p>关联性容器定义了三种类型：</p>
<ul>
<li><code>key_type</code></li>
<li><code>mapped_type</code></li>
<li><code>value_type</code>
<ul>
<li><code>set</code>：<code>key_type</code></li>
<li><code>map</code>：<code>pair&lt;const key_type, mapped_type&gt;</code></li>
</ul>
</li>
</ul>
<p>set 的迭代器都是 <code>const_iterator</code></p>
<p><code>.lower_bound()</code> &gt;=，<code>.upper_bound()</code> &gt;，<code>.equal_range()</code></p>
<p>除此之外，还有键可以重复的 <code>multiset</code> 和 <code>multimap</code></p>
<p><code>unordered_set</code> 和 <code>unordered_map</code> 使用 hash，不保证顺序</p>
<h2 id="动态内存-Dynamic-Memory">动态内存 Dynamic Memory</h2>
<p>智能指针：</p>
<ul>
<li><code>shared_ptr&lt;T&gt; sp</code> 和 <code>unique_ptr&lt;T&gt; up</code></li>
<li><code>p.get()</code> 返回 p 中的指针</li>
<li><code>make_shared&lt;T&gt;(args)</code> 返回指向动态分配类型 T 的对象的 <code>shared_ptr</code>，使用 <code>args</code> 初始化对象</li>
</ul>
<p><code>.reset</code> 更新引用计数并可能会删除指向的对象</p>
<p>也可以显式指定析构函数：<code>shared_ptr&lt;T, D&gt; s2(d)</code> 或 <code>unique_ptr&lt;T, D&gt; u2(d)</code>，一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">connection c = <span class="hljs-built_in">connect</span>(&amp;d);<br><span class="hljs-function">unique_ptr&lt;connection, <span class="hljs-title">decltype</span><span class="hljs-params">(end_connection)</span>*&gt; <span class="hljs-title">p</span><span class="hljs-params">(&amp;c, end_connection)</span></span>;<br></code></pre></td></tr></table></figure>
<p>转移所有权的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p2</span><span class="hljs-params">(p1.release())</span></span>;<br></code></pre></td></tr></table></figure>
<p><code>weak_ptr</code> 是不会控制指向对象的生命周期的智能指针，其通常指向由 <code>shared_ptr</code> 管理的对象</p>
<p>因为有可能指向已经被释放的值，故不能直接访问，而是通过 <code>.lock()</code>：如果已经 <code>w.expired() == true</code>，则返回 <code>nullptr</code>；否则返回指向的对象的 <code>shared_ptr</code></p>
<p>也支持动态分配数组：<code>unique_ptr&lt;T[]&gt; u</code></p>
<p>但注意当使用 <code>shared_ptr</code> 时，要指定析构函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>], [](<span class="hljs-type">int</span> *p) &#123; <span class="hljs-keyword">delete</span>[] p; &#125;)</span></span>;<br></code></pre></td></tr></table></figure>
<p><code>allocator</code> 可以将分配从构造中分离出来</p>
<ul>
<li>定义 <code>allocator&lt;T&gt; a</code></li>
<li><code>a.allocate(n)</code> 分配原始的，为构造的内存以存放 n 个 T 类型的对象</li>
<li><code>a.construct(p, args)</code>：<code>p</code> 必须指向 T 类型原始内存的指针，<code>args</code> 是用来构造的参数</li>
<li><code>a.destroy(p)</code>：运行析构函数</li>
<li><code>a.deallocate(p, n)</code>：归还 <code>allocate</code> 的内存</li>
</ul>
<p>一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">allocator&lt;string&gt; alloc;<br><span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> p = alloc.<span class="hljs-built_in">allocate</span>(n);<br><span class="hljs-keyword">auto</span> q = p;<br>alloc.<span class="hljs-built_in">construct</span>(q++);<br>alloc.<span class="hljs-built_in">construct</span>(q++, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;c&#x27;</span>);<br>alloc.<span class="hljs-built_in">construct</span>(q++, <span class="hljs-string">&quot;hi&quot;</span>);<br><span class="hljs-keyword">while</span> (q != p)<br>    alloc.<span class="hljs-built_in">destroy</span>(--q);<br>alloc.<span class="hljs-built_in">deallocate</span>(p, n);<br></code></pre></td></tr></table></figure>
<p>类似于 <code>copy</code> 和 <code>fill</code> 的算法，<code>allocator</code> 也有相对应的算法：<code>uninitialized_copy(b, e, b2)</code> 和 <code>uninitialized_fill(b ,e t)</code></p>
<h2 id="复制控制-Copy-Control">复制控制 Copy Control</h2>
<h3 id="复制，赋值和销毁">复制，赋值和销毁</h3>
<p><strong>copy constructor</strong>：<code>Foo(const Foo&amp;);</code></p>
<p>复制初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(dots)</span></span>; <span class="hljs-comment">// 直接初始化</span><br>string s2 = dots; <span class="hljs-comment">// 复制初始化</span><br></code></pre></td></tr></table></figure>
<p>有的类使用 <code>explicit</code> 指定必须使用直接初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// ok</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v1 = <span class="hljs-number">10</span>; <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure>
<p><strong>copy assignment</strong>：<code>Foo&amp; operator=(const Foo&amp;);</code></p>
<p><strong>析构函数 destructor</strong>：<code>~Foo();</code></p>
<p>以上三者必须同时定义</p>
<p>使用 <code>= default</code> 来显式要求编译器生成默认的版本</p>
<p>极少数类（如 <code>iostream</code>）会禁止复制，使用 <code>= delete</code></p>
<h3 id="复制控制和资源管理">复制控制和资源管理</h3>
<p>尽管很少见，但赋值运算符 <strong>必须</strong> 支持自己给自己赋值，故其 <strong>一定</strong> 要先复制 <code>rhs</code> 操作数，再删除 <code>lhs</code> 操作数</p>
<p>尽管 <code>swap</code> 不是必须的，但是定义 <code>swap</code> 可以有更好的优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(HasPtr &amp;lhs, HasPtr &amp;rhs)</span> </span>&#123;<br>    <span class="hljs-keyword">using</span> std::swap; <span class="hljs-comment">// 一定要这么使用，而不是指定 std:: swap</span><br>    <span class="hljs-built_in">swap</span>(lhs.ps, rhs.ps);<br>    <span class="hljs-built_in">swap</span>(lhs.i, rhs. i);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Swap">Swap</h3>
<p>可以在赋值中使用 <code>swap</code>，这种做法比较安全：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">HasPtr&amp; HasPtr::<span class="hljs-keyword">operator</span>=(HasPtr rhs) &#123;<br>    <span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>, rhs);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="移动对象">移动对象</h3>
<p><code>IO</code> 和 <code>unique_ptr</code> 不可以被复制，但可以被 <code>move</code></p>
<p><strong>左值引用</strong> 和 <strong>右值引用</strong></p>
<p>可以使用 <code>std::move</code> 将左值转换为右值</p>
<p>相对应的，就有了 move constructor：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">StrVec::<span class="hljs-built_in">StrVec</span>(StrVec &amp;&amp;s) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">elements</span>(s.elements), <span class="hljs-built_in">first_free</span>(s.first_free), <span class="hljs-built_in">cap</span>(s.cap) &#123;<br>    s.elements = s.first_free = s.cap = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 让 s 能够安全地调用析构函数</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>因为 move constructor 没有分配资源，所以并不会抛出异常，故要加上 <code>noexcept</code></p>
<p><code>push_back()</code> 保证了如果发生异常，则原有数据保持不变。那么如果 move constructor 发生了异常，则旧数据和新数据都会损坏，故只能选择 copy constructor。所以需要显式指明不会抛出异常</p>
<p>对应的也就有 move assignment：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">StrVec&amp; StrVec::<span class="hljs-keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="hljs-keyword">noexcept</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) &#123; <span class="hljs-comment">// 注意要判断是否是给自己赋值</span><br>        <span class="hljs-built_in">free</span>();<br>        elements = rhs.elements;<br>        first_free = rhs.first_free;<br>        cap = rhs.cap;<br>        rhs.elements = rhs.first_free = rhs.cap = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>只有当一个类没有定义自己的复制控制的成员时，编译器才会合成 move 成员</p>
<p>一种 <strong>同时</strong> 定义了 copy 和 move 赋值的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">HasPtr&amp; <span class="hljs-keyword">operator</span>=(HasPtr rhs) &#123;<br>    <span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>, rhs);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>一般的迭代器在解引用时返回的是 <strong>左值引用</strong>，但是 <strong>move iterator</strong> 返回的却是一个 <strong>右值引用</strong></p>
<p>将迭代器转为移动迭代器的做法：<code>make_move_iterator()</code></p>
<p>区分复制和移动参数的重载函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> X&amp;)</span></span>; <span class="hljs-comment">// 复制</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(X&amp;&amp;)</span></span>; <span class="hljs-comment">// 移动</span><br></code></pre></td></tr></table></figure>
<p>类似于 <code>const *this</code>，我们也可以指定 <code>*this</code> 是左值还是右值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Foo&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Foo&amp;) &amp;; <span class="hljs-comment">// this 是一个左值</span><br></code></pre></td></tr></table></figure>
<h2 id="重载运算和转换-Overloaded-Operations-and-Conversions">重载运算和转换 Overloaded Operations and Conversions</h2>
<p>可以显式调用运算符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">operator</span>+(data1, data2);<br>data1.<span class="hljs-keyword">operator</span>+=(data2);<br></code></pre></td></tr></table></figure>
<p>成员函数与非成员函数</p>
<p>输入流和输出流重载</p>
<p>算术运算符通常使用符号赋值重载：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Sales_data <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Sales_data &amp;lhs, <span class="hljs-type">const</span> Sales_data &amp;rhs) &#123;<br>    Sales_data sun = lhs;<br>    sum += rhs;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>同时定义</p>
<p>支持初始化列表的赋值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">StrVec&amp; StrVec::<span class="hljs-keyword">operator</span>=(initializer_list&lt;string&gt; il) &#123;<br>    <span class="hljs-keyword">auto</span> data = <span class="hljs-built_in">alloc_n_copy</span>(il.<span class="hljs-built_in">begin</span>(), il.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">free</span>();<br>    elements = data.first;<br>    first_free = cap = data.second;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>定义下标运算符时，通常要定义两个版本：const 和非 const 的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StrVec</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    std::string&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> n) &#123; <span class="hljs-keyword">return</span> elements[n]; &#125;<br>    <span class="hljs-type">const</span> std::string&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> n) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> elements[n]; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>自增/自减分为前缀/后缀版本，用一个为 <code>0</code> 的参数来区分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StrBlobPtr</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 前缀版本</span><br>    StrBlobPtr&amp; <span class="hljs-keyword">operator</span>++();<br>    StrBlobPtr&amp; <span class="hljs-keyword">operator</span>--();<br>    <span class="hljs-comment">// 后缀版本</span><br>    StrBlobPtr <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>);<br>    StrBlobPtr <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>甚至可以重载 <strong>函数调用</strong> 运算符，像函数一样使用，叫 <strong>函数对象</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">absInt</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> val &lt; <span class="hljs-number">0</span> ? -val : val;<br>    &#125;<br>&#125;<br><br>absInt absObj;<br><span class="hljs-type">int</span> ui = <span class="hljs-built_in">absObj</span>(<span class="hljs-number">-42</span>);<br></code></pre></td></tr></table></figure>
<p>事实上，lambda 就是函数对象</p>
<p>对于一个捕获了局部变量的 lambda，其相当于构造函数带该参数，并保存在其成员变量中</p>
<p><code>functional</code> 头文件中定义了很多类型，如：<code>plus&lt;T&gt;</code>、<code>greater&lt;T&gt;</code> 等</p>
<p>有多种可调用对象，如函数，函数指针，lambda，重载了 <code>()</code> 的对象等，该头文件中还定义了函数原型以统一这些表达：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">map&lt;string, function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt;&gt; binops = &#123;<br>    &#123;<span class="hljs-string">&quot;+&quot;</span>, add&#125;, <span class="hljs-comment">// 函数指针</span><br>    &#123;<span class="hljs-string">&quot;-&quot;</span>, std::<span class="hljs-built_in">minus</span>&lt;<span class="hljs-type">int</span>&gt;()&#125;, <span class="hljs-comment">// 库函数对象</span><br>    &#123;<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-built_in">div</span>()&#125;, <span class="hljs-comment">// 用户定义的函数对象</span><br>    &#123;<span class="hljs-string">&quot;*&quot;</span>, [](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123; <span class="hljs-keyword">return</span> i * j; &#125;&#125; <span class="hljs-comment">// 匿名 lambda</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>类型转换函数的基本形式：<code>operator 类型名() const</code></p>
<p>前面可以加上 <code>explicit</code>，强制要求显式转换</p>
<h2 id="面向对象编程-Object-Oriented-Programming">面向对象编程 Object-Oriented Programming</h2>
<h3 id="概览">概览</h3>
<p><strong>基类 base class</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Quoto</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> n)</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>派生类 derived class</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bulk_quote</span> : <span class="hljs-keyword">public</span> Quote &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>动态绑定（运行时绑定）</strong>：根据运行时是对基类还是派生类的引用，调用不同类中的函数</p>
<p>基类一般会定义一个 <code>virtual</code> 析构函数，使得其动态绑定</p>
<p><code>virtual</code> 关键字表示希望派生类覆盖该成员</p>
<h3 id="定义基类和派生类">定义基类和派生类</h3>
<p>派生类会自动转换为基类，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Bulk_quote bulk;<br>Quote *p = &amp;bulk; <span class="hljs-comment">// 指向 bulk 的 Quote 部分</span><br>Quote &amp;p = bulk; <span class="hljs-comment">// 引用 bulk 的 Quote 部分</span><br></code></pre></td></tr></table></figure>
<p>基类先初始化，然后才是派生类的成员：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Bulk_quote</span>(<span class="hljs-type">const</span> std::string&amp; book, <span class="hljs-type">double</span> p, <span class="hljs-type">double</span> disc) :<br>    <span class="hljs-built_in">Quote</span>(book, p), <span class="hljs-built_in">discount</span>(dics) &#123; &#125;;<br></code></pre></td></tr></table></figure>
<p>对于 <code>static</code> 成员，则整个层次结构中只有一个该成员实例</p>
<p>使用 <code>final</code> 来防止一个类被继承：<code>class NoDerived final &#123; ... &#125;;</code></p>
<p>静态类型（编译时）和动态类型（运行时）</p>
<p>基类向派生类没有隐式转换</p>
<p>注意这只在 <strong>引用</strong> 和 <strong>指针</strong> 之间讨论，在基类和派生类 <strong>对象</strong> 之间没有隐式转换</p>
<h3 id="虚函数">虚函数</h3>
<p><strong>只有</strong> 在通过指针或引用调用虚函数时，才会在运行时处理，否则在编译时解决</p>
<p>一旦某个函数被定义为 <code>virtual</code>，则会在所有派生类中都定义为 <code>virtual</code></p>
<p>可以使用 <code>override</code> 显式指明覆盖了基类中的某个虚函数</p>
<p>注意只有 <code>virtual</code> 函数可以 <code>override</code>，<code>final</code> 函数不会被 <code>override</code></p>
<p>可以绕开虚函数机制</p>
<h3 id="抽象基类">抽象基类</h3>
<p><strong>纯虚函数 pure virtual</strong> 不会被定义，方法是在声明时在后面加 <code>= 0</code></p>
<p>有纯虚函数的类是 <strong>抽象基类 abstract base class</strong>，不能创建抽象基类的对象，其相当于提供了一个要求派生类覆盖的 <strong>接口</strong></p>
<p>派生类的构造函数只初始化它的直接基类</p>
<h3 id="访问控制和继承">访问控制和继承</h3>
<p><code>public</code> 和 <code>private</code> 继承不影响该类的访问控制，但会影响这个类的用户（包括其派生类）能否访问到其基类的成员</p>
<p>friend 不会被继承</p>
<p>类内部的 <code>using</code> 声明可以使其 <code>private</code> 继承来的被访问到</p>
<h3 id="继承下的类作用域">继承下的类作用域</h3>
<p>名字的查找发生在编译时</p>
<h3 id="构造函数和复制控制">构造函数和复制控制</h3>
<p>析构函数必须是 <code>virtual</code> 的</p>
<p>构造时先构造基类，析构时反过来</p>
<h3 id="容器与继承">容器与继承</h3>
<p>如果我们想要容纳以继承关联的对象，一般放智能指针，这样使用的就是动态类型</p>
<h2 id="模板和泛型编程-Templates-and-Generic-Programming">模板和泛型编程 Templates and Generic Programming</h2>
<p>面向对象编程和泛型变成都是处理 <strong>编写程序</strong> 时不知道的类型的，但是 OOP 在 <strong>运行</strong> 时处理，泛型则在 <strong>编译</strong> 时处理</p>
<h3 id="定义一个模板">定义一个模板</h3>
<p>函数模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;v1, <span class="hljs-type">const</span> T &amp;v2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (v1 &lt; v2) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (v2 &lt; v1) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-built_in">compare</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>) &lt;&lt; endl; <span class="hljs-comment">// 可以推断出模板参数类型</span><br></code></pre></td></tr></table></figure>
<p>我们也可以定义 <strong>非类型参数 nontype parameters</strong>，即表示的是一个 <strong>值</strong> 而不是 <strong>类型</strong>，在模板函数内部一定是一个 <strong>常量表达式</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">unsigned</span> N, <span class="hljs-type">unsigned</span> M&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> (&amp;p1)[N], <span class="hljs-type">const</span> <span class="hljs-type">char</span> (&amp;p2)[M])</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(p1, p2);<br>&#125;<br><span class="hljs-built_in">compare</span>(<span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-string">&quot;mom&quot;</span>); <span class="hljs-comment">// 使用</span><br></code></pre></td></tr></table></figure>
<p>为了生成实例化，编译器需要定义函数模板或类模板成员函数，所以这两者一般都放在头文件中</p>
<p>在类的外部定义类模板成员函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>返回类型 Blob&lt;T&gt;::成员函数名(参数列表)<br></code></pre></td></tr></table></figure>
<p>只有当某个成员被使用时，它才会被实例化</p>
<p>可以让友元的成为模板的所有实例的朋友，也可以一对一成为友元</p>
<p>可以使模板类型参数成为友元：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> &#123;<br>    <span class="hljs-keyword">friend</span> Type;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>可以定义类模板的类型别名：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">using</span> twin = pair&lt;T, T&gt;;<br>twin&lt;strin&gt; authors;<br></code></pre></td></tr></table></figure>
<p>类模板和函数参数支持设置默认值，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> F = less&lt;T&gt;&gt;<br><span class="hljs-type">int</span> <span class="hljs-built_in">compare</span>(<span class="hljs-type">const</span> T &amp;v1, <span class="hljs-type">const</span> T &amp;v2, F f = <span class="hljs-built_in">F</span>()) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">f</span>(v1, v2)) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>       <span class="hljs-keyword">if</span> (<span class="hljs-built_in">f</span>(v2, v1)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以显式实例化来避免开销：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">template</span> 声明; <span class="hljs-comment">// 实例化声明</span><br><span class="hljs-keyword">template</span> 声明; <span class="hljs-comment">// 实例化定义</span><br></code></pre></td></tr></table></figure>
<p><code>unique_ptr</code> 在编译时绑定了 deleter，而 <code>shared_ptr</code> 在运行时绑定了 deleter</p>
<h3 id="模板参数推断">模板参数推断</h3>
<p>模板类型参数的仅有的自动转换是 const 转换和数组或函数指针转换</p>
<p>而常规的转换应用于非模板参数的类型上</p>
<p>函数模板可以显式指定参数类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> T3&gt;<br><span class="hljs-function">T1 <span class="hljs-title">sum</span><span class="hljs-params">(T2, T3)</span></span>;<br><br><span class="hljs-built_in">sum</span>&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;(i, lng);<br></code></pre></td></tr></table></figure>
<p>这是一个返回未知类型的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> It&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">fcn</span><span class="hljs-params">(It beg, It end)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(*beg)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> *beg;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其返回的是一个引用，但是如果是想要按值返回，则可以显式 <strong>类型改变 type transformation</strong>：<code>remove_reference&lt;&gt;</code></p>
<p>引用合并：</p>
<ul>
<li><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code> 都合并为 <code>X&amp;</code></li>
<li><code>X&amp;&amp; &amp;&amp;</code> 合并为 <code>X&amp;&amp;</code></li>
</ul>
<p>故即使参数的形式是右值 <code>&amp;&amp;</code>，也可能合并为左值 <code>&amp;</code></p>
<p>因此，函数参数中的对模板类型的右值引用可以绑定到左值上，即若一个左值传递给这个参数，则会被实例化为左值引用</p>
<p>使用右值的函数模板通常被重载为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp;)</span></span>; <span class="hljs-comment">// 绑定到非 const 右值</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;)</span></span>; <span class="hljs-comment">// 左值和 const 右值</span><br></code></pre></td></tr></table></figure>
<p>实际上，<code>std::move</code> 的原理如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::<span class="hljs-function">type&amp;&amp; <span class="hljs-title">move</span><span class="hljs-params">(T&amp;&amp; t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>std::forward</code> 可以在保持原始参数类型的情况下传递参数，其返回的类型是 <code>T&amp;&amp;</code>，例如实现一个交换调用参数顺序的模板函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flip</span><span class="hljs-params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp; t2)</span> </span>&#123;<br>    <span class="hljs-built_in">f</span>(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="重载和模板">重载和模板</h3>
<p>当有几个重载函数都能够匹配调用时，会选择最详细的那个</p>
<p>如果还有非模板函数也能匹配，则更优先匹配非模板函数</p>
<h3 id="可变模板">可变模板</h3>
<p><strong>可变模板 variadic template</strong> 是接受可变数量的参数的模板函数或类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;t, <span class="hljs-type">const</span> Args&amp; ... rest)</span></span>;<br></code></pre></td></tr></table></figure>
<p>可以使用 <code>sizeof...()</code> 获取包中的元素数量</p>
<p>通常使用递归实现展开：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(ostream &amp;os, <span class="hljs-type">const</span> T &amp;t, <span class="hljs-type">const</span> T &amp;t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> os &lt;&lt; t;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function">ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(ostream &amp;os, <span class="hljs-type">const</span> T &amp;t, <span class="hljs-type">const</span> Args&amp; ... rest)</span> </span>&#123;<br>    os &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">print</span>(os, rest...);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通常和 <code>std::forward&lt;Argss&gt;(args)...</code> 一起使用转发给别的函数</p>
<h3 id="模板特化">模板特化</h3>
<p>我们可以接管编译器做的工作，即 <strong>模板特化 template specialization</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> &amp;p1, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> &amp;p2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(p1, p2);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>模板特化也适用于类模板，但要注意定义在同一个命名空间中</p>
<p>类模板可以部分特化，但函数模板不行</p>
<h2 id="专业化的库设施-Specialized-Library-Facilities">专业化的库设施 Specialized Library Facilities</h2>
<h3 id="tuple-类型"><code>tuple</code> 类型</h3>
<p><code>tuple</code> 和 <code>pair</code> 类似，但是支持容纳多个元素</p>
<p>定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">tuple&lt;<span class="hljs-type">size_t</span>, <span class="hljs-type">size_t</span>, <span class="hljs-type">size_t</span>&gt; item&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure>
<p>或者使用 <code>make_tuple</code></p>
<p>访问其中的元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">tuple_element&lt;<span class="hljs-number">1</span>, <span class="hljs-keyword">decltype</span>(item)&gt;::type cnt = <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(item);<br></code></pre></td></tr></table></figure>
<p>tuple 支持关系比较</p>
<h3 id="bitset-类型"><code>bitset</code> 类型</h3>
<p>定义 32 位：<code>bitset&lt;32&gt; bitvec(1U);</code>，其中低位为 1</p>
<p>也可以从字符串中获取：<code>bitset&lt;32&gt; bitvec4(&quot;1100&quot;);</code>，注意最低位为 0</p>
<p>其支持丰富的操作位的函数</p>
<p>以字符串格式 IO</p>
<h3 id="正则表达式">正则表达式</h3>
<h3 id="随机数">随机数</h3>
<p>使用到了两个类——<strong>随机数引擎 random-number engines</strong> 和 <strong>随机数分布类 random-number distribution classes</strong></p>
<p>生成均匀 <code>[0, 9]</code> 的均匀的随机数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">uniform_int_distribution&lt;<span class="hljs-type">unsigned</span>&gt; <span class="hljs-title">u</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">9</span>)</span></span>;<br><span class="hljs-function">default_random_engine <span class="hljs-title">e</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>    cout &lt;&lt; <span class="hljs-built_in">u</span>(e) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure>
<p>还支持生成小数 <code>uniform_real_distribution&lt;&gt;</code>、正态分布 <code>normal_distribution&lt;&gt;</code></p>
<h3 id="再探-IO-库">再探 IO 库</h3>
<p><strong>操作符 manipulator</strong> 用于控制输出的格式</p>
<p>如十进制、八进制，精度</p>
<p>还支持更低级的 IO：</p>
<ul>
<li><code>is.get(ch)</code> 读下一个字节到 ch 中</li>
<li><code>os.put(ch)</code> 把下一个字符 ch 放到 os 中</li>
<li><code>is.get()</code> 返回下一个字节为 int，因为可能读到的是 EOF</li>
<li><code>is.unget()</code> 放回一个字节</li>
<li><code>is.peek()</code> 返回下一个字节为 int，但不会移除</li>
<li><code>is.putback(ch)</code> 把 ch 放回 is</li>
</ul>
<p>还有支持多字节的版本：</p>
<ul>
<li><code>is.getline(sink, size, delim)</code> 读至多 <code>size</code> 个字节至 EOF 或 delim 到 sink 指向的位置，注意 delim 不会被存储。delim 也会被保存的版本：<code>get</code></li>
<li><code>is.ignore(size, delim)</code></li>
<li><code>os.write(source, size)</code></li>
</ul>
<p>随机读写（<code>p</code> 代表 <strong>写</strong>，<code>g</code> 代表 <strong>读</strong>，但实际上操作的是同一个标志，本没有什么区别）：</p>
<ul>
<li><code>tellg()</code> 获取当前位置</li>
<li><code>seekg(pos)</code> 移动当前位置</li>
<li><code>seekg(off, from)</code></li>
</ul>
<h2 id="用于大型程序的工具-Tools-for-Large-Programs">用于大型程序的工具 Tools for Large Programs</h2>
<h3 id="异常处理">异常处理</h3>
<p>当一个异常发生时，函数会返回并向上传递异常，直到被捕捉或退出程序，这个过程叫 <strong>堆栈展开 stack unwinding</strong>，在该过程中，局部对象的析构函数会被调用，所以要注意向异常传递的指针所指向的对象在异常处理时是否存在</p>
<p>如果一个 <code>catch</code> 无法完全解决问题，需要 <strong>再抛出异常 rethrow</strong>，方法很简单：<code>throw;</code></p>
<p>捕捉所有异常的方法 <code>catch(...)</code></p>
<p><strong>函数 try 块 function try block</strong> 能够将 <code>catch</code> 与语句和构造函数的初始化阶段结合起来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Blob::<span class="hljs-built_in">Blob</span>(std::initializer_list&lt;<span class="hljs-type">int</span>&gt; il) <span class="hljs-keyword">try</span> :<br>    <span class="hljs-built_in">data</span>(std::make_shared&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;(il)) &#123; &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::bad_alloc &amp;e) &#123; <span class="hljs-built_in">handle_out_of_memory</span>(e); &#125;<br></code></pre></td></tr></table></figure>
<p><code>noexcept(true)</code> 表示这个函数 <strong>不会</strong> 抛出异常，<code>noexcept(false)</code> 表示这个函数可能抛出异常，<code>noexcept(函数)</code> 可以判断某个函数是否会抛出异常，通常用于定义一个是否抛出异常取决于函数 <code>g()</code> 的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(<span class="hljs-keyword">noexcept</span>(g()))</span></span>;<br></code></pre></td></tr></table></figure>
<p>异常也有继承的层次结构，可以自定义异常类型</p>
<h3 id="命名空间">命名空间</h3>
<p>为了防止全局命名空间造成的 <strong>命名空间污染 namespace pollution</strong>，引入了 <strong>命名空间 namespace</strong> 用于防止命名冲突</p>
<p>命名空间的定义中包含着各命名的声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> cpp &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sales_data</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">cpp::Sales_data s;<br></code></pre></td></tr></table></figure>
<p>命名空间的定义可以被分到多个文件中</p>
<p>在全局作用域定义的名字被定义在 <strong>全局命名空间 global namespace</strong> 中，显式的使用方法为：<code>::成员名</code></p>
<p>命名空间可以嵌套</p>
<p><strong>内联命名空间 inline namespace</strong> 中的名字可以不需要命名空间名限定即可使用</p>
<p><strong>匿名命名空间 unnamed namespace</strong> 中的名字只会局限于当前文件，无法显式指定，用于替代 <code>static</code> 来是名称局限于当前文件中</p>
<p><strong>命名空间别名 namespace alias</strong> 用于定义某命名空间的缩写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> primer = cplusplus_primer;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>using 声明 using declaration</strong> 每次只引入一个命名空间中的成员</li>
<li><strong>using 指令 using directive</strong> 一次引入了所有的成员</li>
<li>推荐使用前者，因为如果发生了名称冲突，则会在编译时报错，而后者是在运行时报错，且更容易发生冲突</li>
</ul>
<p>注意到这种写法是允许的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">operator</span>&gt;&gt;(std::cin, s);<br></code></pre></td></tr></table></figure>
<p>其中的 <code>operator</code> 前并没有加上 <code>std::</code> 也能正常运行，因为首先会在对象 <code>s</code> 和 <code>cin</code> 定义的作用域中查找相关的 <code>operator</code></p>
<p>因此，<code>std::move</code> 和 <code>std::forward</code> 通常要连着前面的限定一起写，因为如果使用 <code>using std::move</code> 的话，一开始并不是在 <code>std</code> 命名空间中查找 <code>move</code> 函数的，而 <code>move</code> 是个非常常见的名称，容易被误定义过。为了避免这种事，一定要连上 <code>std::</code></p>
<h3 id="多重和虚拟继承">多重和虚拟继承</h3>
<p>一个多继承的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Panda</span> : <span class="hljs-keyword">public</span> Bear, <span class="hljs-keyword">public</span> Endangered &#123; ... &#125;<br></code></pre></td></tr></table></figure>
<p>其构造函数的写法和平常的没什么区别：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Panda::<span class="hljs-built_in">Panda</span>(std::string name, <span class="hljs-type">bool</span> onExhibit)<br>    : <span class="hljs-built_in">Bear</span>(name, onExhibit, <span class="hljs-string">&quot;Panda&quot;</span>)<br>      <span class="hljs-built_in">Endangered</span>(Endangered::critical) &#123; &#125;<br></code></pre></td></tr></table></figure>
<p>最终基类一定第一个初始化，然后按声明的顺序</p>
<p>如果有不同的基类的相同名字的成员，则必须指定是哪个基类的成员</p>
<p>注意到 <code>Bear</code> 和 <code>Endangered</code> 继承了相同的基类 <code>ZooAnimal</code>，为了防止同时继承了这两个类的派生类存在多个 <code>ZooAnimal</code> 部分，需要将这两个类声明为 <strong>虚继承 virtual inheritance</strong>，那个共同的基类叫 <strong>虚基类 virtual base class</strong></p>
<p>声明方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bear</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> ZooAnimal &#123; ... &#125;<br></code></pre></td></tr></table></figure>
<p>虚继承中构造函数保证了虚基类最先初始化，且只被初始化一次</p>
<h2 id="专门的工具和技术-Specialized-Tools-and-Techniques">专门的工具和技术 Specialized Tools and Techniques</h2>
<h3 id="控制内存分配">控制内存分配</h3>
<p>new 表达式构造了对象并调用 new 函数分配内存</p>
<p>delete 同理</p>
<h3 id="运行时类型识别">运行时类型识别</h3>
<p><strong>运行时类型识别 run-time type identification(RTTI)</strong> 通过两个运算符提供：</p>
<ul>
<li><code>typeid</code> 返回给定表达式的类型</li>
<li><code>dynamic_cast</code> 操作符将指向基类的指针或引用转换为指向派生类的指针或引用</li>
</ul>
<p>对于指针，<code>dynamic_cast</code> 失败会返回 <code>nullptr</code>，故一般用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (Derived *dp = <span class="hljs-built_in">dynamic_cast</span>&lt;Derived*&gt;(bp)) &#123;<br><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于引用，则抛出 <code>bad_cast</code> 异常</p>
<p>注意指针的 <code>typeid</code> 返回的是编译时的类型</p>
<h3 id="枚举">枚举</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">color</span> &#123;red, yellow, green&#125;; <span class="hljs-comment">// 无作用域的枚举</span><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">peppers</span> &#123;red, yellow, green&#125;; <span class="hljs-comment">// 有作用域的枚举</span><br>color eyes = green; <span class="hljs-comment">// 无作用域的枚举可以直接使用</span><br>peppers p2 = peppers::red; <span class="hljs-comment">// 有作用域的枚举必须显式指定</span><br></code></pre></td></tr></table></figure>
<p>默认情况下从 0 开始，每次加 1，可以在定义时指定每个枚举量的值</p>
<p>枚举量的值是一个 <code>constexpr</code> 的量</p>
<p>我们可以指定枚举量的类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">intValues</span> : <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br></code></pre></td></tr></table></figure>
<h3 id="类成员指针">类成员指针</h3>
<p>针对数据成员的指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> string Screen::*pdata = &amp;Screen::contents; <span class="hljs-comment">// 定义</span><br><span class="hljs-keyword">auto</span> s = myScreen.*pdata; <span class="hljs-comment">// 使用</span><br></code></pre></td></tr></table></figure>
<p>当然，也可以是成员函数的指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">char</span> (Screen::*pmf2)(Screen::pos, Screen::pos) <span class="hljs-type">const</span> = &amp;Screen::get;<br></code></pre></td></tr></table></figure>
<p>可以通过 <code>function&lt;&gt;</code> 将其转换为一个可调用对象，或者直接使用 <code>mem_fn</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">find_if</span>(svec.<span class="hljs-built_in">begin</span>(), svec.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">mem_fn</span>(&amp;string::empty));<br></code></pre></td></tr></table></figure>
<h3 id="嵌套类">嵌套类</h3>
<p>在类中声明另一个类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextQuery</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">QueryResult</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后在外部定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextQuery</span>::QueryResult &#123;<br>    <span class="hljs-built_in">QueryResult</span>(std::string);<br>&#125;<br></code></pre></td></tr></table></figure>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/dc5fbc03.html" title="IntelliJ IDEA"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/IntelliJ%20IDEA.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">IntelliJ IDEA</div></div><div class="info-2"><div class="info-item-1">IntelliJ IDEA 是 Java 和 Kotlin 的知名 IDE，简单而功能强大 插件推荐 Chinese (Simplified) Language Pack / 中文语言包  我判断一个外国工具是否流行的唯一依据是其是否支持中文。 ——沃兹基·硕德  CodeGlance Pro  侧边栏显示代码缩略图，类似与 VS Code 的功能 Rainbow Brackets：彩虹括号，可惜是付费的，但也有免费的版本：Rainbow Brackets Lite  Alibaba Java Coding Guidelines(XenoAmess TPM)：基于 Java 开发手册，提供了一系列的代码检查和修复功能 Json Parser：验证和格式化 JSON 字符串的工具 Grep Console：给控制台输出标上颜色，过滤输出等 Atom Material Icons：IDEA 版的 Material 图标库 RestfulTool：方便查看 Restful 服务开发  CheckStyle-IDEA：一个著名的 Java Linter </div></div></div></a><a class="pagination-related" href="/posts/6441a1ac.html" title="Makefile"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/Makefile.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Makefile</div></div><div class="info-2"><div class="info-item-1">介绍 Makefile 的基本规则： target ... : prerequisites ...    recipe    ...    ...  target：可以是一个 object file（目标文件），也可以是一个可执行文件，还可以是一个标签（label） prerequisites：生成该 target 所依赖的文件和/或 target recipe：该 target 要执行的命令（任意的 shell 命令）  简单来说就是指定了一个依赖关系 输入 make 命令时，是这么工作的：  make 会在当前目录下找名字叫 Makefile 或 makefile 的文件 如果找到，它会找文件中的第一个目标文件（target），并把这个文件作为最终的目标文件 如果该文件不存在，或其所依赖的后面的 .o 文件的文件修改时间要比这个文件新，则执行后面所定义的命令来生成这个文件 如果所依赖的 .o 文件也不存在，那么 make 会在当前文件中找目标为 .o 文件的依赖性，如果找到则再根据那一个规则生成 .o 文件 最后用 .o 文件生成可执行文件  在 Makefile...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="iconfont icon-tuijian"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/dd378ae0.html" title="Stanford CS106L：标准C++程序设计"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/Stanford%20CS106L%EF%BC%9A%E6%A0%87%E5%87%86%20C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-19</div><div class="info-item-2">Stanford CS106L：标准C++程序设计</div></div><div class="info-2"><div class="info-item-1"> 流 Stream stream 相当于缓冲区 buffer，在不同物件中传输数据 构造 stringstream ##include &lt;iostream&gt;##include &lt;sstream&gt;##include &lt;string&gt;int main() &#123;    std::istringstream iss(&quot;Initial&quot;);    std::ostringstream oss(&quot;Initial&quot;);    std::string s;    iss &gt;&gt; s;    oss &lt;&lt; s;    return 0;&#125; 四个 bits：  Good：准备好读写 Fail：之前的操作失败了 EOF：之前的操作到达了 buffer 的末尾 Bad：外部错误  通常检查 EOF 和 Fail 位的状态 不要大量使用 std::endl，因为每次使用时都会清除一次 buffer，导致效率低下，改为 \n。 还有很多 manipulator 可供使用，例如控制格式的...</div></div></div></a><a class="pagination-related" href="/posts/47e8553d.html" title="C++ Concurrency In Action"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/C++%20Concurrency%20In%20Action.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-03</div><div class="info-item-2">C++ Concurrency In Action</div></div><div class="info-2"><div class="info-item-1">基于 C++ Concurrency In Action Second Edition 编写 C++ 并发世界 并发 concurrency 是指两件或更多分开的活动在同时发生 单核 CPU 通过 context switch 来形成多个任务在同时执行的假象 多核 CPU 原理也类似 并发的方法：  多进程 多线程  并发和并行 parallelism 概念类似，但是  并行通常更考虑效率 并发则关心关注点分离  故使用并发的情况：  关注点分离 任务和数据的并行  C++ 中原来没有关于并发的标准，和 C 语言一样使用操作系统提供的 API。从 C++11 开始，封装了较一般的 thread 等 从并发版的 hello world 开始： ##include &lt;iostream&gt;##include &lt;thread&gt;void hello() &#123;    std::cout &lt;&lt; &quot;Hello, World&quot; &lt;&lt; std::endl;&#125;int main() &#123;   ...</div></div></div></a><a class="pagination-related" href="/posts/f8060ffb.html" title="C++ 入门（上）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/C++%20%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%8A%EF%BC%89.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-05</div><div class="info-item-2">C++ 入门（上）</div></div><div class="info-2"><div class="info-item-1">基于 C++ Primer Fifth 编写 不愧是 C++，这才只是入门，只到 C++ 11 开始 Getting Started 万恶之源： ##include &lt;iostream&gt;int main() &#123;    std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl;    return 0;&#125; 文件的后缀名有很多，最常见的应该是 .cc 和 .cpp 编译器也有很多，如使用 g++ 编译： g++ -o prog1 prog1.cc  添加支持 c++ 11 标准：-std=c++11 -Wall 生成更多警告信息  输入输出：  这里使用了 iostream 库中的标准输入流和标准输出流，该库中还有标准错误流 cerr 和 clog &lt;&lt; 是输出操作符，&gt;&gt; 是输入操作符 endl 是一种 控制符 manipulator，有结束当前行和刷新缓冲区的作用  std:: 表示使用 命名空间 namespace...</div></div></div></a><a class="pagination-related" href="/posts/51f33067.html" title="C++20"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/C++20.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-01</div><div class="info-item-2">C++20</div></div><div class="info-2"><div class="info-item-1">C++20 带来了不亚于 C++11 的重大改变，其中最重要的就是概念、协程、range、模块 Concepts concepts 有多种使用方法： // 使用 requirestemplate&lt;typename T&gt;requires std::integral&lt;T&gt;void f(T t) &#123;&#125;// 直接在模板参数列表中使用template&lt;std::integral T&gt;void f(T t) &#123;&#125;// 在 auto 中使用auto f(std::integral auto t) &#123;&#125; 除了限定参数，也可以限定返回值，类模板，泛型成员函数 支持重载、特化模板 多个 concept 用 &amp;&amp; 连接 有许多预先定义好的 concept，详见 cppreference 定义 concept 的语法： template&lt;typename T&gt;concept MyConcept = requires(T t) &#123;  &#123; t.foo()...</div></div></div></a><a class="pagination-related" href="/posts/f366bb7b.html" title="C++杂项"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/C++%E6%9D%82%E9%A1%B9.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-01</div><div class="info-item-2">C++杂项</div></div><div class="info-2"><div class="info-item-1">安装 C++ 编译器 对于 Windows 用户，这里推荐 WinLibs，里面同时包含了 GCC 和 Clang，以及一些在开发中常用的工具，如 CMake、GNU Make、Ninja、Nasm、Doxygen、cppcheck 等。 将下载的压缩包解压到某个目录，然后将该目录添加到环境变量 PATH 中 配置 VS Code 安装如下插件  clangd：比微软官方的 C/C++ 插件 更好用 CodeLLDB：调试插件 CMake 和 CMake Tools：cmake 是目前看来 c++ 项目中最好的构建工具  配置 clangd // Clangd 运行参数(终端输入 clangd --help-list-hidden 可查看更多)&quot;clangd.arguments&quot;: [  // 允许从项目的 .clangd 文件中读取配置  &quot;--enable-config&quot;,  // compelie_commands.json 文件的目录位置(由于 CMake 生成的该文件默认在 build 文件夹中，故设置为 build) ...</div></div></div></a><a class="pagination-related" href="/posts/30479bcf.html" title="Effective C++"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/Effective%20C++.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-20</div><div class="info-item-2">Effective C++</div></div><div class="info-2"><div class="info-item-1">基于 Effective C++ Third Edition: 55 Specific Ways to Improve Your Programs and designs 编写 让你自己习惯于 C++ 将 C++ 视为语言的联邦 C++ 不是一门单独的语言，其具有各种不同风格的语言特性，以至于可能出现两个同样使用 C++ 的人会看不懂彼此的代码。一般分为四大组成部分：  C 面向对象的 C++ 模板 C++ STL  因此基于使用的 C++ 的部分不用，Effective C++ 编程的规则也可能不同 倾向于 const、enum 和 inline 而不是 #define 对于变量而言，const 和 enum 限制了作用域 对于函数而言，inline 函数能够避免一些未知错误 尽可能使用 const 声明某种东西 const 可以帮助编译器检测一些使用错误，同时 const 可以适用于任何作用域中的对象，包括函数参数，返回值，甚至整个成员函数 编译器强制 bitwise const，但应该使用逻辑 const 编程 当 const 和非 const...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/%E5%A4%B4%E5%83%8F_%E7%81%B0%E5%A4%AA%E7%8B%BC.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Aefrivern</div><div class="author-info-description">我一定会回来的</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">171</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">226</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/aefrivern" rel="external nofollow noreferrer" target="_blank" title="icon-github"><i class="GitHub"></i></a><a class="social-icon" href="mailto:2771503468@qq.com" rel="external nofollow noreferrer" target="_blank" title="icon-youxiang"><i class="QQ邮箱"></i></a><a class="social-icon" href="https://steamcommunity.com/id/old_driver_zero" rel="external nofollow noreferrer" target="_blank" title="icon-steam"><i class="Steam"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><a class="faa-parent animated-hover"><svg class="faa-tada icon" style="height:25px;width:25px;fill:currentColor;position:relative;top:5px" aria-hidden="true"><use xlink:href="#icon-mulu"></use></svg></a><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%9E%8B%E5%AE%B9%E5%99%A8-Associative-Containers"><span class="toc-number">1.</span> <span class="toc-text">关联型容器 Associative Containers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98-Dynamic-Memory"><span class="toc-number">2.</span> <span class="toc-text">动态内存 Dynamic Memory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%8E%A7%E5%88%B6-Copy-Control"><span class="toc-number">3.</span> <span class="toc-text">复制控制 Copy Control</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%EF%BC%8C%E8%B5%8B%E5%80%BC%E5%92%8C%E9%94%80%E6%AF%81"><span class="toc-number">3.1.</span> <span class="toc-text">复制，赋值和销毁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%8E%A7%E5%88%B6%E5%92%8C%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">复制控制和资源管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swap"><span class="toc-number">3.3.</span> <span class="toc-text">Swap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.4.</span> <span class="toc-text">移动对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E5%92%8C%E8%BD%AC%E6%8D%A2-Overloaded-Operations-and-Conversions"><span class="toc-number">4.</span> <span class="toc-text">重载运算和转换 Overloaded Operations and Conversions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-Object-Oriented-Programming"><span class="toc-number">5.</span> <span class="toc-text">面向对象编程 Object-Oriented Programming</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A7%88"><span class="toc-number">5.1.</span> <span class="toc-text">概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-number">5.2.</span> <span class="toc-text">定义基类和派生类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.</span> <span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="toc-number">5.4.</span> <span class="toc-text">抽象基类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-number">5.5.</span> <span class="toc-text">访问控制和继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%8B%E7%9A%84%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">5.6.</span> <span class="toc-text">继承下的类作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%8D%E5%88%B6%E6%8E%A7%E5%88%B6"><span class="toc-number">5.7.</span> <span class="toc-text">构造函数和复制控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">5.8.</span> <span class="toc-text">容器与继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B-Templates-and-Generic-Programming"><span class="toc-number">6.</span> <span class="toc-text">模板和泛型编程 Templates and Generic Programming</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%9D%BF"><span class="toc-number">6.1.</span> <span class="toc-text">定义一个模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E6%8E%A8%E6%96%AD"><span class="toc-number">6.2.</span> <span class="toc-text">模板参数推断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E6%A8%A1%E6%9D%BF"><span class="toc-number">6.3.</span> <span class="toc-text">重载和模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E6%A8%A1%E6%9D%BF"><span class="toc-number">6.4.</span> <span class="toc-text">可变模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96"><span class="toc-number">6.5.</span> <span class="toc-text">模板特化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%93%E4%B8%9A%E5%8C%96%E7%9A%84%E5%BA%93%E8%AE%BE%E6%96%BD-Specialized-Library-Facilities"><span class="toc-number">7.</span> <span class="toc-text">专业化的库设施 Specialized Library Facilities</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tuple-%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.1.</span> <span class="toc-text">tuple 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bitset-%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.2.</span> <span class="toc-text">bitset 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">7.3.</span> <span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">7.4.</span> <span class="toc-text">随机数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E6%8E%A2-IO-%E5%BA%93"><span class="toc-number">7.5.</span> <span class="toc-text">再探 IO 库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B7%A5%E5%85%B7-Tools-for-Large-Programs"><span class="toc-number">8.</span> <span class="toc-text">用于大型程序的工具 Tools for Large Programs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">8.1.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">8.2.</span> <span class="toc-text">命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E5%92%8C%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF"><span class="toc-number">8.3.</span> <span class="toc-text">多重和虚拟继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%93%E9%97%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8A%80%E6%9C%AF-Specialized-Tools-and-Techniques"><span class="toc-number">9.</span> <span class="toc-text">专门的工具和技术 Specialized Tools and Techniques</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">9.1.</span> <span class="toc-text">控制内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB"><span class="toc-number">9.2.</span> <span class="toc-text">运行时类型识别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">9.3.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E6%8C%87%E9%92%88"><span class="toc-number">9.4.</span> <span class="toc-text">类成员指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BB"><span class="toc-number">9.5.</span> <span class="toc-text">嵌套类</span></a></li></ol></li></ol></div></div><div class="card-widget card-post-series"><div class="item-headline"><svg class="meta_icon post-ui-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-a-layergroup"></use></svg><span>系列文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/f366bb7b.html" title="C++杂项"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/C++%E6%9D%82%E9%A1%B9.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++杂项"></a><div class="content"><a class="title" href="/posts/f366bb7b.html" title="C++杂项">C++杂项</a><time datetime="2024-11-01T04:57:19.000Z" title="发表于 2024-11-01 12:57:19">2024-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/51f33067.html" title="C++20"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/C++20.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++20"></a><div class="content"><a class="title" href="/posts/51f33067.html" title="C++20">C++20</a><time datetime="2024-11-01T04:49:19.000Z" title="发表于 2024-11-01 12:49:19">2024-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/47e8553d.html" title="C++ Concurrency In Action"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/C++%20Concurrency%20In%20Action.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ Concurrency In Action"></a><div class="content"><a class="title" href="/posts/47e8553d.html" title="C++ Concurrency In Action">C++ Concurrency In Action</a><time datetime="2024-05-03T07:35:45.000Z" title="发表于 2024-05-03 15:35:45">2024-05-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/162e86b7.html" title="Effective Modern C++"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/Effective%20Modern%20C++.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Effective Modern C++"></a><div class="content"><a class="title" href="/posts/162e86b7.html" title="Effective Modern C++">Effective Modern C++</a><time datetime="2024-04-28T00:58:45.000Z" title="发表于 2024-04-28 08:58:45">2024-04-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/30479bcf.html" title="Effective C++"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/Effective%20C++.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Effective C++"></a><div class="content"><a class="title" href="/posts/30479bcf.html" title="Effective C++">Effective C++</a><time datetime="2024-04-20T01:58:45.000Z" title="发表于 2024-04-20 09:58:45">2024-04-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8724ba9a.html" title="C++ 入门（下）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/C++%20%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%8B%EF%BC%89.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ 入门（下）"></a><div class="content"><a class="title" href="/posts/8724ba9a.html" title="C++ 入门（下）">C++ 入门（下）</a><time datetime="2024-04-10T08:24:19.000Z" title="发表于 2024-04-10 16:24:19">2024-04-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f8060ffb.html" title="C++ 入门（上）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/C++%20%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%8A%EF%BC%89.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ 入门（上）"></a><div class="content"><a class="title" href="/posts/f8060ffb.html" title="C++ 入门（上）">C++ 入门（上）</a><time datetime="2024-04-05T08:24:19.000Z" title="发表于 2024-04-05 16:24:19">2024-04-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>安得广厦千万间，大庇天下寒士俱欢颜，风雨不动安如山。</div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/comments/">留点什么</a><a href="/random/">随便逛逛</a></li><li><a href="/about/">关于</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/gallery/">我的画廊</a><a href="/charts/">网站统计</a></li></ul></div></div></div></div><div class="copyright">&copy;2022 - 2024 By Aefrivern</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><script async src="//at.alicdn.com/t/c/font_4031045_1yiosqv4vch.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/c/font_4031045_izvon5l4fr8.js"></script><!-- hexo injector body_end end --></body></html>