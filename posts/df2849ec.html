<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java | Aefrivern的小屋</title><meta name="author" content="Aefrivern"><meta name="copyright" content="Aefrivern"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基于 Bruce Eckel 的 On Java 8 编写 什么是对象 What is an Object? 面向对象编程的特点：  任何东西都是对象 程序是一堆通过发消息告诉彼此的对象（调用对象的方法） 每个对象有由其它对象组成的内存 每个对象都有一个类型（类是一个实例） 一个特定的类型的所有对象可以收到相同的信息  也可以说：对象有声明（内部数据）、表现（方法）和身份（唯一的内存地址） 对象有">
<meta property="og:type" content="article">
<meta property="og:title" content="Java">
<meta property="og:url" content="https://aefrivern.github.io/posts/df2849ec.html">
<meta property="og:site_name" content="Aefrivern的小屋">
<meta property="og:description" content="基于 Bruce Eckel 的 On Java 8 编写 什么是对象 What is an Object? 面向对象编程的特点：  任何东西都是对象 程序是一堆通过发消息告诉彼此的对象（调用对象的方法） 每个对象有由其它对象组成的内存 每个对象都有一个类型（类是一个实例） 一个特定的类型的所有对象可以收到相同的信息  也可以说：对象有声明（内部数据）、表现（方法）和身份（唯一的内存地址） 对象有">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://aefrivern.github.io/gallery/cover/Java.webp">
<meta property="article:published_time" content="2024-02-26T00:17:22.000Z">
<meta property="article:modified_time" content="2024-11-23T06:03:38.000Z">
<meta property="article:author" content="Aefrivern">
<meta property="article:tag" content="编程语言">
<meta property="article:tag" content="面向对象编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://aefrivern.github.io/gallery/cover/Java.webp"><link rel="shortcut icon" href="/illustration/favicon.ico"><link rel="canonical" href="https://aefrivern.github.io/posts/df2849ec.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"GY5EJYJ1FS","apiKey":"c443c952672ec7062840aac45536181e","indexName":"blog","hitsPerPage":6,"languages":{"input_placeholder":"搜索文章","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4031045_1yiosqv4vch.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/highlight.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/hexo-butterfly-article-double-row.css"><script src="/js/echarts.min.js"></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image: url(/gallery/wallpaper/wallpaper.webp);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/%E5%A4%B4%E5%83%8F_%E7%81%B0%E5%A4%AA%E7%8B%BC.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">171</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">226</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye-01"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-a-16-01-01"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-wenjianjia"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/anime/"><i class="fa-fw iconfont icon-zhifeiji"></i><span> 二次元</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw iconfont icon-xiangce"></i><span> 画廊</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyu"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/charts/"><i class="fa-fw iconfont icon-tongjichaxun"></i><span> 统计</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw iconfont icon-liuyan"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/random/"><i class="fa-fw iconfont icon-suiji"></i><span> 随便逛逛</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/gallery/cover/Java.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Aefrivern的小屋</span></a><a class="nav-page-title" href="/"><span class="site-name">Java</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-sousuo1"></use></svg><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye-01"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-a-16-01-01"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-wenjianjia"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/anime/"><i class="fa-fw iconfont icon-zhifeiji"></i><span> 二次元</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw iconfont icon-xiangce"></i><span> 画廊</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyu"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/charts/"><i class="fa-fw iconfont icon-tongjichaxun"></i><span> 统计</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw iconfont icon-liuyan"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/random/"><i class="fa-fw iconfont icon-suiji"></i><span> 随便逛逛</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-26T00:17:22.000Z" title="发表于 2024-02-26 08:17:22">2024-02-26</time><span class="post-meta-separator">|</span><svg class="meta_icon post-ui-icon" style="width:13px;height:13px;position:relative;top:2px"><use xlink:href="#icon-gengxin"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-23T06:03:38.000Z" title="更新于 2024-11-23 14:03:38">2024-11-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><a class="faa-parent animated-hover"></a><svg class="meta_icon post-ui-icon" style="width:13px;height:13px;position:relative;top:2px"><use xlink:href="#icon-fenlei"></use></svg><a class="post-meta-categories" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-word"></use></svg><span class="post-meta-label">总字数:</span><span class="word-count">6820</span><span class="post-meta-separator">|</span><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>基于 Bruce Eckel 的 <em>On Java 8</em> 编写</p>
<h2 id="什么是对象-What-is-an-Object">什么是对象 What is an Object?</h2>
<p>面向对象编程的特点：</p>
<ul>
<li>任何东西都是对象</li>
<li>程序是一堆通过发消息告诉彼此的对象（调用对象的<strong>方法</strong>）</li>
<li>每个对象有由其它对象组成的内存</li>
<li>每个对象都有一个类型（<strong>类</strong>是一个<strong>实例</strong>）</li>
<li>一个特定的类型的所有对象可以收到相同的信息</li>
</ul>
<p>也可以说：对象有声明（内部数据）、表现（方法）和身份（唯一的内存地址）</p>
<p>对象有<strong>接口</strong></p>
<p>对象通过<strong>方法</strong>提供服务</p>
<p>隐藏的实现——<strong>封装</strong></p>
<p>重复利用实现——<strong>继承</strong></p>
<p><strong>是</strong>和<strong>像</strong>的关系</p>
<p>对象的生命周期——有<strong>垃圾收集器</strong></p>
<h2 id="到处都是对象-Objects-Everywhere">到处都是对象 Objects Everywhere</h2>
<p>使用<strong>引用</strong>操作对象</p>
<p>原始类型，特别的，有“类包装”，如 <code>Character</code></p>
<p>有方便的数组</p>
<p>注释常见每一行开头有一个 <code>*</code>，尽管是不必要的</p>
<p>有作用域，无需手动销毁对象</p>
<p>创建新的数据类型：<code>class</code></p>
<p>域中的原始成员数据默认值为 0，但局部变量随机</p>
<p>Java 中防止名称重复的方法是反向使用域名，如域名为 <code>MindviewInc.com</code> 中的 <code>foibles</code> utility 则包名称为 <code>com.mindviewinc.utility.foibles</code>，注意均为小写。可以想见，包名都会很长，所以 IDE 很重要</p>
<p>当使用其他组件时，需要 <code>import</code>，如 <code>import java.util.ArrayList</code> 或批量导入 <code>import java.util.*</code></p>
<p><code>static</code> 关键字可以修饰域或方法，可以在不创建对象时使用</p>
<ul>
<li>不同的实例的 static 域共享相同的内存地址</li>
<li>static 方法中不能使用非 static 数据或该对象的非 static 方法</li>
</ul>
<h2 id="操作符-Operators">操作符 Operators</h2>
<p>类似于 c，有优先级，赋值，简写，自增，关系等。</p>
<p>注意区分 <code>==</code> 和 <code>.equals()</code> 判断是否相等的区别</p>
<p>逻辑运算符与短路</p>
<p>字面值，如 <code>0x1f</code>（十六进制），<code>0177</code>（八进制）、<code>0b00011</code>（二进制）、<code>200L</code>（<code>long</code> 的后缀）、<code>1F</code>（<code>float</code> 的后缀）、<code>1D</code>(<code>double</code> 的后缀)</p>
<p>可以通过 <code>Integer.toBinaryString()</code> 等类似的函数转换</p>
<p>可以使用下划线分割，使字面值更易读，如 <code>0b0010_1111</code></p>
<p><code>e</code> 表示以 10 为底的指数</p>
<p>位运算</p>
<p>三元运算符</p>
<p><code>string</code> 支持使用 <code>+</code> 连接</p>
<p>强制类型转换：<code>(long) i</code></p>
<p>小于 <code>int</code> 的数据类型在运算时会转换为 <code>int</code> 类型</p>
<p>注意 Java 没有 <code>sizeof()</code>，因为 Java 程序运行在虚拟机上，其数据类型大小在各种机器上是一样的</p>
<h2 id="控制流-Control-Flow">控制流 Control Flow</h2>
<p>有 <code>true</code> 和 <code>false</code>，但注意数字不能直接当布尔类型使用</p>
<p>支持 <code>for-in</code> 结构，即 <code>for (int i : range(10))</code></p>
<p><code>switch</code> 结构支持 <code>string</code></p>
<h2 id="内务工作-Housekeeping">内务工作 Housekeeping</h2>
<p>构造函数与类同名，在实例化后自动调用</p>
<p>特别的，构造函数不需要 <code>return</code>，尽管在 <code>new</code> 的时候返回了一个引用，但不需要手动编写</p>
<p>没有参数的构造函数叫<strong>零参数构造函数</strong>，注意如果你自定义了一个有参数的构造函数，则系统默认你需要零参数构造函数</p>
<p>名称相同，但参数不同，则执行的效果不同，这种情况叫做<strong>重载 overload</strong>。没有返回值重载，因为无法区分调用的是哪个返回值的函数</p>
<p>当访问一个实例中的方法时，类似于将这个对象当作参数传递了进去，如 <code>a.peel(1) -&gt; Banana.peel(a, 1)</code>，故存在 <code>this</code> 关键字，表示对本对象的引用</p>
<p>可以使用 <code>this</code> 在一个构造函数中调用另一个参数的构造函数，但只能调用一个，且必须在开头，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Flower</span> &#123;<br>    Flower(<span class="hljs-type">int</span> petals) &#123;<br>        ...<br>    &#125;<br><br>    Flower(String ss) &#123;<br>        ...<br>    &#125;<br><br>    Flower(String s, <span class="hljs-type">int</span> petals) &#123;<br>        <span class="hljs-built_in">this</span>(petals);<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>垃圾收集可以从栈和静态存储中出发，遍历所有的引用，没有被遍历到的内存空间就是垃圾，要被收集。</p>
<p>Java 起初通过不断增加其管理的空间指针来快速分配空间，当占用达到一定额度时开始清理垃圾。其采用多种方法混合，例如对于垃圾比较多的情况，可以在清理时顺便将所有有用的数据转移到另一个堆中，让空间更紧凑；对于垃圾较少的情况，则只清理垃圾，不移动正常的数据</p>
<p>JVM 中还有一些加速方法，如 **just-in-time（JIT）**编译器可以部分转换程序为机器码，同时随着程序的运行逐渐更改编译的内容来取得更好的效率</p>
<p>成员域默认初始化为 0，可以在定义时就初始化，也可以在构造函数初始化</p>
<p>创建一个类的对象的过程如下：</p>
<ol>
<li>构造函数实际上是一个 <code>static</code> 方法，故当创建一个对象或访问类中的 <code>static</code> 方法或域时，会定位 <code>.class</code></li>
<li>所有的 <code>static</code> 初始化都会运行，且只有 <code>Class</code> 对象被装载时运行一次</li>
<li>当使用 <code>new</code> 时，构造过程在堆上分配对象空间</li>
<li>该存储会置为 0</li>
<li>执行在定义域时的初始化</li>
<li>执行构造函数</li>
</ol>
<p>可以使用 <code>static</code> 块来显式静态初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Spoon</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">static</span> &#123; i = <span class="hljs-number">47</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Java 中支持数组</p>
<p>可变参数列表：<code>void printArray(Object... args)</code></p>
<p>Java 中还支持枚举类型，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Spiciness</span> &#123;<br>    NOT, MILD, MEDIUM, HOT, FLAMTING<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="实现隐藏-Implementation-Hiding">实现隐藏 Implementation Hiding</h2>
<p>package 是库的单元</p>
<p>Java 默认在环境变量 CLASSPATH 指定的目录下查找包，如包 <code>foo.bar.baz</code> 在目录 <code>CLASSPATH/foo/bar/baz</code> 下，若使用 grage，可为每个项目手动设置 CLASSPATH</p>
<p>当导入的不同包中有相同名称的对象，若不使用该对象，不会报错，否则会报错，必须显式指定</p>
<p>包访问权限控制有四种类型：</p>
<ul>
<li><code>public</code> 所有人都可以访问</li>
<li>没有限定符（默认访问），只有在同一个包中的类可以访问该成员</li>
<li><code>protected</code> 只有子类可以访问</li>
<li><code>private</code> 其他人无法访问</li>
</ul>
<p>一般来说成员的域要设计成 <code>private</code></p>
<p>对于类，一般来说都不会设计成 private 和 protected</p>
<p>特别的，可以将构造函数设置为 private 来防止对象的创建，以下设计模式叫 Singleton，只允许创建一个对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Soup2</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Soup2</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Soup2</span> <span class="hljs-variable">ps1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Soup2</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Soup2 <span class="hljs-title function_">access</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> ps1; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Lunch</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStatic</span><span class="hljs-params">()</span> &#123; <span class="hljs-type">Soup1</span> <span class="hljs-variable">soup</span> <span class="hljs-operator">=</span> Soup1.makeSoup(); &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSingleton</span><span class="hljs-params">()</span> &#123; Soup2.access().f(); &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="复用-Reuse">复用 Reuse</h2>
<p>组合——在一个对象中包括了另一个对象 <strong>has-a</strong></p>
<p>继承 <strong>is a</strong></p>
<p>子类构造函数默认先调用了父类的默认构造函数，除非使用 <code>super()</code> 显式调用带参数的构造函数（必须是第一条语句）</p>
<p>Java 中不支持<strong>委派 delegation</strong>，即将一个成员变量放到里面（像组合），但与此同时把其所有的方法都暴露在新类中（像继承）</p>
<p>子类可以覆盖父类的某些成员函数</p>
<p><strong>向上级类型转换 upcasting</strong>：子类的类型可以自动转换为父类的类型</p>
<p>Java 只支持<strong>单</strong>继承，即只有一个父类</p>
<p><code>final</code> 关键词总的意思是<strong>不可变</strong>，一般是为了设计考虑才会使用</p>
<ul>
<li>对于数据，表示常数；特别的，对于一个对象来说，表示的是<strong>引用</strong>不改变</li>
<li>没有初始化值的 final 域叫做<strong>空白 finals</strong>，必须在每个构造函数中初始化</li>
<li>final 参数：不可改变</li>
<li>final 方法：子类不可覆盖该方法，注意到所有的 private 方法已经隐含了是 final 的方法，即不可 override</li>
<li>final 类：禁止继承</li>
</ul>
<p>当类中的代码第一次要用时，类的代码被装载。即通常是访问了一个 static 域或 static 方法时（注意到构造函数也是 static 的）。在装载时，所有的 static 对象和 static 代码块以文本顺序初始化</p>
<h2 id="多态-Polymorphism">多态 Polymorphism</h2>
<p>也称<strong>动态绑定</strong>或<strong>延迟绑定</strong>或<strong>运行时绑定</strong>，即绑定发生在运行时，基于对象的类型</p>
<p>注意，只有正常的函数调用是多态的，即域和静态方法的访问不是多态的，故一般域要设置为 private，以免造成误解</p>
<p>创建复杂对象的构造函数调用顺序：</p>
<ol>
<li>父类构造函数递归调用</li>
<li>以声明顺序调用成员初始化</li>
<li>派生类的构造函数调用</li>
</ol>
<p>如果在构造函数中调用了多态的函数，则可能不会得到预期的结果，故构造函数中最好只做初始化的工作</p>
<p><strong>共变式返回类型 covariant return type</strong>：派生类中的覆盖的方法可以返回基类的派生类的类型</p>
<p>有 upcast，当然也有 downcast，但是有时可能有问题，Java 会检查</p>
<h2 id="接口-Interfaces">接口 Interfaces</h2>
<p>Java 中支持<strong>抽象类 abstract class</strong> 和<strong>接口 interface</strong>，这里只介绍接口，因为其抽象程度更高</p>
<p>接口中的函数声明不写，且只有 public：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PureInterface</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 支持 default，可以不用被 override</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span> &#123; ... &#125;;<br>    <span class="hljs-comment">// 支持静态方法</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(String msg)</span> &#123;<br>        System.out.println(msg);<br>    &#125;<br>    <span class="hljs-comment">// 接口中可以有域，但实际上是静态的</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">RANDOM_INT</span> <span class="hljs-operator">=</span> RAND.nextInt(<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以继承多个<strong>接口</strong></p>
<p><strong>工厂模型设计模式</strong>：生产适应于接口的对象</p>
<h2 id="内部类-Inner-Classes">内部类 Inner Classes</h2>
<p>在一个类的定义中定义另一个类，可以使用 <code>外部类名称.内部类名称</code> 来调用内部类。</p>
<p>这个内部类可以访问外部类的成员，即保留了对外部类的引用</p>
<p>使用 <code>外部类名称.this</code> 返回外部类对象的引用</p>
<p>创建一个内部类对象时，使用 <code>外部类对象.new 内部类名称()</code> 创建</p>
<p>private 内部类可以完全隐藏实现的信息</p>
<p>内部类可以在任意一个<strong>作用域</strong>中，可以是<strong>匿名</strong>的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Parcel7</span> &#123;<br>    <span class="hljs-keyword">public</span> Contents <span class="hljs-title function_">contents</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Contents</span>() &#123;<br>            <span class="hljs-comment">// 内部类的定义</span><br>            <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">11</span>;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">value</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> i; &#125;<br>        &#125;; <span class="hljs-comment">// 别忘了 new 语句末尾的 ;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意内部类初始化使用的数据必须是 final 的</p>
<p>匿名类可以重载构造函数，但是只能重载一个</p>
<p>如果内部类是 static 的，则被称作<strong>嵌套类 nested class</strong>，其意味着：</p>
<ul>
<li>不需要外部类对象来创建嵌套类对象</li>
<li>不能从嵌套类对象访问非静态的外部类对象</li>
</ul>
<p>接口也可以有内部类，但是是 static 且 public 的，甚至可以实现外部接口</p>
<p>可以有多层嵌套的内部类，最内层的类可以直接访问最外层的类的成员</p>
<p>通过内部类，Java 可以间接实现多继承</p>
<p><strong>闭包 closure</strong> 是保持了其被创建的环境的信息的可调用对象，可以通过内部类实现，在实现 GUI 功能时很有用</p>
<p><strong>控制框架 control framework</strong> 要响应事件，内部类在这种设计模式中很有用，可以直接在一个控制器类中定义事件操控要控制的对象，灵活而简便</p>
<p>内部类也可以被继承，但问题在于其拥有一个对外部类的引用，故在继承该内部类的构造函数中，必须传入那个外部类，并调用外部类的构造函数</p>
<p>内部类不可被覆盖</p>
<p>除此之外，内部类还可以定义在代码块中，叫做<strong>局部内部类</strong>，</p>
<p>内部类编译后的名字类似于 <code>LocalInnerClass$1LocalCounter.class</code>，即用 <code>$</code> 分割外部类和内部类的名称</p>
<h2 id="集合-Collections">集合 Collections</h2>
<p>定义一个 ArrayList：<code>ArrayList&lt;Apple&gt; apples = new ArrayList&lt;&gt;();</code></p>
<p>批量添加可以使用 <code>Arrays.asList()</code> 或 <code>Collections.addAll()</code></p>
<p>迭代器包括：<code>next()</code>、<code>hasNext()</code>、<code>remove()</code> 方法</p>
<p>支持 for-in</p>
<h2 id="函数式编程-Functional-Programming">函数式编程 Functional Programming</h2>
<p>可以这样思考 OO 和 FP 两种编程方法：</p>
<p><strong>面向对象编程</strong>抽象<strong>数据</strong>，<strong>函数式编程</strong>抽象<strong>表现</strong></p>
<p>lambda 表达式“似乎”生成了函数，但在 JVM 中只存在类</p>
<p>一个 lambda 表达式的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Body</span> &#123; String <span class="hljs-title function_">detailed</span><span class="hljs-params">(String head)</span>; &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaExpressions</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Body</span> <span class="hljs-variable">bod</span> <span class="hljs-operator">=</span> h -&gt; h  + <span class="hljs-string">&quot;No Parens!&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; System.out.println(bod.detailed(<span class="hljs-string">&quot;Hi!&quot;</span>)); &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Java 中支持<strong>方法引用</strong>，格式为 <code>类名或对象名::方法名</code></p>
<p><strong>未绑定方法引用 unbound method reference</strong>：引用任意一个方法，但没有关联的对象，故在使用时必须提供对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br>    String <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;X::f()&quot;</span>; &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">TransformX</span> &#123; String <span class="hljs-title function_">transform</span><span class="hljs-params">(X x)</span>; &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnboundMethodReference</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TransformX</span> <span class="hljs-variable">sp</span> <span class="hljs-operator">=</span> X::f;<br>        <span class="hljs-type">X</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">X</span>();<br>        System.out.println(sp.transform(x));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>也可以捕捉构造函数，然后通过引用调用构造函数</p>
<p>lambda 表达式和方法引用有接口，每个接口中只有一个抽象方法，叫<strong>函数式方法</strong></p>
<p><code>java.util.function</code> 中已经定义了足够的目标接口，命名规则如下：</p>
<ul>
<li>如果处理对象，这如 <code>Function</code>、<code>Consumer</code>、<code>Predicate</code></li>
<li>如果处理原始参数，则前面为名字，如 <code>LongConsumer</code></li>
<li>如果返回原始类型，则 <code>ToLongFunction</code></li>
<li>如果返回和参数相同的类型，则是一个 <code>Operator</code>，如 <code>UnaryOperator</code></li>
<li>如果有两个参数并返回 boolean，则 <code>Predicate</code></li>
<li>如果有两个不同类型的参数，则名字中有 <code>Bi</code></li>
</ul>
<p>一个使用的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> &#123;<br>    Foo f;<br>    Bar(Foo f) &#123;<span class="hljs-built_in">this</span>.f = f; &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">static</span> Function&lt;Foo, Bar&gt; f1 = f -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>(f);<br>    <span class="hljs-type">Bar</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> f1.apply(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Java 支持高阶函数，即可以生成或消耗一个函数，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">FuncSS</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Function</span>&lt;String, String&gt; &#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProduceFunction</span> &#123;<br>    <span class="hljs-keyword">static</span> FuncSS <span class="hljs-title function_">produce</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> s -&gt; s.toLowerCase(); &#125; <span class="hljs-comment">// 返回一个函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <span class="hljs-type">FuncSS</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> produce(); &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>函数可以组合，使用 <code>andThen(argument)</code>、<code>compose(argument)</code>、<code>and(argument)</code>、<code>or(argument)</code>、<code>negate()</code></p>
<p>一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FunctionComposition</span> &#123;<br>    <span class="hljs-keyword">static</span> Function&lt;String, String&gt; f1 = s -&gt; &#123;<br>        System.out.println(s);<br>        <span class="hljs-keyword">return</span> s.replace(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>);<br>    &#125;,<br>    f2 = s -&gt; s.substring(<span class="hljs-number">3</span>),<br>    f3 = s -&gt; s.toLowerCase(),<br>    f4 = f1.compose(f2).andThen(f3);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(f4.apply(<span class="hljs-string">&quot;GO AFTER ALL AMBULANCES&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>同样支持 Curry，如 <code>Function&lt;String, Function&lt;String, String&gt;&gt; sum = a -&gt; b -&gt; a + b;</code></p>
<h2 id="流-Streams">流 Streams</h2>
<p>流让函数式编程成为可能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(<span class="hljs-number">47</span>).ints(<span class="hljs-number">5</span>, <span class="hljs-number">20</span>).distinct().limit(<span class="hljs-number">7</span>).sorted().forEach(System.out::println);<br></code></pre></td></tr></table></figure>
<p>创建流：<code>Stream.of()</code>；此外，所有的 <code>Collection</code> 都可以使用 <code>stream()</code> 方法创建一个流</p>
<p><code>range()</code> 也返回一个流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">System.out.println(range(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>).sum());<br></code></pre></td></tr></table></figure>
<p><code>Stream.generate()</code> 和 <code>Supplier&lt;T&gt;</code> 使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Stream.generate(() -&gt; <span class="hljs-string">&quot;duplicate&quot;</span>).limit(<span class="hljs-number">3</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure>
<p><code>Stream.iterate()</code> 从一个种子开始，把它传递给方法，结果添加到流中并储存为新的第一个参数</p>
<p>在 Builder 设计模式中，创建一个 builder 对象，传递多片构造信息，最后执行 build 动作</p>
<p><code>.peek()</code> 函数可以不改变流的同时查看流，用于调试</p>
<p><code>sorted()</code> 用于排序</p>
<p><code>distinct()</code> 去重</p>
<p><code>filter(Predicate)</code> 筛选</p>
<p>对每个元素使用函数：<code>map(Function)</code>、<code>mapToInt()</code></p>
<p><code>flatMap(Function)</code> 系列做两件事：map 并把每个流展开为元素</p>
<p>支持 Optional，表示空的流，一个使用的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OptionalBasics</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Optional&lt;String&gt; optString)</span> &#123;<br>        <span class="hljs-keyword">if</span>(optString.isPresent())<br>            System.out.println(optString.get());<br>        <span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">&quot;Nothing inside!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        test(Stream.of(<span class="hljs-string">&quot;Epithets&quot;</span>).findFirst());<br>        test(Stream.&lt;String&gt;empty().findFirst());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>解包 Optionals 的函数：<code>ifPresent(Consumer)</code>、<code>orElse(otherObject)</code>、<code>orElseGet(Supplier)</code>、<code>orElseThrow(Supplier)</code></p>
<p>创建 Optional 的方法：<code>empty()</code>、<code>of(value)</code>、<code>ofNullable(value)</code></p>
<p>终止操作符：<code>toArray()</code>、<code>forEach(Consumer)</code>、<code>collect(Collector)</code></p>
<p>将所有流元素组合起来：<code>reduce(BinaryOperator)</code> 或 <code>reduce(identity, BinaryOperator)</code></p>
<p>还有匹配：<code>allMatch(Predicate)</code>、<code>anyMatch(Predicate)</code>、<code>noneMatch(Predicate)</code></p>
<p>选择元素：<code>findFirst()</code></p>
<p>消息：<code>count()</code>、<code>max()</code>、<code>min()</code></p>
<h2 id="异常-Exceptions">异常 Exceptions</h2>
<p>抛出异常：<code>throw new NullPointerException(&quot;t = null&quot;)</code></p>
<p>捕捉异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br><br>&#125; <span class="hljs-keyword">catch</span>(Type1 id1) &#123;<br><br>&#125; <span class="hljs-keyword">catch</span>(Type2 id2) &#123;<br><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>自定义异常类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span> &#123; &#125;<br></code></pre></td></tr></table></figure>
<p>指明一个方法会抛出某种异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> TooBig, TooSmall, DivZero &#123;...&#125;<br></code></pre></td></tr></table></figure>
<h2 id="验证你的代码-Validating-Your-Code">验证你的代码 Validating Your Code</h2>
<p>单元测试：使用 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://junit.org/junit5/">JUnit 5</a></p>
<ul>
<li><code>@BeforeAll</code>、<code>@AfterAll</code> 在所有测试的最前和最后执行</li>
<li><code>@BeforeEach</code>、<code>@AfterEach</code> 在每个测试……</li>
<li><code>@Test</code> 定义一个测试</li>
</ul>
<p>一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Running testInsert()&quot;</span>);<br>    assertEquals(list.size(), <span class="hljs-number">3</span>);<br>    list.add(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Insert&quot;</span>);<br>    assertEquals(list.size(), <span class="hljs-number">4</span>);<br>    assertEquals(list.get(<span class="hljs-number">1</span>), <span class="hljs-string">&quot;Insert&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>契约式设计 Design by Contract (DbC)</strong>：强调前置条件、后置条件和不变式的检查</p>
<p>Java 中有 <code>assert</code> 用于实现，<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/google/guava">guava</a> 库中也有 <code>verify()</code> 实现类似的功能</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://slf4j.org/">SLF4J</a> 提供了多级的日志输出</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/jdb.html">jdb</a> 用于调试，或者使用 IDE 自带的图形化方法</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/openjdk/jmh">jmh</a> 可以用于测试速度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@State(Scope.Thread)</span><br><span class="hljs-meta">@BenchmarkMode(Mode.AverageTime)</span><br><span class="hljs-meta">@OutputTimeUnit(TimeUnit.MICROSECONDS)</span><br><span class="hljs-meta">@Warmup(iterations = 5)</span><br><span class="hljs-meta">@Measurement(iterations = 5)</span><br><span class="hljs-meta">@Fork(1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JMH1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span>[] la;<br>    <span class="hljs-meta">@Param(&#123;</span><br><span class="hljs-meta">        &quot;1&quot;,</span><br><span class="hljs-meta">        &quot;10&quot;,</span><br><span class="hljs-meta">        &quot;100&quot;,</span><br><span class="hljs-meta">        &quot;1000&quot;,</span><br><span class="hljs-meta">        &quot;10000&quot;,</span><br><span class="hljs-meta">        &quot;100000&quot;</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-meta">@Setup</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setup</span><span class="hljs-params">()</span> &#123;<br>        la = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[size];<br>    &#125;<br><br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAll</span><span class="hljs-params">()</span> &#123;<br>        Arrays.setAll(la, n -&gt; n);<br>    &#125;<br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parallelSetAll</span><span class="hljs-params">()</span> &#123;<br>        Arrays.parallelSetAll(la, n -&gt; n);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="文件-Files">文件 Files</h2>
<p><code>get()</code> 方法将 <code>String</code> 序列或 URI 转化为一个 <code>Path</code> 对象，该对象有很多方法</p>
<p>通过在使用 <code>resolve()</code> 方法来向路径结尾添加片段</p>
<p>使用 <code>Files.readAllLines()</code> 来一次逐行读入整个文件</p>
<p><code>Files.write()</code> 则写入文件</p>
<h2 id="字符串-Strings">字符串 Strings</h2>
<p>Java 中字符串是不可变的</p>
<p>支持和 C 语言类似的 <code>printf()</code>，但一般使用 <code>System.out.format()</code>，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">System.out.format(<span class="hljs-string">&quot;Row 1: [%d %f]%n&quot;</span>, x, y);<br></code></pre></td></tr></table></figure>
<p><code>Formatter</code> 类可以处理格式化，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Turtle</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Formatter f;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Turtle</span><span class="hljs-params">(String name, Formatter f)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.f = f;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123; f.format(<span class="hljs-string">&quot;%s The Turtle is at (%d,%d)%n&quot;</span>, name, x, y); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <span class="hljs-type">Turtle</span> <span class="hljs-variable">tommy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Turtle</span>(<span class="hljs-string">&quot;Tommy&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Formatter</span>(System.out)); &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>String.format()</code> 返回的是一个 <code>String</code></p>
<p>使用 <code>Pattern.compile()</code> 编译正则表达式，调用 <code>.matcher(String)</code> 生成 <code>Matcher</code> 对象，这个对象有多种操作，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Pattern</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Pattern.compile(arg);<br>    <span class="hljs-type">Matcher</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> p.matcher(args[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">while</span>(m.find())<br>        System.out.println( <span class="hljs-string">&quot;Match \&quot;&quot;</span> + m.group() + <span class="hljs-string">&quot;\&quot; at positions &quot;</span> + m.start() + <span class="hljs-string">&quot;-&quot;</span> + (m.end() - <span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>Pattern</code> 中也有一个静态方法 <code>static boolean matches(String regex, CharSequence input)</code></p>
<p><code>matches</code> 匹配整个输入，<code>lookingAt()</code> 匹配开头，<code>find()</code> 找到多个匹配的位置</p>
<p><code>compile()</code> 时还可以传入多个 flags</p>
<p><code>split()</code>、<code>replaceAll() / replaceFirst()</code> 都使用正则表达式</p>
<p><code>reset()</code>可以将现有的 <code>Matcher</code> 对象应用于新的字符序列</p>
<p>输入人类可读的信息可以使用 <code>Scanner</code> 类，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">stdin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(SimpleRead.input);<br>    System.out.println(<span class="hljs-string">&quot;What is your name?&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> stdin.nextLine();<br>    System.out.println(name);<br>    System.out.println( <span class="hljs-string">&quot;How old are you? What is your favorite double?&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> stdin.nextInt();<br>    <span class="hljs-type">double</span> <span class="hljs-variable">favorite</span> <span class="hljs-operator">=</span> stdin.nextDouble();<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="反射-Reflection">反射 Reflection</h2>
<p>编译时有时不知道对象信息，需要通过<strong>反射 reflection</strong> 在运行时获取到对象信息</p>
<p>class loader 在创建某个类的对象时动态地将类装载到 JVM 中</p>
<p>如果你已经有了对某个类的对象的引用，则可以使用 <code>getClass()</code> 获得对类的引用，还有 <code>getInterface()</code> 获得其接口等：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ToyTest</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printInfo</span><span class="hljs-params">(Class cc)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Class name: &quot;</span> + cc.getName() + <span class="hljs-string">&quot; is interface? [&quot;</span> + cc.isInterface() + <span class="hljs-string">&quot;]&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Simple name: &quot;</span> + cc.getSimpleName());<br>        System.out.println( <span class="hljs-string">&quot;Canonical name : &quot;</span> + cc.getCanonicalName());<br>    &#125;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;deprecation&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            c = Class.forName(<span class="hljs-string">&quot;reflection.toys.FancyToy&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span>(ClassNotFoundException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Can&#x27;t find FancyToy&quot;</span>);<br>            System.exit(<span class="hljs-number">1</span>);<br>        &#125;<br>        printInfo(c);<br>        <span class="hljs-keyword">for</span>(Class face : c.getInterfaces())<br>            printInfo(face);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> c.getSuperclass();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">// Requires public zero-argument constructor:</span><br>            obj = up.newInstance();<br>        &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Cannot instantiate&quot;</span>);<br>        &#125;<br>        printInfo(obj.getClass());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>产生对 Class 对象的引用还有一种方法：class 字面值，如 <code>FancyToy.class</code>，特别的，对于原始类型，有 <code>TYPE</code> 域，如 <code>Integer.TYPE</code></p>
<p>准备待使用的类：</p>
<ol>
<li>装载，找到字节码并创建一个 Class 对象</li>
<li>链接，为 static 域分配空间，处理对其他类的引用</li>
<li>初始化，如果有基类，则初始化，执行 static 初始化（初始化推迟到第一个对 static 方法的引用）</li>
</ol>
<p>还有一种反射形式，<code>instanceof</code> 告诉你某个对象是否是一个特定类型的实例，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> Dog)<br>    ((Dog)x).bark();<br></code></pre></td></tr></table></figure>
<p><code>.isInstance()</code> 方法则可以动态地测试一个对象的类型</p>
<p>工厂方法可以被多态地调用，并创建合适类型的对象，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Part</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Supplier</span>&lt;Part&gt; &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getClass().getSimpleName();<br>    &#125;<br>    <span class="hljs-keyword">static</span> List&lt;Supplier&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Part</span>&gt;&gt; prototypes = Arrays.asList(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">FuelFilter</span>(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AirFilter</span>(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CabinAirFilter</span>(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">OilFilter</span>(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">FanBelt</span>(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">PowerSteeringBelt</span>(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">GeneratorBelt</span>()<br>    );<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Random</span> <span class="hljs-variable">rand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(<span class="hljs-number">47</span>);<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Part <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> rand.nextInt(prototypes.size());<br>       <span class="hljs-keyword">return</span> prototypes.get(n).get();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Filter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Part</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FuelFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> FuelFilter <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FuelFilter</span>(); &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>instanceof</code> 返回真，如果是一个类或这个类的子类</p>
<p><code>.getMethods()</code> 和 <code>.getConstructors()</code> 返回方法和构造函数的数组</p>
<p><strong>代理 proxy</strong> 是在对象之间插入一个额外的操作的对象，Java 中有<strong>动态</strong>代理，即创建代理对象和处理调用代理方法都是动态的，所有对动态代理的调用都重定向到 invocation handler 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.*;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicProxyHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> Object proxied;<br>    DynamicProxyHandler(Object proxied) &#123;<br>        <span class="hljs-built_in">this</span>.proxied = proxied;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span><br>    <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println( <span class="hljs-string">&quot;**** proxy: &quot;</span> + proxy.getClass() + <span class="hljs-string">&quot;, method: &quot;</span> + method + <span class="hljs-string">&quot;, args: &quot;</span> + args);<br>        <span class="hljs-keyword">if</span>(args != <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">for</span>(Object arg : args)<br>                System.out.println(<span class="hljs-string">&quot; &quot;</span> + arg);<br>        <span class="hljs-keyword">return</span> method.invoke(proxied, args);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleDynamicProxy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consumer</span><span class="hljs-params">(Interface iface)</span> &#123;<br>        iface.doSomething();<br>        iface.somethingElse(<span class="hljs-string">&quot;bonobo&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">RealObject</span> <span class="hljs-variable">real</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealObject</span>();<br>        consumer(real);<br>        <span class="hljs-comment">// Insert a proxy and call again:</span><br>        <span class="hljs-type">Interface</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (Interface)Proxy.newProxyInstance(<br>            Interface.class.getClassLoader(),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123; Interface.class &#125;,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">DynamicProxyHandler</span>(real));<br>        consumer(proxy);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们之前学习了 <code>Optional</code>，但通常不好在所有地方都使用这个，而是应该在<strong>接近数据</strong>的地方使用，</p>
<p>反射也带来了一些安全问题，如果有了源代码，就可以在外部调用 <code>private</code> 方法，添加自己的方法等</p>
<h2 id="泛型-Generics">泛型 Generics</h2>
<p>一个泛型类的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tuple2</span>&lt;A, B&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> A a1;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> B a2;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tuple2</span><span class="hljs-params">(A a, B b)</span> &#123; a1 = a; a2 = b; &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">rep</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> a1 + <span class="hljs-string">&quot;, &quot;</span> + a2; &#125;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;(&quot;</span> + rep() + <span class="hljs-string">&quot;)&quot;</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>同样的，接口也可以是泛型的，如 <code>Supplier&lt;T&gt;</code></p>
<p>静态方法也可以是泛型的，参数也可以是泛型的，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SafeVarargs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title function_">makeList</span><span class="hljs-params">(T... args)</span> &#123;<br>    List&lt;T&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(T item : args)<br>    result.add(item);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在泛型的内部，泛型参数的类型被擦去了，即在运行时，<code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code> 都变成了 <code>List</code></p>
<p>这种设计是历史遗留问题，因为这样就可以兼容泛型和非泛型的库了</p>
<p>可以对泛型设一些界限，如 <code>&lt;T extends HasColor&gt;</code>、<code>&lt;T super Red&gt;</code></p>
<p><strong>wildcard</strong>，如 <code>&lt;? extends Fruit&gt;</code> 和 <code>&lt;? super Myclass&gt;</code></p>
<p>甚至还有无界限的版本 <code>&lt;?&gt;</code></p>
<h2 id="数组-Arrays">数组 Arrays</h2>
<p><code>Arrays.toString()</code> 将数组转化为一个可读的字符串</p>
<p>初始化有多种方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">BerylliunmSphere[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BerylliunmSphere</span>[<span class="hljs-number">5</span>];<br>BerylliunmSphere[] b = &#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">BerylliunmSpher</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">BerylliunmSphere</span>()&#125;;<br>BerylliunmSphere[] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BerylliunmSphere</span>[] &#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">BerylliunmSphere</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">BerylliunmSphere</span>()&#125;<br></code></pre></td></tr></table></figure>
<p>默认初始值为 <code>null</code> 或 <code>0</code></p>
<p>Java 中可以返回数组</p>
<p><code>Arrays.deepToString()</code> 可以将多维数组转化为字符串</p>
<p><code>Arrays.fill()</code> 用某个值填充某个数组</p>
<p><code>Arrays.setAll(long[] a, intToLongFunction gen)</code> 等的第二个参数接受一个 <code>index</code> 并生成填充数组该位的值</p>
<p>此外，<code>Arrays</code> 中还有一些有用的方法，如 <code>asList()</code>、<code>copyOf()</code>、<code>copyOfRange()</code>、<code>equals()</code>、<code>deepEquals()</code>、<code>stream()</code>、<code>sort()</code>、<code>binarySearch()</code> 等</p>
<h2 id="枚举-Enumerations">枚举 Enumerations</h2>
<p>一个简单的枚举：<code>enum Shrubbery &#123; GROUND, CRAWLING, HANGING &#125;</code></p>
<ul>
<li><code>.ordinal()</code> 从 0 开始依声明顺序给每个 enum 编号的 int</li>
<li><code>Enum.valueOf(Shrubbery.class, s)</code> 产生 <code>s</code> 名字对应的实例</li>
</ul>
<p>使用 <code>static</code> 导入把实例标识符导入到本地命名空间中，故不需要再加限定</p>
<p><code>enum</code> 和普通的类没太大的区别，可以添加构造函数和方法等</p>
<p>实质上所有的 <code>enum</code> 类型都继承于 <code>Enum</code></p>
<p><code>EnumSet</code> 在元素基数较小时，可以替代 <code>HashSet</code>，其内部使用 64 位二进制实现，速度更快：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">EnumSet&lt;AlarmPoints&gt; points = EnumSet.noneOf(AlarmPoints.class);<br></code></pre></td></tr></table></figure>
<p><code>EnumMap</code> 同理</p>
<h2 id="注解-Annotations">注解 Annotations</h2>
<p><code>@Deprecated</code> 生成编译器警告，<code>@SuppressWarnings</code> 关闭不合适的编译器警告，<code>@FunctionalInterface</code> 这是一个函数接口</p>
<p>自定义注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> UseCase &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">id</span><span class="hljs-params">()</span>;<br>    String <span class="hljs-title function_">description</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;no description&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>@Target</code> 定义了何处应用这个注解</li>
<li><code>@Retention</code> 定义了注解在源代码 <code>SOURCE</code>、类文件 <code>CLASS</code> 还是运行时 <code>RUNTIME</code></li>
</ul>
<p>没有任何元素的注解，如 <code>@Test</code>，叫做<strong>标记注解 marker annotation</strong></p>
<p>使用注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PasswordUtils</span> &#123;<br>    <span class="hljs-meta">@UseCase(id = 47, description = &quot;password&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validatePassword</span><span class="hljs-params">(String passwd)</span> &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-meta">@UseCase(id = 48)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">encryptPassword</span><span class="hljs-params">(String passwd)</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="并发编程-Concurrent-Programming">并发编程 Concurrent Programming</h2>
<p>Java 8 中的 stream 最大的好处就是可以通过 <code>.parallel()</code> 实现并行</p>
<p>但是正如所有并行程序都会面临的问题，并行并不一定会运行更快，与 <code>limit()</code> 一起使用也会导致很多和预期不同的错误</p>
<p>可以创建一个任务类型，交给 <code>ExecutorService</code> 来运行，<code>ExecutorService</code> 能够维护线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NapTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleThreadExecutor</span> &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">exec</span> <span class="hljs-operator">=</span> Excecutors.newSingleThreadExecutor();<br>    exec.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NapTask</span>);<br>    exec.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>.newSingleThreadExecutor()</code> 是单线程的，而 <code>.newCacheThreadPool()</code> 则是多线程运行</p>
<p>也可以用返回值的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountingTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CachedThreadPool3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">extractResult</span><span class="hljs-params">(Future&lt;Integer&gt; f)</span> &#123; <span class="hljs-keyword">return</span> f.get(); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">exec</span> <span class="hljs-operator">=</span> Excecutors.newCacheThreadPool();<br>        List&lt;CountingTask&gt; tasks;<br>        List&lt;Future&lt;Integer&gt;&gt; futures = exec.invokeAll(tasks);<br>        <span class="hljs-comment">// 单个 future</span><br>        Future&lt;Integer&gt; f = exec.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CountingTask</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>但是，<code>Future</code> 机制已经不推荐了</strong></p>
<p><code>Atomic</code> 类中的类型可以不用担心竞争问题</p>
<p><code>CompletableFuture</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">CompletableFuture&lt;Machina&gt; cf = CompletableFuture.completedFuture(<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Machina</span>(<span class="hljs-number">0</span>))<br>    .thenApplyAsync(Machina::work)<br>cf.join();<br></code></pre></td></tr></table></figure>
<p><code>thenApplyAsync</code> 和 <code>thenApply</code> 的区别在于前者是异步的，后者立刻返回</p>
<h2 id="Javadoc">Javadoc</h2>
<p>格式：<code>/** */</code></p>
<p>两种使用方法：内嵌 HTML 或使用 doc tag</p>
<p>有三种类型的注释：类、域、方法</p>
<p>默认不会输出 <code>private</code> 和包访问的成员</p>
<p>常用的 HTML：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;ol&gt;</span><br><span class="hljs-comment"> * &lt;li&gt; one</span><br><span class="hljs-comment"> * &lt;li&gt; two</span><br><span class="hljs-comment"> * &lt;/ol&gt;</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<p>标签：</p>
<ul>
<li><code>@see</code> 参考其他类中的文档，如 <code>@see 类名</code> 或 <code>@see 完全类名#方法名</code></li>
<li><code>&#123;@link 包名.类名#方法 标签&#125;</code> 类似于 <code>@see</code>，但是是内联的，且可以自定义标签</li>
<li><code>&#123;@docRoot&#125;</code> 创建文档根目录的相对路径</li>
<li><code>&#123;@inheritDoc&#125;</code> 从最近的基类中继承文档</li>
<li><code>@version</code>、<code>@author</code>、<code>@since</code></li>
<li><code>@param</code>、<code>@return</code>、<code>@throws</code></li>
</ul>
<h2 id="I-O-流-I-O-Streams">I/O 流 I/O Streams</h2>
<p>输入流 <code>InputStream</code> 的类型：</p>
<table>
<thead>
<tr>
<th>类</th>
<th>功能</th>
<th>构造参数</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ByteArrayInputStream</code></td>
<td>允许内存中的 buffer 充当输入流</td>
<td>提取字节的 buffer</td>
</tr>
<tr>
<td><code>FileInputStream</code></td>
<td>从文件中读</td>
<td>一个代表文件名的字符串或 <code>File</code></td>
</tr>
<tr>
<td><code>PipedInputStream</code></td>
<td>从一端输入，另一端出来</td>
<td><code>PipedOutputStream</code></td>
</tr>
</tbody>
</table>
<p>输入的同理，不再赘述</p>
<p>以上所有的流都必须连接到一个 <code>FilterInputStream</code> 来提供更多的接口</p>
<p><code>FilterInputStream</code> 的类型：</p>
<table>
<thead>
<tr>
<th>类</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DataInputStream</code></td>
<td>从一个流中读原始类型数据</td>
</tr>
<tr>
<td><code>BufferedInputStream</code></td>
<td>使用了一个 buffer 读</td>
</tr>
</tbody>
</table>
<p>对于输出，特别的，有 <code>PrintStream</code>，其产生格式化的输出，应该是 <code>OutputStream</code> 的最终包装</p>
<p><code>Reader</code> 和 <code>Writer</code> 相当于 <code>InputStream</code> 和 <code>OutputStream</code> 的改名，区别不大</p>
<h2 id="低级别并发-Low-Level-Concurrency">低级别并发 Low-Level Concurrency</h2>
<p>可以将方法声明为 <code>synchronized</code> 避免冲突：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123; &#125;<br></code></pre></td></tr></table></figure>
<p>也可以使用 <code>Lock</code> 类来显式上锁</p>
<p>另外，还有一些实现了 <code>Delayed</code> 接口的无锁数据结构，如 <code>DelayQueue</code></p>
<h2 id="数据压缩-Data-Compression">数据压缩 Data Compression</h2>
<p>将普通的 I/O 流用 <code>ZipOutputStream</code>、<code>GZIPOutputStream</code> 和 <code>ZipInputStream</code>、<code>GZIPInputStream</code> 包围即可</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">面向对象编程</a></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/fda4520e.html" title="为美好的世界献上祝福"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/%E4%B8%BA%E7%BE%8E%E5%A5%BD%E7%9A%84%E4%B8%96%E7%95%8C%E7%8C%AE%E4%B8%8A%E7%A5%9D%E7%A6%8F.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">为美好的世界献上祝福</div></div><div class="info-2"><div class="info-item-1"> 美好世界 能够让人眼前一亮的异世界作品，如果要深究起整个故事的背景，或许是比较灰暗的，敌人异常地强大。但是这部作品并没有像普通的异世界作品那样集中笔墨于异世界的冒险故事，人设、后宫、背景、搞笑都只是陪衬，目的是突出这种已经被用烂了的冒险桥段。而是别出心裁，着重刻画主人公们在异世界的打打闹闹的生活（搬砖、piaochang），还有异世界的风土人情（红魔族和阿库西斯教团），还有那些善良而有趣的“NPC”（道具店老板），而所谓的“冒险”和对抗魔王只是顺手做的事情。 正如这两季的 ed...</div></div></div></a><a class="pagination-related" href="/posts/e5d89884.html" title="全栈公开课（第二部分）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/%E5%85%A8%E6%A0%88%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">全栈公开课（第二部分）</div></div><div class="info-2"><div class="info-item-1">React router、自定义 hook，利用 CSS 和 webpack 给 app 添加样式 React-router 使用 React Router 库生成导航栏： import &#123; BrowserRouter as Router, Routes, Route, Link &#125; from &#x27;react-router-dom&#x27;;const App = () =&gt; &#123;  const padding = &#123;    padding: 5,  &#125;;  return (    &lt;Router&gt;      &lt;div&gt;        &lt;Link style=&#123;padding&#125; to=&#x27;/&#x27;&gt;          home        &lt;/Link&gt;        &lt;Link style=&#123;padding&#125; to=&#x27;/notes&#x27;&gt;          notes       ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="iconfont icon-tuijian"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/41002d9e.html" title="Rust"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/Rust.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-26</div><div class="info-item-2">Rust</div></div><div class="info-2"><div class="info-item-1">  基于 The Rust Programming Language 编写 安装 安装：rustup 换源从来是任何需要联网的应用的第一步，这里使用的是字节的 RsProxy：  设置 Rustup 镜像（Windows 下则设置两个环境变量）  export RUSTUP_DIST_SERVER=&quot;https://rsproxy.cn&quot;export RUSTUP_UPDATE_ROOT=&quot;https://rsproxy.cn/rustup&quot;  设置 crates.io 镜像：  ~/.cargo/config.toml： [source.crates-io]replace-with = &#x27;rsproxy-sparse&#x27;[source.rsproxy]registry = &quot;https://rsproxy.cn/crates.io-index&quot;[source.rsproxy-sparse]registry =...</div></div></div></a><a class="pagination-related" href="/posts/af1c25a3.html" title="golang"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/golang.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-25</div><div class="info-item-2">golang</div></div><div class="info-2"><div class="info-item-1">简介 老传统了： package mainimport &quot;fmt&quot;func main() &#123;    fmt.Println(&quot;Hello, World!&quot;)&#125; 然后可以直接运行： go run hello.go 为了简化依赖管理，一般使用模块特性，使用 go mod init example.com/m 等来生成一个 go.mod 文件，当前目录会被视为一个模块  go mod tidy 用来一键添加并清理依赖  大型项目一般使用 go build 或 go install 来构建 换源 go env -w GO111MODULE=ongo env -w GOPROXY=https://goproxy.cn,direct 基本元素 特别的，go 强制大括号不换号 大写字母开头的为 导出（公开）标识符，反之为非导出标识符 基本内置类型有 int32、float 64、complex128 等，还有一些平台特定的，如 int 等 type status bool // 类型定义声明，是两个不同的类型type status...</div></div></div></a><a class="pagination-related" href="/posts/364ea8cc.html" title="设计模式"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-21</div><div class="info-item-2">设计模式</div></div><div class="info-2"><div class="info-item-1">基于 Design Patterns: Elements of Reusable Object-Oriented Software 编写 介绍 设计模式有四大必备元素：  模式名 问题：何时应用此模式 解决方案：应用于不同情况下的模板 后果：应用该模式的结果与取舍  多种设计模式可以组合使用，事实上也经常组合使用 设计模式解决问题的方法：  找到合适的对象 确定对象的粒度 具体说明对象接口 具体说明对象实现 类与接口继承 给接口编程，而不是向实现  为了让复用机制生效  继承与组合——倾向于组合 指派 继承与参数化类型  运行时和编译时结构  aggregation：一个对象拥有另一个对象，即两者有相同的生命周期 acquaintance：一个对象仅仅知道另一个对象  为改变而设计：  通过  应用程序：  工具集 框架  创建模式 抽象工厂 Abstract Factory 目的：在具体说明具体类的情况下创建相关的对象家族 应用  一个应该被配置为多种产品家族之一的系统 一个家族的相关产品被一起使用 提供一类库的产品  结构  参与者  抽象工厂 - 具体工厂 抽象产品 -...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/%E5%A4%B4%E5%83%8F_%E7%81%B0%E5%A4%AA%E7%8B%BC.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Aefrivern</div><div class="author-info-description">我一定会回来的</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">171</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">226</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/aefrivern" rel="external nofollow noreferrer" target="_blank" title="icon-github"><i class="GitHub"></i></a><a class="social-icon" href="mailto:2771503468@qq.com" rel="external nofollow noreferrer" target="_blank" title="icon-youxiang"><i class="QQ邮箱"></i></a><a class="social-icon" href="https://steamcommunity.com/id/old_driver_zero" rel="external nofollow noreferrer" target="_blank" title="icon-steam"><i class="Steam"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><a class="faa-parent animated-hover"><svg class="faa-tada icon" style="height:25px;width:25px;fill:currentColor;position:relative;top:5px" aria-hidden="true"><use xlink:href="#icon-mulu"></use></svg></a><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1-What-is-an-Object"><span class="toc-number">1.</span> <span class="toc-text">什么是对象 What is an Object?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%B0%E5%A4%84%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1-Objects-Everywhere"><span class="toc-number">2.</span> <span class="toc-text">到处都是对象 Objects Everywhere</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6-Operators"><span class="toc-number">3.</span> <span class="toc-text">操作符 Operators</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81-Control-Flow"><span class="toc-number">4.</span> <span class="toc-text">控制流 Control Flow</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%8A%A1%E5%B7%A5%E4%BD%9C-Housekeeping"><span class="toc-number">5.</span> <span class="toc-text">内务工作 Housekeeping</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E9%9A%90%E8%97%8F-Implementation-Hiding"><span class="toc-number">6.</span> <span class="toc-text">实现隐藏 Implementation Hiding</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E7%94%A8-Reuse"><span class="toc-number">7.</span> <span class="toc-text">复用 Reuse</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81-Polymorphism"><span class="toc-number">8.</span> <span class="toc-text">多态 Polymorphism</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-Interfaces"><span class="toc-number">9.</span> <span class="toc-text">接口 Interfaces</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB-Inner-Classes"><span class="toc-number">10.</span> <span class="toc-text">内部类 Inner Classes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88-Collections"><span class="toc-number">11.</span> <span class="toc-text">集合 Collections</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-Functional-Programming"><span class="toc-number">12.</span> <span class="toc-text">函数式编程 Functional Programming</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81-Streams"><span class="toc-number">13.</span> <span class="toc-text">流 Streams</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8-Exceptions"><span class="toc-number">14.</span> <span class="toc-text">异常 Exceptions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81-Validating-Your-Code"><span class="toc-number">15.</span> <span class="toc-text">验证你的代码 Validating Your Code</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6-Files"><span class="toc-number">16.</span> <span class="toc-text">文件 Files</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-Strings"><span class="toc-number">17.</span> <span class="toc-text">字符串 Strings</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84-Reflection"><span class="toc-number">18.</span> <span class="toc-text">反射 Reflection</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B-Generics"><span class="toc-number">19.</span> <span class="toc-text">泛型 Generics</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-Arrays"><span class="toc-number">20.</span> <span class="toc-text">数组 Arrays</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE-Enumerations"><span class="toc-number">21.</span> <span class="toc-text">枚举 Enumerations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-Annotations"><span class="toc-number">22.</span> <span class="toc-text">注解 Annotations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-Concurrent-Programming"><span class="toc-number">23.</span> <span class="toc-text">并发编程 Concurrent Programming</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Javadoc"><span class="toc-number">24.</span> <span class="toc-text">Javadoc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O-%E6%B5%81-I-O-Streams"><span class="toc-number">25.</span> <span class="toc-text">I&#x2F;O 流 I&#x2F;O Streams</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8E%E7%BA%A7%E5%88%AB%E5%B9%B6%E5%8F%91-Low-Level-Concurrency"><span class="toc-number">26.</span> <span class="toc-text">低级别并发 Low-Level Concurrency</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9-Data-Compression"><span class="toc-number">27.</span> <span class="toc-text">数据压缩 Data Compression</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>安得广厦千万间，大庇天下寒士俱欢颜，风雨不动安如山。</div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/comments/">留点什么</a><a href="/random/">随便逛逛</a></li><li><a href="/about/">关于</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/gallery/">我的画廊</a><a href="/charts/">网站统计</a></li></ul></div></div></div></div><div class="copyright">&copy;2022 - 2024 By Aefrivern</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><script async src="//at.alicdn.com/t/c/font_4031045_1yiosqv4vch.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/c/font_4031045_izvon5l4fr8.js"></script><!-- hexo injector body_end end --></body></html>