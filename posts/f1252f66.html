<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>ETH Zurich：数字设计与计算机体系结构 | Aefrivern的小屋</title><meta name="author" content="Aefrivern"><meta name="copyright" content="Aefrivern"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="引言与基础 Introduction and Basics 当前的四大方向：  安全 节省能源 低延时和可预测 AI&#x2F;ML，生物，医疗，健康等的专属硬件  课程高层次目标：  了解基础 原则 惯例  基于此：  了解计算机工作 权衡不同的设计和思想 实现基于原则的硬件 在越来越复杂的系统中 debug 开发新颖的、开箱即用的设计  这些 DDCA 的原则有利于：  设计更好的硬件、软件、系统 设计">
<meta property="og:type" content="article">
<meta property="og:title" content="ETH Zurich：数字设计与计算机体系结构">
<meta property="og:url" content="https://aefrivern.github.io/posts/f1252f66.html">
<meta property="og:site_name" content="Aefrivern的小屋">
<meta property="og:description" content="引言与基础 Introduction and Basics 当前的四大方向：  安全 节省能源 低延时和可预测 AI&#x2F;ML，生物，医疗，健康等的专属硬件  课程高层次目标：  了解基础 原则 惯例  基于此：  了解计算机工作 权衡不同的设计和思想 实现基于原则的硬件 在越来越复杂的系统中 debug 开发新颖的、开箱即用的设计  这些 DDCA 的原则有利于：  设计更好的硬件、软件、系统 设计">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://aefrivern.github.io/gallery/cover/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.webp">
<meta property="article:published_time" content="2023-10-25T00:17:22.000Z">
<meta property="article:modified_time" content="2024-11-23T06:30:08.000Z">
<meta property="article:author" content="Aefrivern">
<meta property="article:tag" content="体系结构">
<meta property="article:tag" content="计算机科学">
<meta property="article:tag" content="ETH Zurich">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://aefrivern.github.io/gallery/cover/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "ETH Zurich：数字设计与计算机体系结构",
  "url": "https://aefrivern.github.io/posts/f1252f66.html",
  "image": "https://aefrivern.github.io/gallery/cover/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.webp",
  "datePublished": "2023-10-25T00:17:22.000Z",
  "dateModified": "2024-11-23T06:30:08.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Aefrivern",
      "url": "https://aefrivern.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/illustration/favicon.ico"><link rel="canonical" href="https://aefrivern.github.io/posts/f1252f66.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"GY5EJYJ1FS","apiKey":"c443c952672ec7062840aac45536181e","indexName":"blog","hitsPerPage":6,"languages":{"input_placeholder":"搜索文章","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ETH Zurich：数字设计与计算机体系结构',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4031045_1yiosqv4vch.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/highlight.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/hexo-butterfly-article-double-row.css"><script src="/js/echarts.min.js"></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image: url(/gallery/wallpaper/wallpaper.webp);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/%E5%A4%B4%E5%83%8F_%E7%81%B0%E5%A4%AA%E7%8B%BC.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">186</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">240</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye-01"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-a-16-01-01"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-wenjianjia"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/anime/"><i class="fa-fw iconfont icon-zhifeiji"></i><span> 二次元</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw iconfont icon-xiangce"></i><span> 画廊</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyu"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/charts/"><i class="fa-fw iconfont icon-tongjichaxun"></i><span> 统计</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw iconfont icon-liuyan"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/random/"><i class="fa-fw iconfont icon-suiji"></i><span> 随便逛逛</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/gallery/cover/ETH Zurich：数字设计与计算机体系结构.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Aefrivern的小屋</span></a><a class="nav-page-title" href="/"><span class="site-name">ETH Zurich：数字设计与计算机体系结构</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-sousuo1"></use></svg><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye-01"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-a-16-01-01"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-wenjianjia"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/anime/"><i class="fa-fw iconfont icon-zhifeiji"></i><span> 二次元</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw iconfont icon-xiangce"></i><span> 画廊</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyu"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/charts/"><i class="fa-fw iconfont icon-tongjichaxun"></i><span> 统计</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw iconfont icon-liuyan"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/random/"><i class="fa-fw iconfont icon-suiji"></i><span> 随便逛逛</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">ETH Zurich：数字设计与计算机体系结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-25T00:17:22.000Z" title="发表于 2023-10-25 08:17:22">2023-10-25</time><span class="post-meta-separator">|</span><svg class="meta_icon post-ui-icon" style="width:13px;height:13px;position:relative;top:2px"><use xlink:href="#icon-gengxin"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-23T06:30:08.000Z" title="更新于 2024-11-23 14:30:08">2024-11-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><a class="faa-parent animated-hover"></a><svg class="meta_icon post-ui-icon" style="width:13px;height:13px;position:relative;top:2px"><use xlink:href="#icon-fenlei"></use></svg><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-word"></use></svg><span class="post-meta-label">总字数:</span><span class="word-count">1.2w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="引言与基础-Introduction-and-Basics">引言与基础 Introduction and Basics</h2>
<p>当前的四大方向：</p>
<ul>
<li>安全</li>
<li>节省能源</li>
<li>低延时和可预测</li>
<li>AI/ML，生物，医疗，健康等的专属硬件</li>
</ul>
<p>课程高层次目标：</p>
<ul>
<li>了解基础</li>
<li>原则</li>
<li>惯例</li>
</ul>
<p>基于此：</p>
<ul>
<li>了解计算机工作</li>
<li>权衡不同的设计和思想</li>
<li>实现基于原则的硬件</li>
<li>在越来越复杂的系统中 debug</li>
<li>开发新颖的、开箱即用的设计</li>
</ul>
<p>这些 DDCA 的原则有利于：</p>
<ul>
<li>设计更好的硬件、软件、系统</li>
<li>设计中更好地取舍</li>
<li>了解计算机工作原理</li>
<li>并行、批判性思考</li>
</ul>
<p>最重要的是：</p>
<blockquote>
<p>Learning is for life, while exam study is until you pass.</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.webp" alt="计算机体系结构"></p>
<p>机会在底层</p>
<p>内存中的问题：</p>
<ul>
<li>row hammer</li>
<li>meltdown and spectre</li>
<li>data movement</li>
</ul>
<h2 id="权衡，指标-Tradeoffs-Metrics">权衡，指标 Tradeoffs, Metrics</h2>
<p>数据移动消耗了大量的能源，尤其是在机器学习中</p>
<p>新的计算范式（重新思考整个栈）：</p>
<ul>
<li>在内存中处理，在数据边处理</li>
<li>量子计算</li>
<li>安全与可靠计算机</li>
</ul>
<p>新的加速单元与系统（算法-硬件协同设计）：</p>
<ul>
<li>AI &amp; ML</li>
<li>图 &amp; 数据分析，视觉，视频</li>
<li>生物分析</li>
</ul>
<p>新的内存，存储系统，联系，设备：</p>
<ul>
<li>非易失性内存，智能内存系统，量子</li>
<li>高速连接，分离式系统</li>
</ul>
<p>两个课程的主要目标：</p>
<ul>
<li>批判性思考</li>
<li>广阔思考</li>
</ul>
<p>建筑</p>
<ul>
<li>总是从基本的建筑块和设计原则开始</li>
<li>如何使用、应用、增强的知识</li>
<li>潜在的技术可能会改变
<ul>
<li>但是利用技术的方法有相似之处</li>
<li>用于该设计的方法依赖于原则</li>
</ul>
</li>
</ul>
<p>一般用途和特殊用途的处理器</p>
<h2 id="组合逻辑电路-Combinational-Logic">组合逻辑电路 Combinational Logic</h2>
<p>计算机用大量的<strong>晶体管 transistors</strong> 组成</p>
<p>MOS：用导体 Conductor(<strong>M</strong>etal)，绝缘体 Insulators(<strong>O</strong>xide)，和半导体 <strong>S</strong>emiconductors 组成</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/MOS.webp" alt="MOS"></p>
<p>有两种类型的 MOS 晶体管：n 类型和 p 类型</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%99%B6%E4%BD%93%E7%AE%A1.webp" alt="两种类型的晶体管"></p>
<ul>
<li>如果 <strong>n 类型</strong>的晶体管的 gate 被施加<strong>高</strong>电压，则从 source 到 drain 的连接像导线一样。基于技术，高电压可能从 0.3V 到 3V</li>
<li>如果 <strong>n 类型</strong>的晶体管的 gate 被施加<strong>零</strong>电压，则 source 到 drain 的连接破坏了</li>
</ul>
<p>p 类型的晶体管工作和 n 类型的相反</p>
<ul>
<li><strong>p</strong> 类型：pull u<strong>p</strong></li>
<li><strong>n</strong> 类型：pull dow<strong>n</strong></li>
</ul>
<p>现代的计算机同时使用两种晶体管，即 <strong>CMOS</strong>（Complementary MOS）技术</p>
<p>最简单的门：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E9%9D%9E%E9%97%A8.webp" alt="非门"></p>
<p>更复杂一点的门：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/NAND%E9%97%A8.webp" alt="NAND门"></p>
<p>可以使用 NOT 和 NAND 门 组成 AND 门</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E4%B8%8E%E9%97%A8.webp" alt="与门"></p>
<p>注意 AND 门至少要用 6 个晶体管，而 NAND 反而只要 4 个晶体管，因为 CMOS 是反相的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CMOS%E9%97%A8%E7%BB%93%E6%9E%84.webp" alt="CMOS门结构"></p>
<ul>
<li>
<p>当晶体管<strong>并联 Parallel</strong> 时，<strong>一个</strong>晶体管 ON，整个电路 ON</p>
</li>
<li>
<p>当晶体管<strong>串联 series</strong> 时，<strong>所有</strong>晶体管 ON，整个电路 ON</p>
</li>
<li>
<p>如果两个网络都 ON，则<strong>短路</strong></p>
</li>
<li>
<p>如果两个网络都 OFF，则输出<strong>浮动 floating</strong>，无法确定</p>
</li>
</ul>
<p>MOS 晶体管是<strong>不完美</strong>的开关</p>
<ul>
<li>pMOS 擅长传递 1 而不擅长 0</li>
<li>nMOS 擅长传递 0 而不擅长 1</li>
</ul>
<p>动态功率：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>×</mo><msup><mi>V</mi><mn>2</mn></msup><mo>×</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">C × V^2 × f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></p>
<ul>
<li>C = 电路电容量</li>
<li>V = 提供的电压</li>
<li>f = 电容器改变的频率</li>
</ul>
<p>静态功率：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>×</mo><msub><mi>I</mi><mrow><mi>l</mi><mi>e</mi><mi>a</mi><mi>k</mi><mi>a</mi><mi>g</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V × I_{leakage}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>维持摩尔定律的方法：创新</p>
<ul>
<li>制造更小的晶体管/结构</li>
<li>寻找更好性质的材料</li>
<li>更精密的制造</li>
<li>新设备技术</li>
</ul>
<p><strong>组合逻辑 Combinational Logic</strong>：</p>
<ul>
<li>无记忆</li>
<li>输出严格依赖于<strong>当前</strong>输入的组合</li>
<li>输入的函数规范</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%BE%B7%E6%91%A9%E6%A0%B9%E5%BE%8B.webp" alt="德摩根律"></p>
<p>布尔代数的用途：</p>
<ul>
<li>表达组合逻辑块的函数</li>
<li>化简函数</li>
</ul>
<p>用真值表简单、通用的表达布尔函数的方法：</p>
<ul>
<li><strong>Sum of Products</strong> 形式：所有导致输出为 <strong>1</strong> 的<strong>极小项</strong>的和</li>
<li><strong>Product of Sums</strong> 形式：导致输出为 0 的<strong>极大项</strong>的积</li>
</ul>
<p><strong>解码器 Decoder</strong>：</p>
<ul>
<li>输入模式检查</li>
<li>n 输入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 输出</li>
<li>一个输出为 1，其余为 0</li>
<li>为 1 的输出对于输入匹配</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/decoder.webp" alt="decoder"></p>
<p>decoder 对于确定如何解释一个 bit 模式很有用，如内存地址、程序指令等</p>
<p><strong>选择器 Multiplexer</strong>：选择 N 个输入之一连接到输出，基于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">\log_2 N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> bit 的控制位</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/mux.webp" alt="mux"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/mux2.webp" alt="mux2"></p>
<p>选择器可以作为实现逻辑函数的查询表</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E4%BD%BF%E7%94%A8Mux%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91%E5%87%BD%E6%95%B01.webp" alt="使用Mux实现逻辑函数"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E4%BD%BF%E7%94%A8Mux%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91%E5%87%BD%E6%95%B02.webp" alt="使用Mux实现逻辑函数2"></p>
<p>decoder 可以使用或门建造逻辑函数（类似于 SOP 形式）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E4%BD%BF%E7%94%A8decoder%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91%E5%87%BD%E6%95%B0.webp" alt="使用decoder实现逻辑函数"></p>
<p>全加器：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%85%A8%E5%8A%A0%E5%99%A8.webp" alt="全加器"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E5%85%A8%E5%8A%A0%E5%99%A8.webp" alt="顺序全加器"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%A4%9A%E4%BD%8D%E5%B9%B6%E8%A1%8C%E5%85%A8%E5%8A%A0%E5%99%A8.webp" alt="多位并行全加器"></p>
<p><strong>可编程逻辑阵列 Programmable Logic Array(PLA)</strong>：</p>
<ul>
<li>AND 和 OR 门的阵列</li>
<li>使用 SOP 实现任何逻辑函数</li>
</ul>
<p>FPGA 就使用了其中的一部分技术</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/PLA.webp" alt="PLA"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AD%89%E5%80%BC%E6%A3%80%E6%9F%A5%E5%99%A8.webp" alt="等值检查器"></p>
<p>将一些算术和逻辑操作组合到一起形成 <strong>ALU</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/ALU.webp" alt="ALU"></p>
<p><strong>三态门 tri-state buffer</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E4%B8%89%E6%80%81%E9%97%A8.webp" alt="三态门"></p>
<p>类似于一个开关</p>
<p>可用于控制总线上的设备：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%80%BB%E7%BA%BF.webp" alt="总线"></p>
<p>可以使用三态门制造 Mux：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E4%B8%89%E6%80%81%E9%97%A8%E5%AE%9E%E7%8E%B0Mux.webp" alt="三态门实现Mux"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E4%B8%89%E6%80%81%E9%97%A8%E7%9A%84%E6%99%B6%E4%BD%93%E7%AE%A1%E5%AE%9E%E7%8E%B0.webp" alt="三态门的晶体管实现"></p>
<p>化简的关键工具：<strong>联合定理 Uniting theorem</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo><mi>A</mi><mover accent="true"><mi>B</mi><mo>ˉ</mo></mover><mo>+</mo><mi>A</mi><mi>B</mi><mo>=</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">F = A\bar{B} + AB = A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9034399999999999em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8201099999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>，即如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>B</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8201099999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8201099999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;"><span class="mord">ˉ</span></span></span></span></span></span></span></span></span></span> 同时出现，则可以消去</p>
<p>优先电路</p>
<ul>
<li>输入：有优先级的请求</li>
<li>输出：授予每个请求信号</li>
</ul>
<p><strong>卡诺图 Karnaugh Map</strong>：是一个化简的可视化方法，然而在实际中意义不大，因为无法处理六维或更高维度的数据</p>
<h2 id="时序逻辑设计-Sequential-Logic-Design">时序逻辑设计 Sequential Logic Design</h2>
<p>相互耦合的反相器：有两个稳定的状态：Q = 0 和 Q = 1，但是无法设置 Q</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%9B%B8%E4%BA%92%E8%80%A6%E5%90%88%E7%9A%84%E5%8F%8D%E7%9B%B8%E5%99%A8.webp" alt="相互耦合的反相器"></p>
<p>SRAM 是一种改进方式，但是两边的晶体管并不稳定</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/SRAM.webp" alt="SRAM"></p>
<p>存储元素：</p>
<ul>
<li>锁存器和触发器</li>
<li>SRAM</li>
<li>DRAM</li>
<li>闪存，硬盘，磁带</li>
</ul>
<p>速度减小，成本降低，所以有了内存层次结构</p>
<p><strong>R-S 锁存器 Reset-Set Latch</strong>：</p>
<ul>
<li>稳定状态下，S 和 R 都为 1</li>
<li>S：若 S 为 0，则设 Q 为 1</li>
<li>R：若 R 为 0，则该 Q 为 0</li>
<li>S 和 R 不能同时为 0，因为破坏了不变式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>=</mo><mo stretchy="false">!</mo><msup><mi>Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">Q = !Q^{\prime}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mclose">!</span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">Q</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">Q^{\prime}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 振荡，进入<strong>亚稳态 metastability</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/RS%E9%94%81%E5%AD%98%E5%99%A8.webp" alt="RS锁存器"></p>
<p>为了保证 R-S 锁存器的操作正确，使用<strong>门锁 D 锁存器 gated D latch</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E9%97%A8%E9%94%81D%E9%94%81%E5%AD%98%E5%99%A8.webp" alt="门锁D锁存器"></p>
<p>当 WE 为 1 时，Q 取 D 的值。S 和 R 不会同时为 0</p>
<p><strong>寄存器 register</strong>：用多个 D latch 表示多个位</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%AF%84%E5%AD%98%E5%99%A8.webp" alt="寄存器"></p>
<p><strong>内存 Memory</strong> 是地址的组合</p>
<p>对内存输出使用一个 Mux 读内存：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Mux%E8%AF%BB%E5%86%85%E5%AD%98.webp" alt="Mux读内存"></p>
<p>对输入内存使用一个 decoder 写内存：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%86%99%E5%86%85%E5%AD%98.webp" alt="写内存"></p>
<p>组合起来添加更多寄存器得到内存：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%9B%B4%E5%A4%A7%E7%9A%84%E5%86%85%E5%AD%98%E9%98%B5%E5%88%97.webp" alt="更大的内存阵列"></p>
<p>基于内存的查找表（可以用来实现逻辑函数）：</p>
<ul>
<li>每个地址：真值表中的行</li>
<li>每个数据位：相关的输出数据</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%86%85%E5%AD%98%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91%E5%87%BD%E6%95%B0.webp" alt="内存实现逻辑函数"></p>
<p><strong>查找表 Lookup Table(LUT)</strong> 广泛应用于 FPGA 中</p>
<p>我们已经设计了能够<strong>存储信息</strong>的电路，可以用其实现<strong>记忆过去</strong>的输入的电路</p>
<p>一个系统的<strong>状态 state</strong> 是那个时刻所有相关元素的快照</p>
<p>顺序锁是一个<strong>异步 asynchronous</strong> 的机器：当状态转移发生时就发生</p>
<p>现代计算机都是<strong>同步 synchronous</strong> 机器：在固定单位时间后状态转移才会发生</p>
<p>使用一个<strong>时钟 clock</strong> 决定何时改变状态，时钟信号交替 0 和 1</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%97%B6%E9%92%9F.webp" alt="时钟"></p>
<p>在一个时钟周期的<strong>开始</strong>，系统状态改变</p>
<p>同步控制更容易正确，而异步控制更高效</p>
<p><strong>有限状态机 Finite State Machine(FSM)</strong>：</p>
<ul>
<li>一个状态系统的<strong>离散时间模型</strong></li>
<li>每个状态表示系统在一个给定时间的快照</li>
</ul>
<p>FSM 图形化：</p>
<ul>
<li>一个系统所有可能的状态</li>
<li>系统如何从一个状态转移到另一个</li>
</ul>
<p>一个有限状态机有三个部分组成：</p>
<ul>
<li>下一个状态逻辑</li>
<li>状态寄存器</li>
<li>输出逻辑</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.webp" alt="有限状态机"></p>
<p>状态寄存器的两个性质：</p>
<ul>
<li>在每个时钟周期<strong>开始</strong>时存储数据</li>
<li>数据在<strong>整个</strong>时钟周期可用</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/D%E8%A7%A6%E5%8F%91%E5%99%A8.webp" alt="D触发器"></p>
<p><strong>上升沿</strong>触发的触发器</p>
<ul>
<li><strong>触发器 flip-flop</strong> 叫做<strong>边缘触发</strong>的状态元素</li>
<li>锁存器是<strong>电平触发</strong>的状态元素</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%9F%BA%E4%BA%8ED%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8.webp" alt="基于D触发器的寄存器"></p>
<p>两种有限状态机：</p>
<ul>
<li>Moore FSM：输出仅取决于当前状态</li>
<li>Mealy FSM：输出取决于当前状态和输入</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E4%B8%A4%E7%A7%8D%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.webp" alt="两种有限状态机"></p>
<p>状态编码：</p>
<ul>
<li><strong>二进制编码</strong>
<ul>
<li>使用 <em><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\log_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span></span></span></span>状态数量</em> 位表示状态</li>
<li>最小化触发器，但并不是输出逻辑或下一个状态逻辑</li>
</ul>
</li>
<li><strong>one-hot 编码</strong>
<ul>
<li>使用 <em>状态数量</em> 个位表示状态</li>
<li>最小化下一个状态逻辑，但最大化触发器</li>
<li>最简单的设计过程</li>
</ul>
</li>
<li><strong>输出编码</strong>
<ul>
<li>输出<strong>直接</strong>在状态编码</li>
<li>最小化输出逻辑</li>
<li>只适用于 Moore 机器</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AF%86%E5%88%AB1101%E5%BA%8F%E5%88%97%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%9B%BE.webp" alt="识别1101序列的状态转移图"></p>
<p>FSM 设计过程：</p>
<ul>
<li>决定所有可能的状态</li>
<li>设计状态转移图
<ul>
<li>决定每个状态的输入和输出，还有转移</li>
</ul>
</li>
<li>方法
<ul>
<li>从 reset 状态开始</li>
<li>添加转移和状态</li>
<li>选择合适的状态名</li>
<li>建造一个 FSM 就<strong>像</strong>编程，但不是编程
<ul>
<li>FSM 像有条件和 goto 的程序的顺序控制流</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在硬件上，一般有很多并发的 FSM</p>
<h2 id="硬件描述语言和-Verilog-Hardware-Desccription-Languages-and-Verilog">硬件描述语言和 Verilog Hardware Desccription Languages and Verilog</h2>
<p>硬件描述语言：</p>
<ul>
<li>用于<strong>描述</strong>硬件</li>
<li>可以<strong>描述</strong>复杂的设计</li>
<li>可以<strong>模拟</strong>行为</li>
<li>可以<strong>合成</strong>部分硬件</li>
</ul>
<p>两大最有名的 HDL：Verilog 和 VHDL</p>
<p>HDL 让描述硬件更轻松，无缝表达硬件的内在并行</p>
<p>设计模块的层次结构：</p>
<ul>
<li>预先定义的原始门</li>
<li>由这些门构建简单模块</li>
<li>由简单模块构建复杂模块</li>
</ul>
<p>层次结构控制了复杂性</p>
<p>自顶向下设计方法和自底向上的设计方法，通常两者都会使用</p>
<p><strong>模块 module</strong> 是 Verilog 中的主要组成，需要定义</p>
<ul>
<li>模块的名字</li>
<li>端口方向</li>
</ul>
<p>然后描述模块的功能</p>
<p>有两种风格：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> test(a, b, y);<br>    <span class="hljs-keyword">input</span> a;<br>    <span class="hljs-keyword">input</span> b;<br>    <span class="hljs-keyword">output</span> y;<br><span class="hljs-keyword">endmodule</span><br><span class="hljs-comment">// 或</span><br><span class="hljs-keyword">module</span> test(<span class="hljs-keyword">input</span> a, <span class="hljs-keyword">input</span> b, <span class="hljs-keyword">output</span> y);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>
<p>对于多 bit 的输入/输出，可以使用 [结束访问:开始范围]，如 <code>input [31:0]a;</code> 表示 <code>a[31],a[30]..a[0]</code>，顺序可以交换，但是必须一致</p>
<p>操作位：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// 切片</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] longbus;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] shortbus;<br><span class="hljs-keyword">assign</span> shortbus = longbus[<span class="hljs-number">12</span>:<span class="hljs-number">5</span>];<br><br><span class="hljs-comment">// 连接</span><br><span class="hljs-keyword">assign</span> y = &#123;a[<span class="hljs-number">2</span>], a[<span class="hljs-number">1</span>]&#125;;<br><br><span class="hljs-comment">// 可以定义重复</span><br><span class="hljs-keyword">assign</span> x = &#123;<span class="hljs-number">4</span>&#123;a[<span class="hljs-number">0</span>]&#125;&#125;;<br></code></pre></td></tr></table></figure>
<p>HDL 实现的两个主要风格：</p>
<ul>
<li><strong>结构化</strong>：
<ul>
<li>侧重于描述<strong>门级别</strong>的电路</li>
<li>用门描述模块层次结构</li>
</ul>
</li>
<li><strong>表现化</strong>：
<ul>
<li>侧重于电路的<strong>函数描述</strong></li>
<li>包括逻辑和数学运算符</li>
<li>比门级别更高层次抽象</li>
<li>一个表现描述可能有多种门层次的实现方式</li>
</ul>
</li>
</ul>
<p>使用模块 <code>small(A,B,Y)</code> 的两种方法：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// 要求顺序匹配</span><br><span class="hljs-keyword">small</span> i_first(A, SEL, n1);<br><span class="hljs-comment">// 或</span><br><span class="hljs-keyword">small</span> i_second (<span class="hljs-variable">.B</span>(C), <span class="hljs-variable">.Y</span>(Y), <span class="hljs-variable">.A</span>(n1));<br></code></pre></td></tr></table></figure>
<p>结构化例子：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mux2(<span class="hljs-keyword">input</span> d0, <span class="hljs-keyword">input</span> d1, <span class="hljs-keyword">output</span> y);<br>    <span class="hljs-keyword">and</span> g1 (d0, d1, y);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>
<p>也就是和模块实例化一样，但是不需要定义</p>
<p>表现化：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> example(a, b, y);<br>    <span class="hljs-keyword">input</span> a;<br>    <span class="hljs-keyword">input</span> b;<br>    <span class="hljs-keyword">assign</span> y = a &amp; b;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>
<p>可以按位操作，如</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> and4(<span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] a, <span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] b, <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] y);<br>    <span class="hljs-keyword">assign</span> y = a &amp; b;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>
<p>约简操作：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> and8(<span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] a, <span class="hljs-keyword">output</span> y);<br>    <span class="hljs-keyword">assign</span> y = &amp;a;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>
<p>条件赋值：<code>assign y = s ? d1 : d0;</code></p>
<p>数的表示：N'Bxx</p>
<ul>
<li>N：bit 的数量</li>
<li>B：基，可以是 b, h, d, o</li>
<li>xx：数字
<ul>
<li>用基表示的值</li>
<li>也可以是 X（无效）和 Z（浮动）</li>
<li><code>_</code> 有利于提高可读性</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%9C%89Z%E5%92%8CX%E7%9A%84AND%E9%97%A8%E7%9C%9F%E5%80%BC%E8%A1%A8.webp" alt="有Z和X的AND门真值表"></p>
<p>合成：</p>
<ul>
<li>将合成的 HDL 代码映射到低层次 cell 库中</li>
<li>可以实现许多优化</li>
<li>但是并不能保证是最优的，因为需要计算量太大</li>
</ul>
<p>模拟</p>
<p>模块可以有参数</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mux2 #(<span class="hljs-keyword">parameter</span> width = <span class="hljs-number">8</span>) (<span class="hljs-keyword">input</span> [width-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>]d0, d1, <span class="hljs-keyword">output</span>[width-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] y);<br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-comment">// 使用</span><br>mux2 i_mux(d0, d1, out);<br><span class="hljs-comment">// 12 bit</span><br>mux $(<span class="hljs-number">12</span>) i_mux_b(d0, d1, out);<br></code></pre></td></tr></table></figure>
<p>时间</p>
<ul>
<li><strong>只可</strong>模拟</li>
<li><strong>不可</strong>合成</li>
<li>用于电路的建模延迟</li>
</ul>
<h2 id="时间和验证-Timing-and-Verification">时间和验证 Timing and Verification</h2>
<p>时序 = 组合 + 内存</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84.webp" alt="时序逻辑结构"></p>
<p><code>always</code> 块：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @ (sensitivity list)<br>    statement;<br></code></pre></td></tr></table></figure>
<p>当 <code>sensitivity list</code> 中的事件发生，语句执行</p>
<p>例如 flip-flop：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> flop(<span class="hljs-keyword">input</span> clk, <span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] d, <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] q);<br><span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> clk)<br>    q &lt;= d;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>
<ul>
<li>赋值的变量被声明为 <code>reg</code>，但并不意味着这个值是一个寄存器</li>
<li><code>always</code> 块中不能有 <code>assign</code></li>
</ul>
<p>一个<strong>异步</strong> reset 的 flip-flop：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> clk, <span class="hljs-keyword">negedge</span> reset)<br>    <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (reset == <span class="hljs-number">0</span>) q &lt;= <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> q &lt;= d;<br>    <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>对于更长的雨具，<code>begin-end</code> 对可以提高可读性</p>
<p>一个<strong>同步</strong> reset 的 flip-flop：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> clk)<br>    <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (reset == &#x27;<span class="hljs-number">0</span>&#x27;) q &lt;= <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> q &lt;= d;<br>    <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>可能有多个 <code>always</code> 块，但是不能在不同的 <code>always</code> 块中给相同的信号赋值</p>
<p><code>always</code> 块可以用于定义组合逻辑，如果：</p>
<ul>
<li>所有的输出都总是更新</li>
<li>右边的信号都在感知列表中，如 <code>always @ *</code></li>
<li>左边的信号在每个可能的情况下都赋值</li>
</ul>
<p><code>case</code> 语句</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @ (*)<br>    <span class="hljs-keyword">case</span> (data)<br>        <span class="hljs-number">4&#x27;d0</span>: segments = <span class="hljs-number">7&#x27;b111_1110</span>;<br>        <span class="hljs-number">4&#x27;d1</span>: segments = <span class="hljs-number">7&#x27;b111_1010</span>;<br>        <span class="hljs-number">4&#x27;d2</span>: segments = <span class="hljs-number">7&#x27;b111_1000</span>;<br>        <span class="hljs-keyword">default</span>: segments = <span class="hljs-number">7&#x27;b000_0000</span>; <span class="hljs-comment">// 为了避免遗忘某些情况，一定要有 default</span><br>    <span class="hljs-keyword">endcase</span><br></code></pre></td></tr></table></figure>
<p>注意 <code>if...else</code> <strong>只能</strong>用于 <code>always</code> 块中</p>
<ul>
<li>非阻塞式 <code>&lt;=</code>：并行赋值</li>
<li>阻塞式 <code>=</code>：知道前面的赋值完成才开始进程</li>
</ul>
<p><code>parameter</code> 相当于常量，可以用于提高可读性，如 <code>parameter s0 = 2'b00;</code></p>
<p>事实上输出相对于输入有延迟，因为晶体管开关需要时间</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%BB%84%E5%90%88%E7%94%B5%E8%B7%AF%E5%BB%B6%E8%BF%9F.webp" alt="组合电路延迟"></p>
<p>延迟的造成原因：</p>
<ul>
<li>电路的容抗和阻抗</li>
<li>光速有限</li>
</ul>
<p><strong>污染延迟 contamination delay</strong>：Y <strong>开始</strong>改变之前的延迟</p>
<p><strong>传播延迟 propagation delay</strong>：Y <strong>完成</strong>改变的延迟</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%B1%A1%E6%9F%93%E5%BB%B6%E8%BF%9F%E5%92%8C%E4%BC%A0%E6%92%AD%E5%BB%B6%E8%BF%9F.webp" alt="污染延迟和传播延迟"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%85%B3%E9%94%AE%E8%B7%AF%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF.webp" alt="关键路与最短路"></p>
<p><strong>最长（关键 critical）路</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>p</mi><mi>d</mi></mrow></msub><mo>=</mo><mn>2</mn><msub><mi>t</mi><mrow><mi>p</mi><mi>d</mi><mi mathvariant="normal">_</mi><mi>A</mi><mi>N</mi><mi>D</mi></mrow></msub><mo>+</mo><msub><mi>t</mi><mrow><mi>p</mi><mi>d</mi><mi mathvariant="normal">_</mi><mi>O</mi><mi>R</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{pd} = 2 t_{pd\_AND} + t_{pd\_OR}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.01144em;vertical-align:-0.367em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">d</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.98208em;vertical-align:-0.367em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">d</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>最短路：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>c</mi><mi>d</mi></mrow></msub><mo>=</mo><msub><mi>t</mi><mrow><mi>c</mi><mi>d</mi><mi mathvariant="normal">_</mi><mi>A</mi><mi>N</mi><mi>D</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{cd} = t_{cd\_AND}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.98208em;vertical-align:-0.367em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">d</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span></span></span></span></p>
<p><strong>脉冲 glitch</strong>：一个输入转移造成多重输出转移</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%84%89%E5%86%B2.webp" alt="脉冲"></p>
<p>脉冲在卡诺图中可见，当主要隐含数之间移动时，脉冲出现：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%84%89%E5%86%B22.webp" alt="脉冲2"></p>
<p>只需要将其连起来即可</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%84%89%E5%86%B23.webp" alt="脉冲3"></p>
<p>D flip flop 输入时间约束</p>
<p>当<strong>采样 sample</strong> 时，D 必须是<strong>稳定</strong>的</p>
<ul>
<li><strong>设置时间 setup time</strong>：在时钟边缘到来之<strong>前</strong>数据必须稳定的时间</li>
<li><strong>保持时间 hold time</strong>：在时钟边沿之<strong>后</strong>数据必须保持稳定的时间</li>
<li><strong>孔径时间 aperture time</strong>：时钟边沿<strong>周围</strong>数据必须保持的时间，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>a</mi></msub><mo>=</mo><msub><mi>t</mi><mrow><mi>s</mi><mi>e</mi><mi>t</mi><mi>u</mi><mi>p</mi></mrow></msub><mo>+</mo><msub><mi>t</mi><mrow><mi>h</mi><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_a = t_{setup} + t_{hold}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.28055599999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/D%20flip%20flop%20%E8%BE%93%E5%85%A5%E6%97%B6%E9%97%B4%E7%BA%A6%E6%9D%9F.webp" alt="D flip flop 输入时间约束"></p>
<p>D flip flop 输出时间约束</p>
<ul>
<li><strong>到 q 的污染延迟 contamination delay clock-to-q</strong>(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>c</mi><mi>c</mi><mi>q</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{ccq}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>)：在时钟边沿后 Q <strong>开始</strong>改变的最短时间</li>
<li><strong>到 q 的传播延迟</strong>(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>p</mi><mi>c</mi><mi>q</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{pcq}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>)：在时钟边沿后 Q <strong>停止</strong>改变的最短时间</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/filp-flop%E8%BE%93%E5%87%BA%E6%97%B6%E9%97%B4.webp" alt="filp-flop输出时间"></p>
<p>对于时序电路，D2 必须稳定，即</p>
<ul>
<li>至少在时钟边沿到来前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>s</mi><mi>e</mi><mi>t</mi><mi>u</mi><mi>p</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{setup}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.28055599999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>至少在时钟边沿到来后 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>h</mi><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{hold}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
<p>故两个触发器之间有<strong>最大</strong>和<strong>最小</strong>延迟</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>c</mi></msub><mo>&gt;</mo><msub><mi>t</mi><mrow><mi>p</mi><mi>c</mi><mi>q</mi></mrow></msub><mo>+</mo><msub><mi>t</mi><mrow><mi>p</mi><mi>d</mi></mrow></msub><mo>+</mo><msub><mi>t</mi><mrow><mi>s</mi><mi>e</mi><mi>t</mi><mi>u</mi><mi>p</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T_c &gt; t_{pcq} + t_{pd} + t_{setup}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.28055599999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>p</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{pd}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 是有效工作，由关键路延迟决定，其余部分为<strong>时序开销 sequencing overhead</strong></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>c</mi><mi>d</mi></mrow></msub><mo>&gt;</mo><msub><mi>t</mi><mrow><mi>h</mi><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub><mo>−</mo><msub><mi>t</mi><mrow><mi>c</mi><mi>c</mi><mi>q</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{cd} &gt; t_{hold} - t_{ccq}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，注意与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">T_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 即时钟周期无关</li>
</ul>
<p>时钟也有延迟，不同时钟边沿的时间差为<strong>时钟歪斜 clock skew</strong>，若考虑这一延迟，则原等式的两边都要加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>s</mi><mi>k</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{skew}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>Testbench：一个用于测试的模块，被测试的模块叫<strong>待测设备 device under test(DUT)</strong></p>
<ul>
<li>其提供输入，有人工的，也有自动生成（顺序或随机数）</li>
<li>将 DUT 的结果和人工值或黄金设计相比较</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> testbench2();<br>    <span class="hljs-keyword">reg</span> a;<br>    sillyfunction dut(<span class="hljs-variable">.a</span>(a), <span class="hljs-variable">.b</span>(b), <span class="hljs-variable">.c</span>(c), <span class="hljs-variable">.y</span>(y));<br><br>    <span class="hljs-keyword">initial</span> <span class="hljs-comment">// 类似 always 块，但是只在一开始运行一次</span><br>        <span class="hljs-keyword">begin</span><br>            a = <span class="hljs-number">0</span>; b = <span class="hljs-number">0</span>; c = <span class="hljs-number">0</span>;<br>            #<span class="hljs-number">10</span>;    <span class="hljs-comment">// 等待 10 ns</span><br>            <span class="hljs-keyword">if</span> (y != <span class="hljs-number">1</span>) <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;000 failed.&quot;</span>);    <span class="hljs-comment">// 打印信息</span><br>        <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>
<p>好的设计原则：</p>
<ul>
<li>关键路径设计：最小化最大逻辑延迟</li>
<li>平衡设计：平衡系统中不同部分的最大逻辑延迟，即不出现瓶颈</li>
<li>面包黄油设计：优化一般情况，但也要考虑到非一般情况</li>
</ul>
<h2 id="冯诺依曼结构-Von-Neumann-Model">冯诺依曼结构 Von Neumann Model</h2>
<p>为了用计算机完成一个任务，需要</p>
<ul>
<li>计算机程序</li>
<li>计算机</li>
</ul>
<p>程序：指令集</p>
<ul>
<li>指令：程序中最小工作单元</li>
</ul>
<p>指令集：计算机被用于设计执行的指令的集合</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84.webp" alt="冯诺依曼结构"></p>
<p>两种内存：</p>
<ul>
<li>字长地址的内存：每个字长数据有一个独特的地址</li>
<li>字节地址的内存：每个字节数据有一个独特的地址</li>
</ul>
<p>读内存：</p>
<ol>
<li>将希望读的地址装载到 MAR（内存地址寄存器）中</li>
<li>将相关位置的数据放到 MDR（内存数据寄存器）中</li>
</ol>
<p>写内存：</p>
<ol>
<li>将希望读的地址装载到 MAR 中，将需要写入的数据装载到 MDR 中</li>
<li>激活写使能信号</li>
</ol>
<p>处理单元：由很多功能单元组成，如 ALU</p>
<p>为了更快的存储，临时数据存在寄存器中</p>
<p>控制单元：一步一步执行程序</p>
<ul>
<li>指令寄存器</li>
<li>PC</li>
</ul>
<p>冯诺依曼结构两个关键的性质：</p>
<ul>
<li>存储程序
<ul>
<li>指令在线性内存阵列中存储</li>
<li>内存对指令和数据一视同仁，所以对储存值的解释依赖于控制信号</li>
</ul>
</li>
<li>顺序指令处理
<ul>
<li>一个处理一个指令</li>
<li>PC 识别当前指令</li>
<li>PC 顺序向前，除了控制转移指令</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/LC-3%E6%9C%BA%E5%99%A8.webp" alt="LC-3机器"></p>
<h2 id="指令集架构-Instruction-Set-Architectures">指令集架构 Instruction Set Architectures</h2>
<p>计算机语言可以写作：</p>
<ul>
<li>机器语言：0 和 1</li>
<li>汇编语言：人类可读</li>
</ul>
<p>指令由两部分组成：<strong>指令编码 opcode</strong> 和<strong>操作数 oprand</strong></p>
<p>指令循环：</p>
<ul>
<li>取指令</li>
<li>解码指令</li>
<li>计算地址</li>
<li>获取操作数</li>
<li>执行</li>
<li>存储结果</li>
</ul>
<p>然后返回循环，注意不是所有的指令都有这六个阶段</p>
<p>ISA 是<strong>软件</strong>命令和<strong>硬件</strong>执行的<strong>接口</strong>，其规定了</p>
<ul>
<li>内存组织</li>
<li>寄存器集</li>
<li>指令集</li>
</ul>
<p>指令集的复杂和简单中是权衡：</p>
<ul>
<li>硬件复杂度 vs 软件复杂度</li>
<li>简单 vs 复杂指令的延迟</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AF%AD%E6%B3%95%E6%B2%9F.webp" alt="语法沟"></p>
<p>有四种寻址方式：</p>
<ul>
<li>PC-相关：Memory[PC + sign-extend(PC offset 9)]</li>
<li>间接访问：Memory[Memory[PC + sign-extend(PC offset 9)]]</li>
<li>集 + 偏移：Memory[$s0 + 8]</li>
<li>立即数寻址：LEA(Load Effective Address)：PC + sign-extend(PC offset 9)</li>
</ul>
<p>计算机基本方法：如果有什么是解决不了的，那就在中间加一层：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AF%AD%E6%B3%95%E6%B2%9F2.webp" alt="语法沟2"></p>
<p><strong>数据流模型 Dataflow Model</strong>：指令以<strong>数据流顺序</strong>执行，即不是 PC，而是生产者-消费者模型</p>
<p>通常使用图表示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E6%B5%81.webp" alt="顺序和数据流"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%BB%93%E7%82%B9.webp" alt="数据流结点"></p>
<p>这种架构提取出了并行</p>
<h2 id="微架构-Microarchitecture">微架构 Microarchitecture</h2>
<p>ISA：规定程序员看到这些指令怎样被执行</p>
<p>微架构：执行指令的潜在实现</p>
<p>计算机体系结构定义：ISA + 实现</p>
<p>处理指令：根据 ISA 规范把状态从 AS 转化为 AS'</p>
<ul>
<li>类似于一个抽象有限状态机</li>
<li>从 ISA 视角，每条指令一个状态转移</li>
<li>从微架构视角，每条指令可以有多重状态转移</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%8D%95%E5%91%A8%E6%9C%9F%E6%9C%BA%E5%99%A8.webp" alt="单周期机器"></p>
<p>单周期机器：</p>
<ul>
<li>每条指令一个时钟周期</li>
<li>所有状态在指令执行结束时更新</li>
<li>缺点：可以发现时钟周期时间由关键路决定</li>
</ul>
<p>多周期机器：</p>
<ul>
<li>每条指令被分成多个周期/阶段</li>
<li>在指令执行期间更新状态</li>
<li>在指令执行结束时更新架构状态</li>
<li>相对优点：最慢的阶段决定周期时间</li>
</ul>
<p>指令处理机制由两部分组成：</p>
<ul>
<li>数据路径：有处理和转移数据信号的硬件组成
<ul>
<li>函数单元</li>
<li>硬件结构</li>
<li>存储单元</li>
</ul>
</li>
<li>控制逻辑：决定控制信号，即指定进入数据的数据路径中的元素</li>
</ul>
<p>效率分析：</p>
<ul>
<li>每条指令的执行时间：CPI * 时钟周期时间</li>
<li>整个程序的执行时间：（CPI * 时钟周期时间）的总和 = 指令数 * 评价 CPI * 时钟周期时间</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/MIPS%E7%9A%84%E7%8A%B6%E6%80%81%E5%85%83%E7%B4%A0.webp" alt="MIPS的状态元素"></p>
<p>假设：</p>
<ul>
<li>组合读</li>
<li>同步写</li>
<li>单周期，同步内存</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/R%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E8%B7%AF%E5%BE%84.webp" alt="R类型数据路径"></p>
<p>I 类型的寄存器编码位置不同，还有要选择是使用寄存器还是立即数，故添加两个 Mux</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/I%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E8%B7%AF%E5%BE%84.webp" alt="I类型数据路径"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/LD%E6%95%B0%E6%8D%AE%E8%B7%AF%E5%BE%84.webp" alt="LD数据路径"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/SW%E6%95%B0%E6%8D%AE%E8%B7%AF%E5%BE%84.webp" alt="SW数据路径"></p>
<p>和之前的组合起来，得到完整的数据路径</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E8%B7%AF%E5%BE%84.webp" alt="读写数据路径"></p>
<p>注意 PC 相关跳转中的 PC 是这条指令的下一个，所以要先 PC + 4</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E6%95%B0%E6%8D%AE%E8%B7%AF%E5%BE%84.webp" alt="无条件跳转数据路径"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E6%95%B0%E6%8D%AE%E8%B7%AF%E5%BE%84.webp" alt="条件跳转数据路径"></p>
<p>把所有的放在一起，并加入控制信号：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%8D%95%E5%91%A8%E6%9C%9F%E6%9C%BA%E5%99%A82.webp" alt="单周期机器2"></p>
<table>
<thead>
<tr>
<th>控制信号</th>
<th>为 0 的情况</th>
<th>为 1 的情况</th>
<th>等式</th>
</tr>
</thead>
<tbody>
<tr>
<td>RegDest</td>
<td>选择 inst[20:16]</td>
<td>选择 inst[15:11]</td>
<td>opcode == 0</td>
</tr>
<tr>
<td>ALUSrc</td>
<td>第二个寄存器</td>
<td>立即数</td>
<td>opcode != 0 &amp;&amp; opcode != BEQ &amp;&amp; opcode != BNE</td>
</tr>
<tr>
<td>MemtoReg</td>
<td>存储 ALU 结果</td>
<td>储存内存输出</td>
<td>opcode == LW</td>
</tr>
<tr>
<td>RegWrite</td>
<td>禁止写寄存器</td>
<td>允许写寄存器</td>
<td>opcode != SW &amp;&amp; opcode != Bxx &amp;&amp; opcode != J &amp;&amp; opcode != JR</td>
</tr>
<tr>
<td>MemRead</td>
<td>禁止读内存</td>
<td>允许读内存</td>
<td>opcode == LW</td>
</tr>
<tr>
<td>Memwrite</td>
<td>禁止写内存</td>
<td>允许写内存</td>
<td>opcode == SW</td>
</tr>
<tr>
<td>PCSrc_1</td>
<td>根据 PCSrc_2</td>
<td>26 位立即数跳转</td>
<td>opcode == J || opcode == JAL</td>
</tr>
<tr>
<td>PCSrc_2</td>
<td>PC = PC + 4</td>
<td>16 位立即数跳转</td>
<td>opcode == Bxx &amp;&amp; 条件满足</td>
</tr>
</tbody>
</table>
<p>控制盒子：</p>
<ul>
<li>组合逻辑：根据指令解码</li>
<li>时序逻辑：将控制信号与指令关联起来的内存结构</li>
</ul>
<h2 id="多周期微架构设计-Multi-Cycle-Microarchitecture-Design">多周期微架构设计 Multi-Cycle Microarchitecture Design</h2>
<p>多周期设计的缺点：需要在每个时钟周期结束都储存当前结果</p>
<ul>
<li>硬件寄存器开销大</li>
<li>寄存器设置和保持的开销</li>
</ul>
<p>实现的思想：有限状态机</p>
<ul>
<li>状态由控制信号确定</li>
<li>下一个状态的控制信号在当前状态确定</li>
</ul>
<p>除了运行效率外，多周期微架构还有节省硬件资源的优势</p>
<ul>
<li>注意到单周期微架构使用了两个内存和三个加法器</li>
<li>多周期微架构可以在不同周期复用这些资源</li>
</ul>
<p>直接根据指令执行过程划分阶段：对于 lw 指令，有</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%8C%87%E4%BB%A4%E8%8E%B7%E5%8F%96.webp" alt="指令获取"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AF%BB%E5%AF%84%E5%AD%98%E5%99%A8.webp" alt="读寄存器"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/lw%E5%9C%B0%E5%9D%80.webp" alt="lw地址"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AF%BB%E5%86%85%E5%AD%98.webp" alt="读内存"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8.webp" alt="写寄存器"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%A2%9E%E5%8A%A0PC.webp" alt="增加PC"></p>
<p>其余指令同理</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%A4%9A%E5%91%A8%E6%9C%9F%E5%A4%84%E7%90%86%E5%99%A8.webp" alt="多周期处理器"></p>
<p>接下来是控制单元：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83.webp" alt="控制单元"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA.webp" alt="控制单元的状态机"></p>
<p>但这种设计的缺陷假定了内存访问 &lt; 一个周期，所以需要设计<strong>内存准备</strong>位</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/LC-3b%E7%8A%B6%E6%80%81%E6%9C%BA.webp" alt="LC-3b状态机"></p>
<p>微编程控制术语：</p>
<ul>
<li>微指令：和当前状态相关的控制信号</li>
<li>微顺序：从一个状态转移到另一个的动作</li>
<li>控制存储：存储每个可能的控制信号</li>
<li>微顺序器：决定哪个控制信号会被用于下一个时钟周期</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%BE%AE%E7%BC%96%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.webp" alt="微编程控制结构"></p>
<h2 id="流水线-Pipelining">流水线 Pipelining</h2>
<p>观察之前的多周期设计，可以发现在指令执行的不同阶段有一些硬件资源闲着，所以可以增加并发性</p>
<p>流水线核心思想：</p>
<ul>
<li>把指令执行周期分成不同的处理阶段</li>
<li>每个阶段处理不同的指令</li>
</ul>
<p>理想流水线：</p>
<ul>
<li>相同的操作重复</li>
<li>独立的操作重复</li>
<li>均匀划分的子操作</li>
</ul>
<p>可惜我们的设计决不是理想的流水线</p>
<p>吞吐量增大，但增加了寄存器，成本增加</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%AF%84%E5%AD%98%E5%99%A8.webp" alt="流水线寄存器"></p>
<p>每经过一个阶段一些不用的信号可以丢弃了，即后面的寄存器会越来越小，可以节省成本</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7.webp" alt="流水线控制信号"></p>
<p>资源竞争：两个流水线阶段需要相同的资源</p>
<p>解决方案：</p>
<ul>
<li>减少竞争造成原因</li>
<li>检查资源竞争并暂缓其中一个竞争的阶段</li>
</ul>
<p>数据依赖：</p>
<p>类型：</p>
<ul>
<li>流依赖（真实的数据依赖——写后读）</li>
<li>反依赖（读后写）</li>
<li>输出依赖（写后写）</li>
</ul>
<p>三者都会导致流水线的暂缓，但是后两者是因为寄存器的数量有限导致的，也就是依赖于一个<strong>名字</strong>，而不是<strong>值</strong></p>
<p>流依赖的六种处理方法：</p>
<ul>
<li>检测并等待直到寄存器文件中的值可用</li>
<li>检测并旁路数据至独立的指令</li>
<li>检测并在软件层次减少依赖</li>
<li>检测并把它移出，给独立指令让路</li>
<li>预测需要的值，并确认</li>
<li>做其他事（细粒度的多线程）</li>
</ul>
<p><strong>互锁 interlock</strong>：流水线处理器的指令之间检查依赖以保证正确执行</p>
<p>方法：</p>
<ul>
<li>计分板：每个寄存器文件中都有一个有效位</li>
<li>组合依赖检查：检查指令在后面是否需要写</li>
</ul>
<h2 id="流水线处理器设计-Pipelined-Processor-Design">流水线处理器设计 Pipelined Processor Design</h2>
<p>造成流水线暂停的原因：</p>
<ul>
<li>资源竞争</li>
<li>依赖</li>
<li>长延迟（多周期）的操作</li>
</ul>
<p>暂停实现方法：</p>
<ul>
<li>关闭 PC 和 IF/ID 锁</li>
<li>在暂停的指令后插入无效指令（bubbles）</li>
</ul>
<p><strong>数据转发 data forwarding</strong>：也叫 <strong>data bypassing</strong>，即在数据可用时就将结果值转发给依赖的指令，在写回之前</p>
<p>从内存阶段而后写回阶段转发到执行阶段，如果两者都匹配目标寄存器，则优先转发内存阶段数据，因为其更新</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91.webp" alt="数据转发"></p>
<p>但是，例如 lw 指令，其最后一个阶段才会获取数据，数据转发无效</p>
<p>暂停所需的硬件：</p>
<ul>
<li>获取和解码的使能</li>
<li>执行寄存器的 CLR 或每个寄存器的有效位</li>
</ul>
<p>当 lw 暂停发生</p>
<ul>
<li>保持解码和获取阶段的寄存器的值</li>
<li>清楚执行阶段寄存器的内容，插入 bubble</li>
</ul>
<p>分支预测：特殊的数据依赖——依赖 PC</p>
<p>在分支被解决之前，分支后的指令已经被获取了</p>
<p>简单的策略：总是循序执行（总是不选择），如果分支要执行，则清空未选择路径的指令</p>
<p>分支误测的惩罚：清空的指令数</p>
<p>减少的方法：早期分支解决：在更靠前的阶段测试分支</p>
<p>基于软件的指令调度——静态调度，硬件以编译器指定的顺序执行指令，问题在于编译器不知道运行时确定的值</p>
<p><strong>细粒度多线程 Fine-grained multithreading</strong>：每个周期从一个不同的线程中获取指令，使得同时在流水线中没有两个从同以一线程中的指令</p>
<ul>
<li>硬件有多线程上下文（PC+寄存器）</li>
<li>线程完全独立</li>
<li>直到之前的指令结束，没有指令从同一线程中获取</li>
</ul>
<p>优点：</p>
<ul>
<li>多线程吞吐量增加</li>
<li>一个线程中不需要处理控制和数据依赖的逻辑</li>
</ul>
<p>缺点：</p>
<ul>
<li>单线程效率低</li>
<li>保存线程上下文的额外逻辑</li>
<li>如果线程数量不够，则吞吐量降低</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%BB%86%E7%B2%92%E5%BA%A6%E5%A4%9A%E7%BA%BF%E7%A8%8B.webp" alt="细粒度多线程"></p>
<p>现代 GPU 常用这个方法，即超多线程和超多寄存器</p>
<h2 id="精确异常-Precise-Exceptions">精确异常 Precise Exceptions</h2>
<p>即保持顺序的语义</p>
<p>因为在执行阶段，不同的指令所需时间不同，所以可以在之前的长延迟的指令执行结束前，让独立的指令在不同的函数单元执行</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%A4%9A%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E5%BC%82%E5%B8%B8.webp" alt="多周期执行异常"></p>
<p>若第一个指令出现异常，但后面的指令已经执行完了，故无法确定这个异常是谁引起的</p>
<p>程序执行过程中为计划的改变或中断</p>
<ul>
<li><strong>内部</strong>问题：<strong>异常 exception</strong></li>
<li><strong>外部</strong>事件：<strong>中断 interrupt</strong></li>
</ul>
<p>处理时间：</p>
<ul>
<li>异常：当检测到</li>
<li>中断：当方便时，除了一些高优先级的，如没电了、机器故障等</li>
</ul>
<p>当异常/中断准备好处理时，架构状态应该一致（精确）</p>
<ul>
<li>所有之前的指令都必须完全<strong>退休 retired</strong></li>
<li>之后的指令都没有退休</li>
</ul>
<p>当最老的即将退休的指令被检测到造成异常时，控制逻辑</p>
<ul>
<li>确保架构状态精确（寄存器文件，PC，内存）</li>
<li>清楚流水线中所有年轻的指令</li>
<li>保存 PC 和寄存器</li>
<li>重定向到合适的异常处理过程</li>
</ul>
<p>精确异常的优点：</p>
<ul>
<li>便于调试程序</li>
<li>容易从异常恢复</li>
<li>容易重启过程</li>
<li>进入软件</li>
</ul>
<p>单周期不需要，多周期需要</p>
<ul>
<li>在控制 FSM 添加特殊的指向异常处理器的状态</li>
<li>只在精确状态时切换到处理器</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%B2%BE%E7%A1%AE%E5%BC%82%E5%B8%B8%E6%95%B0%E6%8D%AE%E8%B7%AF%E5%BE%84.webp" alt="精确异常数据路径"></p>
<ul>
<li>EPC 寄存器：保留造成异常的 PC</li>
<li>Cause 寄存器：保持造成异常的原因</li>
<li>异常处理器：在地址 0x80000180 开始</li>
</ul>
<p>支持精确异常的方法：</p>
<ul>
<li>重排序缓冲区</li>
<li>历史缓冲区</li>
<li>未来寄存器文件</li>
<li>检查点</li>
</ul>
<p><strong>重排序缓冲区 Reorder Buffer(ROB)</strong>：乱序完成指令，但是在使结果对架构状态可见之前重排序</p>
<ul>
<li>当指令<strong>解码</strong>时，把下一个顺序项保留在一个特殊的叫重排序缓冲区（ROB）的缓冲区中</li>
<li>当指令<strong>完成</strong>时，把结果写回道 ROB 项中</li>
<li>当 ROB 中最老的指令无异常完成时，结果写回到寄存器文件或内存中</li>
</ul>
<p>ROB 以硬件的队列实现：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/ROB.webp" alt="ROB"></p>
<p>ROB：保持所有被<strong>解码</strong>但没有<strong>退休</strong>的指令的硬件结构</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/ROB2.webp" alt="ROB2"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/ROB%E9%A1%B9.webp" alt="ROB项"></p>
<p>有效位用于跟踪结果的可读性，找出指令是否完成执行</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/ROB3.webp" alt="ROB3"></p>
<p>我们可以使用内容可寻址的方法访问 ROB，即查找最新的寄存器：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/ROB%E8%AE%BF%E9%97%AE1.webp" alt="ROB访问1"></p>
<p>还可以使用间接访问，即将寄存器映射到一个 ROB 项</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/ROB%E8%AE%BF%E9%97%AE2.webp" alt="ROB访问2"></p>
<p>可以发现，两种假的依赖已经被消除了，增加了寄存器名字空间到 ROB 大小</p>
<p>ROB 的缺点：需要访问 ROB 以得到还没有写入寄存器文件的值，延迟和复杂度都上升了</p>
<h2 id="乱序执行-Out-of-Order-Execution">乱序执行 Out-of-Order Execution</h2>
<p>也称动态指令调度</p>
<p><strong>分发 dispatch</strong>：把指令发送到函数单元的动作</p>
<p>注意到顺序流水线的问题是一个未准备好的指令阻塞了更年轻的指令分发到函数单元</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E9%98%BB%E5%A1%9E%E5%8F%91%E9%80%81.webp" alt="阻塞发送"></p>
<p>上图的第二条指令在等待第一条指令完成，但是第三条指令明明与前两条指令独立，可以先执行，却被第二条指令暂停了</p>
<p>乱序执行类似于数据流结构，但是并不暴露给 ISA</p>
<p>思想：将未准备好的指令移除出独立的指令的路</p>
<p>优点：延迟容忍：运行独立的指令在有一个长延迟的操作的情况下执行并完成</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8Cvs%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C.webp" alt="顺序执行vs乱序执行"></p>
<p>OoO 执行：</p>
<ul>
<li>将值的消费者而后生产者连接起来：寄存器重命名：每个数据值关联一个标签</li>
<li>在指令准备好执行前缓存：在重命名后插入到<strong>保留区 Reservation stations(RS)</strong> 中</li>
<li>指令需要跟踪源值的可读性：
<ul>
<li>在值生产后<strong>广播 broadcast</strong> 标签</li>
<li>指令将它们的源标签与广播标签比较，若相同，则源值准备好了</li>
</ul>
</li>
<li>当一个指令的所有源值都准备好了，则发送指令到 FU 中
<ul>
<li>如果所有的源值都准备好了，则指令<strong>唤醒 wake up</strong></li>
<li>如果多重指令醒着，则需要选择为每个 FU <strong>选择</strong>一个</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E4%B8%A4%E4%B8%AA%E9%A9%BC%E5%B3%B0.webp" alt="两个驼峰"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C.webp" alt="乱序执行"></p>
<p>关键路径：标签广播-&gt;值捕捉-&gt;指令唤醒</p>
<p>保存区：中心化 vs 分布式</p>
<p>精确异常：和之前一样</p>
<p>一条指令在执行完成后更新 RAT（<strong>前端寄存器文件 frontend register file</strong>），在退休后如果是最老的指令，则更新架构寄存器文件</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E6%96%87%E4%BB%B6.webp" alt="乱序执行寄存器文件"></p>
<p>可以发现寄存器中存了很多重复的值，可以将其存一个较小的指针，指向一个大寄存器表（物理 RF）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E9%87%8D%E5%A4%8D%E5%AF%84%E5%AD%98%E5%99%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.webp" alt="重复寄存器解决方案"></p>
<p>乱序执行总结：</p>
<ul>
<li>链接</li>
<li>缓存</li>
<li>跟踪可读性</li>
<li>发送</li>
</ul>
<p>乱序执行实际上动态地找到了程序中的平行操作</p>
<h2 id="超标量执行-Superscalar-Execution">超标量执行 Superscalar Execution</h2>
<p>思想：一个周期获取，解码，执行，退休多条指令</p>
<p>硬件实现了同时获取的指令的依赖性</p>
<p>超标量执行和乱序执行是<strong>正交</strong>的概念</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%B6%85%E6%A0%87%E9%87%8F%E6%89%A7%E8%A1%8C.webp" alt="超标量执行"></p>
<h2 id="分支预测-Branch-Prediction">分支预测 Branch Prediction</h2>
<p>处理控制依赖：</p>
<ul>
<li>暂停流水线直到知道下一个获取的地址</li>
<li>猜测下一个获取地址（分支预测）</li>
<li>实施延迟分支（分支延迟槽）</li>
<li>做其他事（细粒度多线程）</li>
<li>减少控制流指令（预测执行）</li>
<li>两个可能的路径都获取（多路径执行）</li>
</ul>
<p>最简单的方法：NextPC = PC + 4</p>
<p>优化方法：编译器提前预测两个分支执行的可能性，将概率高的放在顺序位置</p>
<p>摆脱控制流指令：</p>
<ul>
<li>摆脱不必要的控制流指令——组合预测并检测一次</li>
<li>把控制依赖转化为数据依赖——预测执行（也叫做 if 转换）</li>
</ul>
<p><strong>分布预测 Branch Prediction</strong>：</p>
<p>思想：预测下一条获取的地址</p>
<p>观察到对于一个直接条件分支，目标地址是相同的</p>
<p>思想：从之前的实例中存储目标地址，并用 PC 访问</p>
<p>叫做<strong>分支目标缓存 Branch Target Buffer(BTB)</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%88%86%E6%94%AF%E7%9B%AE%E6%A0%87%E7%BC%93%E5%AD%98.webp" alt="分支目标缓存"></p>
<p>静态分支预测：</p>
<ul>
<li>总是不选择：编译器排列好了代码</li>
<li>总是选择：对于循环来说非常有优势</li>
<li>这两者的优点可以兼顾，即<strong>后向选择，前向不选择（BTFN）</strong>，即循环总是选择，条件分支总是不选择</li>
</ul>
<p><strong>基于剖析 profile-based</strong>：编译器使用剖析运行决定每个分支的可能的方向</p>
<p>缺点：</p>
<ul>
<li>需要在分支指令格式上有提示位</li>
<li>准确性依赖于动态分支表现</li>
<li>准确性依赖于剖析输入数据的代表性</li>
</ul>
<h2 id="进阶分支预测-Advanced-Branch-Prediction">进阶分支预测 Advanced Branch Prediction</h2>
<p><strong>基于程序 program-based</strong>：使用基于程序分析的启发式决定静态预测方向，例如预测循环总是选择，异常处理总是不选择</p>
<p>缺点：</p>
<ul>
<li>启发式可能不具有代表性</li>
<li>需要编译器分析和 ISA 支持</li>
</ul>
<p><strong>基于程序员 programmer-based</strong>：程序员提供静态预测方向，通过在编程语言中使用 <strong>pragmas</strong> 实现</p>
<p>缺点：需要程序员、编程语言、编译器、ISA 支持</p>
<p>pragmas：使程序员能够向低层次表达提示的关键词，如 <code>if(likely(x))</code>,<code>#pragma omp parallel</code></p>
<p>这三种静态技术的缺点都是无法适应<strong>动态</strong>改变</p>
<p><strong>上次预测 last time predictor</strong>：猜测分支和其上次一样，需要在 BTB 中存储一个位</p>
<p>优点在于对于较大的 K 的循环，准确率非常高</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E4%B8%8A%E6%AC%A1%E9%A2%84%E6%B5%8B1.webp" alt="上次预测1"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E4%B8%8A%E6%AC%A1%E9%A2%84%E6%B5%8B2.webp" alt="上次预测2"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E4%B8%8A%E6%AC%A1%E9%A2%84%E6%B5%8B%E7%8A%B6%E6%80%81%E6%9C%BA.webp" alt="上次预测状态机"></p>
<p>可以观察到这种方法改变地太快了，只看到一次改变就改变了自己的看法</p>
<p><strong>基于两位计时器的预测 tow-bit counter based prediction</strong>：每个分支和两位计时器关联，即提供了滞后</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E4%B8%A4%E4%BD%8D%E8%AE%A1%E6%97%B6%E5%99%A8%E6%BB%9E%E5%90%8E.webp" alt="两位计时器滞后"></p>
<p><strong>两级预测 two-level Prediction</strong>：前两者都探索了<strong>上次</strong>预测，还可以从其他维度观察：</p>
<ul>
<li>一个分支的结果可能而后其他分支的结果有关——全局分支关联</li>
<li>一个分支的结果可能和相同分支的过去结果有关（注意不是<strong>上次</strong>）——局部分支关联</li>
</ul>
<p><strong>全局分支关联 global branch correlation</strong>将分支结果和<strong>所有分支的全局历史</strong>关联，基于上次相同全局分支历史出现的分支结果预测分支</p>
<p>实现：</p>
<ul>
<li>所有分支的全局历史——全局历史寄存器（GHR）</li>
<li>使用 GHR 索引记录结果的表</li>
</ul>
<p>两级历史——GHR + GHR 处的历史</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E4%B8%A4%E7%BA%A7%E5%85%A8%E5%B1%80%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B.webp" alt="两级全局分支预测"></p>
<p>改进：向全局预测器添加正在选择的分支的上下文</p>
<p>Gshare 预测器：用分支 PC 哈希 GHR</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Gshare%E9%A2%84%E6%B5%8B%E5%99%A8.webp" alt="Gshare预测器"></p>
<p><strong>局部分支关联 local Branch correlation</strong>：有每个分支历史寄存器，基于上次相同局部分支历史出现的分支结果预测分支</p>
<p>两级历史——每个分支历史寄存器 + 历史寄存器值处的历史</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E4%B8%A4%E7%BA%A7%E5%B1%80%E9%83%A8%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B.webp" alt="两级局部分支预测"></p>
<p>两级预测器分类：</p>
<ul>
<li>BHR 可以是全局的，每个分支集的，每个分支的</li>
<li>PHT 可以是全局的，每个分支集的，每个分支的</li>
</ul>
<p>这些方法各有适用的分支类型，无法对所有分支都适用</p>
<p><strong>混合分支预测器 hybrid branch predictors</strong>：使用不止一个预测器，选择最佳的预测</p>
<ul>
<li>有偏向分支：许多分支都偏向于一个方向</li>
<li>这些分支污染了分支预测结构</li>
<li>检测这些有偏向的分支，使用更简单的预测器预测他们</li>
</ul>
<p>其他分支预测器类型：</p>
<ul>
<li>循环分支检测器和预测器：计数循环迭代次数</li>
<li>感知机分支预测器：使用简单的机器学习算法赋权值</li>
<li>基于混合历史长度的预测器：使用不同历史长度的不同表</li>
</ul>
<p><strong>感知机 perceptron</strong> 是一个简化的神经元模型，也叫做二项分类器</p>
<ul>
<li>输入向量 X，X 为历史寄存器的每个位</li>
<li>感知机学习向量的每个元素如何影响输出，并存储在内部的加权向量中</li>
<li>输出 Weight @ X + Bias &gt; 0，即当前分支的预测结果</li>
</ul>
<p><strong>使用多重历史长度的预测器</strong>：有多个用不同的历史长度的 GHR 索引的 PHT</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E5%8E%86%E5%8F%B2%E9%95%BF%E5%BA%A6%E7%9A%84%E9%A2%84%E6%B5%8B%E5%99%A8.webp" alt="使用多重历史长度的预测器"></p>
<p><strong>分支自信度估计 branch confidence estimation</strong>：估计预测正确的可能性</p>
<p>实现：</p>
<ul>
<li>记录过去 N 个分支的实例的正确/错误结果</li>
<li>基于这些匹配，猜测当前预测是否正确</li>
</ul>
<p><strong>延迟分支 delayed branch</strong>：延迟分支执行，在分支后的 N 条指令不管分支方向，总是执行</p>
<ul>
<li>份额只必须和延迟槽指令独立</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%BB%B6%E8%BF%9F%E5%88%86%E6%94%AF.webp" alt="延迟分支"></p>
<p><strong>带压扁的延迟分支 delayed branch with squashing</strong>：在 ISA 中的语法：如果分支未选择，则延迟槽中的指令不执行</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%B8%A6%E5%8E%8B%E6%89%81%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%88%86%E6%94%AF.webp" alt="带压扁的延迟分支"></p>
<p>缺点：延迟槽难以填满</p>
<h2 id="VLIW-结构，脉动阵列结构，解耦合访问-执行-VLIW-Systolic-Array-Architectures-Decoupled-Access-Execute">VLIW 结构，脉动阵列结构，解耦合访问-执行 VLIW, Systolic Array Architectures, Decoupled Access-Execute</h2>
<p><strong>VLIW（Very Long Instruction Word）</strong>：编译器把独立的指令打包到一起，硬件同时获取和执行这些指令</p>
<p>不需要硬件上的依赖性检查</p>
<p>Lock-step 执行：如果有一个 VLIW 指令中的任何操作暂停，则所有同时的操作暂停</p>
<p>所以 VLIW 的问题在于操作延迟可能是可变的</p>
<p>可以发现 VLIW 在嵌入式，DSP，一些 GPU 中比较成功，其原因是容易找到平行操作</p>
<p><strong>超级块 superblock</strong>：将频繁执行的基础块组合，形成一个<strong>单入口多出口</strong>的大块，就像直线的代码一样</p>
<p>缺点：</p>
<ul>
<li>增加代码大小</li>
<li>需要重新编译</li>
<li>依赖剖析</li>
</ul>
<p>其可用于编译器优化：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%B6%85%E7%BA%A7%E5%9D%97%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96.webp" alt="超级块代码优化"></p>
<p><strong>Systolic Array Architectures 脉动阵列结构</strong>：特定目的的加速器，现在常用于机器学习加速器</p>
<p>思想：用 PE 的阵列替代一个执行单元（PE）并小心地协调 PE 间的数据流</p>
<p>这种做法的好处：最大化在一个从内存中出来的数据上的计算</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%84%89%E5%86%B2%E8%AE%A1%E7%AE%97%E5%8D%B7%E7%A7%AF.webp" alt="脉冲计算卷积"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/2D%E8%84%89%E5%86%B2%E9%98%B5%E5%88%97%E8%AE%A1%E7%AE%97.webp" alt="2D脉冲阵列计算"></p>
<p>优点：I/O 带宽大</p>
<p>也可以使用流水线，把计算划分成多个阶段：</p>
<p><strong>解耦合访问执行 decoupled access-execute(DAE)</strong>：通过两个分离的指令流，其通过 ISA 可见的队列通信，以解耦合访问和执行的操作</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/DAE.webp" alt="DAE"></p>
<p>指令示例：</p>
<table>
<thead>
<tr>
<th>访问</th>
<th>执行</th>
</tr>
</thead>
<tbody>
<tr>
<td>AEQ+z+10, A2</td>
<td>x4+x2*f AEQ</td>
</tr>
<tr>
<td>x, A2 +EAQ</td>
<td>EAQ+AEQ*f X6</td>
</tr>
</tbody>
</table>
<p>这种方法的优点在于两个操作可以不用等待另一个操作</p>
<p>缺点：</p>
<ul>
<li>编译器需要划分程序和管理队列</li>
<li>分支指令需要同步</li>
</ul>
<h2 id="SIMD-处理器-SIMD-Processors">SIMD 处理器 SIMD Processors</h2>
<p>四种划分：</p>
<ul>
<li>SISD：单指令操作单数据元素</li>
<li>SIMD：单指令操作多数据元素
<ul>
<li>阵列处理器，向量处理器</li>
</ul>
</li>
<li>MISD：多指令操作单数据元素
<ul>
<li>脉动阵列结构</li>
</ul>
</li>
<li>MIMD：多指令操作多数据元素
<ul>
<li>多处理器</li>
<li>多线程处理器</li>
</ul>
</li>
</ul>
<p>SIMD 的并发出现在对<strong>不同</strong>部分数据执行<strong>相同</strong>的操作，即采用了对不同数据的操作级别的平行</p>
<p>时间-空间对偶</p>
<ul>
<li>阵列处理器 Array processor：<strong>同时</strong>使用<strong>不同空间</strong>操作多重数据</li>
<li>向量处理器 Vector processor：在<strong>相同空间</strong>以<strong>连续时间</strong>步数操作多重数据</li>
</ul>
<p>存储多重数据元素：向量寄存器</p>
<p>每个<strong>向量数据寄存器 vector data register</strong> 保持 N 个 M bit 的值</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%90%91%E9%87%8F%E5%AF%84%E5%AD%98%E5%99%A8.webp" alt="向量寄存器"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E9%98%B5%E5%88%97%E5%A4%84%E7%90%86%E5%99%A8vs%E5%90%91%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8.webp" alt="阵列处理器vs向量处理器"></p>
<p>向量处理器：</p>
<ul>
<li>向量寄存器</li>
<li>向量长度寄存器 VLEN</li>
<li>向量步长寄存器 VSTR</li>
</ul>
<p>向量指令允许更深的流水线：</p>
<ul>
<li>没有内部向量依赖</li>
<li>向量内部没有控制流</li>
<li>已知步长允许对所有向量元素的简单的地址计算
<ul>
<li>允许简单或更早的加载</li>
</ul>
</li>
</ul>
<p>Amdahl's Law：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>加速</mtext><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>−</mo><mi>f</mi><mo>+</mo><mfrac><mi>f</mi><mi>N</mi></mfrac></mrow></mfrac></mrow><annotation encoding="application/x-tex">\text{加速} = \frac{1}{1-f +\frac{f}{N}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">加速</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.4886559999999998em;vertical-align:-1.1672159999999998em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.177784em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1672159999999998em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>向量寄存器：</p>
<ul>
<li><strong>向量数据寄存器</strong>保存值</li>
<li><strong>向量控制寄存器</strong>：VLEN，VSTR，VMASK
<ul>
<li>VMASK 指示要操作哪个元素，如 <code>VMASK[i] = (V[i] == 0)</code></li>
</ul>
</li>
</ul>
<p>向量函数单元：使用深的流水线执行元素操作</p>
<p>如果我们能每个周期开始加载一个元素，则元素可以连续周期被加载，方法就是<strong>堆积 bank</strong> 内存，通过 bank 交错元素</p>
<p>内存被划分到可以独立访问共享地址和数据总线的 bank 中</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%86%85%E5%AD%98bank.webp" alt="内存bank"></p>
<p>如果步长 == 1 &amp;&amp; 连续的元素交错在 bank &amp;&amp; bank 的数量 &gt;= bank 的延迟，则可以维持 1 元素/周期的吞吐量</p>
<p><strong>向量链</strong>：数据从一个向量函数单元转发到另一个</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%90%91%E9%87%8F%E9%93%BE.webp" alt="向量链"></p>
<p>还可以增加多个 bank 的端口</p>
<p>如果向量数据不在内存中以固定步长模式存储，则可以使用<strong>间接索引</strong>将其组合到向量寄存器中，这也对稀疏向量有益</p>
<p><strong>gather/scatter 操作</strong>：向量使用索引向量加上基寄存器来产生加载和存储的地址</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/scatter%E6%93%8D%E4%BD%9C.webp" alt="scatter操作"></p>
<p>循环中的条件操作使用 Masked 操作</p>
<p>如果是双分支，则可以 Masked 计算 A 后取 Masked 的互补计算 B</p>
<p>Masked 有两种实现，简单实现和稠密时间实现</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0vs%E7%A8%A0%E5%AF%86%E6%97%B6%E9%97%B4%E5%AE%9E%E7%8E%B0.webp" alt="简单实现vs稠密时间实现"></p>
<p>步长和 bank 要互质</p>
<p>减小 bank 冲突：</p>
<ul>
<li>更多 bank</li>
<li>每个 bank 更多端口</li>
<li>更好的数据布局</li>
<li>更好的地址向 bank 的映射</li>
</ul>
<h2 id="图形处理单元-Graphic-Processing-Units">图形处理单元 Graphic Processing Units</h2>
<p>GPU 指令流水线像 <strong>SIMD</strong> 流水线一样运行，但是编程使用<strong>线程</strong>完成，即 GPU 是一个 <strong>SIMT</strong> 机器</p>
<p>执行相同指令的线程集合被硬件动态地分组到一个 warp 中</p>
<p>这个编程模型叫 <strong>SPMD</strong></p>
<p>SIMT 的优点：</p>
<ul>
<li>分别处理每个线程</li>
<li>灵活地分组线程到 warp 中</li>
</ul>
<p>warp 可以在相同流水线上交错，即 <strong>warp 的细粒度多线程</strong>，通过这个容忍了延迟</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/warp%E6%89%A7%E8%A1%8C.webp" alt="warp执行"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/SIMD%E6%89%A7%E8%A1%8C%E5%8D%95%E5%85%83%E7%BB%93%E6%9E%84.webp" alt="SIMD执行单元结构"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/warp%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%88%AB%E5%B9%B6%E8%A1%8C.webp" alt="warp指令级别并行"></p>
<p><strong>分支发散 branch divergence</strong>：warp 内部的线程分支到不同执行路径</p>
<p>可以找到相同 PC 的线程，动态地将它们分组到一个 warp 中</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%8A%A8%E6%80%81warp%E5%90%88%E5%B9%B6.webp" alt="动态warp合并"></p>
<p><strong>以两级调度</strong>来处理长延迟的操作</p>
<h2 id="内存概览，组织与技术-Memory-Overview-Organization-Technology">内存概览，组织与技术 Memory Overview, Organization &amp; Technology</h2>
<p>内存的阵列组织：M bit 的值可以在每个独特的 N bit 的地址读写</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%86%85%E5%AD%98%E7%9A%84%E9%98%B5%E5%88%97%E7%BB%84%E7%BB%87.webp" alt="内存的阵列组织"></p>
<p>访问晶体管连接 bit 存储到 bitline，由 wordline 控制访问</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6.webp" alt="访问控制"></p>
<p>随着内存越来越大，速度也越来越慢，所以需要<strong>将内存划分成更小的阵列</strong></p>
<p>DRAM 的层次结构：Channel -&gt; rank -&gt; bank -&gt; subarrays -&gt; Mats</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Channel.webp" alt="Channel"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/module.webp" alt="module"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/rank.webp" alt="rank"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/bank.webp" alt="bank"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/chip.webp" alt="chip"></p>
<p><strong>动态随机访问内存 dynamic random access memory(DRAM)</strong>：</p>
<ul>
<li>电容充电状态储存值</li>
<li>电容通过 RC 电路泄漏，故需要 refresh</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/SRAM%E8%AF%BB.webp" alt="SRAM读"></p>
<p><strong>相变内存 phase change memory</strong>：非易失内存</p>
<h2 id="内存层次结构与缓存-Memory-Hierachy-and-Caches">内存层次结构与缓存 Memory Hierachy and Caches</h2>
<p>由于速度、成本、容量等的权衡，就有了内存的层次结构</p>
<p>手动管理缓存（GPU，ML 加速器） vs 自动管理缓存</p>
<p>递归延迟等式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub><mo>=</mo><msub><mi>t</mi><mi>i</mi></msub><mo>+</mo><msub><mi>m</mi><mi>i</mi></msub><mo>⋅</mo><msub><mi>T</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">T_i = t_i + m_i \cdot T_{i+1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.59445em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">m_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示 miss 的概率，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示访问的时间，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示实际访问时间</p>
<p>三种映射方法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%85%B3%E8%81%94.webp" alt="内存映射关联"></p>
<p>更高的关联度：</p>
<ul>
<li>更高的命中率</li>
<li>更慢的缓存访问时间</li>
<li>更贵的硬件</li>
</ul>
<h2 id="进阶缓存-Advanced-Caches">进阶缓存 Advanced Caches</h2>
<p>驱逐方法：</p>
<p><strong>最小最近访问的块 LRU</strong>：问题在于跟踪块的访问顺序</p>
<p>所以通常使用近似的 LRU，如</p>
<ul>
<li>Not MRU（非最近使用）</li>
<li>层次结构 LRU：划分到 M 个组，跟踪 MRU 组和每个组中的 MRU</li>
<li>受害者-下一个受害者替换</li>
</ul>
<p><strong>集合痛打 set thrashing</strong>：一个程序工作集合大于集合关联性</p>
<ul>
<li>当 thrashing 出现时，随机取代更好</li>
</ul>
<p>在实践中，表现依赖于负载，LRU 和随机的平均命中率差不多，一般两者混合使用，通过<strong>集合采样</strong>选择</p>
<p><strong>Balady's OPT</strong>：取代未来被引用最远的块</p>
<ul>
<li>最优化 miss 比率，但是没有最优化执行时间，因为没有考虑 miss 的延迟</li>
</ul>
<p>处理写：</p>
<p>是否写到下一级？</p>
<ul>
<li>write-back：
<ul>
<li>在驱逐之前将多重写组合到一个块中</li>
<li>但需要 tag 中 dirty bit</li>
</ul>
</li>
<li>write-through：
<ul>
<li>设计简单</li>
<li>缓存一致</li>
<li>但是带宽受限</li>
</ul>
</li>
</ul>
<p>写 miss 的时候是否分配缓存块？</p>
<ul>
<li>分配：
<ul>
<li>组合写</li>
<li>写和读一样，处理更简单</li>
<li>但是需要整个缓存块的转移</li>
</ul>
</li>
<li>不分配：
<ul>
<li>如果写的局部性差，则节约缓存空间</li>
</ul>
</li>
</ul>
<p>如果每次只写块的一部分，则可以使用<strong>子块 subblock</strong> 缓存</p>
<ul>
<li>每个子块都有独立的有效和脏位</li>
<li>一次请求只分配一个子块</li>
</ul>
<p>优点：</p>
<ul>
<li>无需转移整个缓存块</li>
<li>转移更自由</li>
</ul>
<p>缺点：</p>
<ul>
<li>设计复杂</li>
<li>没有完全利用空间局部性</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%AD%90%E5%9D%97%E7%BC%93%E5%AD%98.webp" alt="子块缓存"></p>
<p>指令和数据缓存：</p>
<p>统一：</p>
<ul>
<li>动态共享缓存空间</li>
<li>但是指令和数据会互相驱逐，即不保证都有空间</li>
<li>指令和数据在流水线的不同阶段访问，统一缓存的位置不易确定</li>
</ul>
<p>故通常：</p>
<ul>
<li>一级缓存分离——流水线约束</li>
<li>更高级缓存统一</li>
</ul>
<p>流水线设计中的多级缓存：</p>
<ul>
<li>一级缓存
<ul>
<li>受时钟周期影响</li>
<li>小，更低的关联；延迟很重要</li>
<li>tag 和 data 储存<strong>并行</strong>访问</li>
</ul>
</li>
<li>二级缓存
<ul>
<li>平衡 hit 比率和访问延迟</li>
<li>大而高的关联度；延迟没那么重要</li>
<li>tag 和 data 储存<strong>顺序</strong>访问</li>
</ul>
</li>
</ul>
<p>顺序 serial：</p>
<ul>
<li>只有一级缓存 miss 了，二级缓存才会访问</li>
</ul>
<p><strong>缓存性能：</strong></p>
<p><strong>缓存大小</strong>：</p>
<ul>
<li>过大：速度慢</li>
<li>过小：时间局部性利用率差，经常要替换数据</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%BC%93%E5%AD%98%E5%A4%A7%E5%B0%8F.webp" alt="缓存大小"></p>
<p><strong>块大小</strong>：</p>
<ul>
<li>过大：
<ul>
<li>时间局部性利用差</li>
<li>tag 开销大</li>
</ul>
</li>
<li>过小：
<ul>
<li>空间局部性利用差</li>
<li>浪费带宽</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%9D%97%E5%A4%A7%E5%B0%8F.webp" alt="块大小"></p>
<p>更大的块：</p>
<p>填入时间长：关键字</p>
<ul>
<li>先用关键字填充缓存块</li>
<li>立刻向处理器提供关键数据</li>
</ul>
<p>浪费带宽：划分为子块</p>
<ul>
<li>每个块有有效位和脏位</li>
</ul>
<p><strong>关联性：</strong></p>
<ul>
<li>大：miss 率低，延迟和花费大</li>
<li>小：花费小，延迟低</li>
</ul>
<p>缓存 miss 的分类：</p>
<ul>
<li>义务 miss：第一次引用地址会 miss
<ul>
<li>预获取</li>
</ul>
</li>
<li>容量 miss：缓存太小，不能保存所有东西
<ul>
<li>更好地利用缓存空间</li>
</ul>
</li>
<li>冲突 miss：不是前两者的 miss
<ul>
<li>更多关联</li>
</ul>
</li>
</ul>
<p>重建数据访问模式：</p>
<ul>
<li>循环交换</li>
<li>分块</li>
<li>分离数据结构常用的域并把它们包装到一个分开的数据结构中</li>
</ul>
<p><strong>内存级别并行 Memory Level Parallelism(MLP)</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/ETH%20Zurich%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%86%85%E5%AD%98%E7%BA%A7%E5%88%AB%E5%B9%B6%E8%A1%8C.webp" alt="内存级别并行"></p>
<p>所以从这个角度看，miss 的花费是不一样的，孤立 miss 比并行 miss 更重要</p>
<p>多核系统中的缓存：</p>
<p>共享缓存：多个上下文使用一个硬件资源</p>
<p>优点：</p>
<ul>
<li>提高容量利用率</li>
<li>动态划分可用缓存空间</li>
<li>维持一致性更简单</li>
</ul>
<p>缺点：</p>
<ul>
<li>资源争夺</li>
<li>访问慢</li>
</ul>
<p>缓存一致性的解决方法：所有缓存<strong>窥探 snoop</strong> 互相的读写操作，如果一个处理器写到了一个块中，所有其他的缓存使块无效</p>
<h2 id="预读-Prefetching">预读 Prefetching</h2>
<p><strong>预读 prefetching</strong>：在数据被程序需要前读取它</p>
<ul>
<li>可以减少延迟</li>
<li>减少义务 miss</li>
<li>不会有较大的错误预期的惩罚</li>
</ul>
<p>带宽消耗</p>
<p>增加 window 的大小以忍受内存延迟</p>
<p><strong>超前执行 runahead execution</strong>：从大的指令窗口中受益，可以维护内存级别的并行</p>
<ul>
<li>目的是生成预读取</li>
</ul>
<p>优点：</p>
<ul>
<li>精确预读取</li>
<li>实现简单——绝大多数硬件已经有了</li>
<li>没有上下文的浪费</li>
<li>无需创建预执行线程</li>
</ul>
<p>缺点：</p>
<ul>
<li>额外执行指令</li>
<li>效率受可用的内存级别并行的限制</li>
<li>预读取距离受内存延迟限制</li>
</ul>
<h2 id="虚拟内存-Virtual-Memory">虚拟内存 Virtual Memory</h2>
<p>页表过大——<strong>多级页表</strong></p>
<p>指令获取或读写都需要至少两次内存访问——<strong>翻译查找缓冲 TLB</strong></p>
<p>虚拟内存需要哦软件和硬件的支持，硬件组件叫 MMU</p>
<p>时钟页替代算法：</p>
<ul>
<li>在内存中保持物理栈帧的循环列表</li>
<li>保持指针为最后检查的栈帧</li>
<li>当页被访问时，设置 PTE 中的 R 位</li>
<li>当一个栈帧需要被替代时，替代第一个 R 位没有设置的栈帧，顺时针清除遍历的 R bit</li>
</ul>
<p>Row Hammer：</p>
<ul>
<li>把物理内存填充满 PTE，其指向相同的物理文件</li>
<li>如果 PTE 中的一个 bit 翻转，则对应的虚拟内存地址指向错误的物理页，且有 RW 权限</li>
<li>攻击者可以读写页表，映射到任意拥有读写权限的内存</li>
</ul>
<p>如果 TLB miss，则需要 <strong>walk</strong> 页表</p>
<p>缓存是虚拟地址还是物理地址？</p>
<ul>
<li>虚拟
<ul>
<li>相同的 VA 映射到不同的 PA</li>
<li>不同的 VA 映射到相同的 PA</li>
</ul>
</li>
<li>物理：延迟大</li>
</ul>
<p>所以对于一级缓存，通常两者都使用；对于更高级的缓存，则延迟不是那么重要</p>
<p>L2 TLB 中的 4KB/2MB 结构有 2 步：</p>
<ul>
<li>假设页表大小为 4 KB，访问，如果失败，进行下一步</li>
<li>假设页表大小为 2 MB，访问，如果失败，miss</li>
<li>即时间上的关联性</li>
</ul>
<p>虚拟环境的虚拟内存原理相似，只是由软件实现</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">体系结构</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/">计算机科学</a><a class="post-meta__tags" href="/tags/ETH-Zurich/">ETH Zurich</a></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/518e2799.html" title="UCB CS61C：计算机架构的伟大思想"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/UCB%20CS61C%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%B6%E6%9E%84%E7%9A%84%E4%BC%9F%E5%A4%A7%E6%80%9D%E6%83%B3.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">UCB CS61C：计算机架构的伟大思想</div></div><div class="info-2"><div class="info-item-1">RISC-V RISC 哲学：  保持指令集小而简单，让其能更容易构建快速的硬件 通过将简单的组合在一起让软件实现复杂的操作  RISC-V 中有 32 个寄存器  序号为 x0-31 x0 的值总是为 0 可以使用序号引用，也可以使用名字  注释 #，只支持单行注释 加减的基本格式：sub x3, x4, x5 等价于 x3 = x4 - x5 立即数有不同的指令：addi x3, x4, 10，即最后一个数必须为立即数。注意到没有对应的减法的版本，因为可以通过加法实现 因为 0 非常常用，所以 x0 寄存器在硬件上设置为 0，即例如 add x0, x3, x4 的指令无效 从内存中读取数据：lw x10, 12(x15)，其中 x15 指向 int 数组 A，则 x10 = A[3]，即 12 表示字节的偏移 将数据存到内存中：sw x10, 40(x15) 除了按 word 转移数据，也支持按字节 byte 转移数据，如 lb、sb，注意 lb x10, 3(x11) 将内存中的数据复制到 x10 的低位中，使用符号扩展前面的内容 也有 unsigned 版本...</div></div></div></a><a class="pagination-related" href="/posts/12e06b11.html" title="她善写月亮，却并不圆满"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/%E5%82%B2%E6%85%A2%E4%B8%8E%E5%81%8F%E8%A7%81.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">她善写月亮，却并不圆满</div></div><div class="info-2"><div class="info-item-1"> 凡是有钱的单身汉，总想娶位太太，这已经成了一条举世公认的真理。  《傲慢与偏见》我早就看过，当时就对简奥斯汀讽刺的文笔和美好的描绘留下了印象。伊丽莎白和达西，简和宾利，整个故事就像一个童话一样，伊丽莎白对爱情有主见，而这也得到了她的家人的支持，最终也收获了爱情。达西是傲慢的，而伊丽莎白一开始也是带着对他的偏见审视他，最终误会解开，两人和解。 电影也拍得很好，把这种感觉拍了出来。英伦田园的如诗如画，大雨中的表白，还有在大雾中走来的达西，片尾的 Mrs.Darcy 的声声呼唤，可以说是满足了对美好爱情的一切幻想。 于是，我去看了《成为简奥斯汀》这部以作者自己的爱情故事为原型的电影，实在是太像了，只可惜这是一个悲伤的结局。简和伊丽莎白一样，但勒弗罗伊却不同于达西，他不能独当一面。简有勇气嫁给爱情，却最终败给生活，主动放弃了这段恋情，终生不嫁。她自称作品要反映现实，却像是一个浪漫主义作家，把自己对爱情的所有美好幻想都寄托在小说中，例如达西这个人就结合了勒弗罗伊和韦斯莱的优点，这是有情人得以终成眷属的关键。 简奥斯汀的小说似乎都是...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="iconfont icon-tuijian"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/518e2799.html" title="UCB CS61C：计算机架构的伟大思想"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/UCB%20CS61C%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%B6%E6%9E%84%E7%9A%84%E4%BC%9F%E5%A4%A7%E6%80%9D%E6%83%B3.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-24</div><div class="info-item-2">UCB CS61C：计算机架构的伟大思想</div></div><div class="info-2"><div class="info-item-1">RISC-V RISC 哲学：  保持指令集小而简单，让其能更容易构建快速的硬件 通过将简单的组合在一起让软件实现复杂的操作  RISC-V 中有 32 个寄存器  序号为 x0-31 x0 的值总是为 0 可以使用序号引用，也可以使用名字  注释 #，只支持单行注释 加减的基本格式：sub x3, x4, x5 等价于 x3 = x4 - x5 立即数有不同的指令：addi x3, x4, 10，即最后一个数必须为立即数。注意到没有对应的减法的版本，因为可以通过加法实现 因为 0 非常常用，所以 x0 寄存器在硬件上设置为 0，即例如 add x0, x3, x4 的指令无效 从内存中读取数据：lw x10, 12(x15)，其中 x15 指向 int 数组 A，则 x10 = A[3]，即 12 表示字节的偏移 将数据存到内存中：sw x10, 40(x15) 除了按 word 转移数据，也支持按字节 byte 转移数据，如 lb、sb，注意 lb x10, 3(x11) 将内存中的数据复制到 x10 的低位中，使用符号扩展前面的内容 也有 unsigned 版本...</div></div></div></a><a class="pagination-related" href="/posts/fb3794ef.html" title="Coursera Nand2Tetris：依据基本原理构建现代计算机：从与非门到俄罗斯方块"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/Coursera%20Nand2Tetris%EF%BC%9A%E4%BE%9D%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9A%E4%BB%8E%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-28</div><div class="info-item-2">Coursera Nand2Tetris：依据基本原理构建现代计算机：从与非门到俄罗斯方块</div></div><div class="info-2"><div class="info-item-1">布尔函数和逻辑门 Boolean Functions and Gate Logic 布尔逻辑 Boolean Logic 与或非 布尔函数合成 Boolean Functions Synthesis 不同的布尔函数能表达相同的意思 所有布尔函数都可以用“与或非”表示 进一步，都可以用“与非”表示 (x OR y) = NOT(NOT(x) AND NOT(y)) 更进一步，可以用 NAND （AND 的否定）表示（NOR 也可以）：  NOT(x) = (x NAND x) (x AND y) = NOT(x NAND y)  故可以仅使用 NAND 构造整个逻辑 逻辑门 Logic Gates 基本逻辑门，复合逻辑门 将复合逻辑门看作黑盒，关心接口，不关心实现 硬件描述语言 Hardware Description Language // 接口CHIP Xor &#123;    IN a, b;    OUT out;    PARTS:    // 实现    Not(in=a, out=nota);    Not(in=b, out=notb);    And(a=a,...</div></div></div></a><a class="pagination-related" href="/posts/e7a99a5e.html" title="UCB CS61A：计算机程序的构造与解释"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/UCB%20CS61A%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E8%A7%A3%E9%87%8A.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-14</div><div class="info-item-2">UCB CS61A：计算机程序的构造与解释</div></div><div class="info-2"><div class="info-item-1"> 值 Values 在 Python 中0o20为八进制的16，0b1101为二进制13，0x为十六进制。 还有字符串 string，元组 tuple，范围 range，列表 list，字典 dictionary，集合 set 函数 Functions，表达式 Expressions，环境 Environments 定义函数： def saxb(a, x, b):    return a * x + b 写成 λ 表达式（能当作表达式的函数）： lambda a, x, b: a * x + b  Environment 是名称对值的映射 在环境中名称被绑定到值上 最外层环境叫 global environment frame  函数被称为第一类值 first-class values，可以作为某一函数的参数或返回值： def add_func(f, g):    def adder(x):        return f(x) + g(x)    return adder&gt;&gt;&gt; from math import sin,cos,pi&gt;&gt;&gt;...</div></div></div></a><a class="pagination-related" href="/posts/7ea0cbe4.html" title="UCB CS61B：数据结构与算法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/UCB%20CS61B%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-30</div><div class="info-item-2">UCB CS61B：数据结构与算法</div></div><div class="info-2"><div class="info-item-1">介绍 先来个Helloword： public class Helloworld &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;Hello world&quot;);    &#125;&#125; Java 的特点：  所有代码都必须在类里面 语句组用大括号，语句末用分号 变量使用前先声明 变量类型是确定的，且不可变（静态语言） 注意public，private等 函数参数需要声明类型，返回值也是 所有 Java 中的函数都是方法  确定变量类型的优点：  运行速度快 可读性强 减少类型错误  缺点：  代码复杂  类 class 的使用 假如有这样一个类： public class Dog &#123;    public int weight;    public Dog(int startingweight) &#123;        weight = startingweight;    &#125;    public static...</div></div></div></a><a class="pagination-related" href="/posts/d2849331.html" title="计算机科学中的伟大思想"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%AD%E7%9A%84%E4%BC%9F%E5%A4%A7%E6%80%9D%E6%83%B3.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-25</div><div class="info-item-2">计算机科学中的伟大思想</div></div><div class="info-2"><div class="info-item-1"> 从第一行 “hello world” 开始，到各种精巧的细分领域的学习，再到第一次编写一个完整的程序——你已经历许多，现在，请开启你最伟大的冒险吧。从一行一行的代码到复杂的程序项目。  你好，世界 从为了使用 LaTeX 编写数学公式而编写文章，到目前为止，这一分类的文章数量虽然算不得多，但也不少了。40 余篇虽然远不及别人一年发的 SCI...</div></div></div></a><a class="pagination-related" href="/posts/dcdf88c8.html" title="计算机科学速成课"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-19</div><div class="info-item-2">计算机科学速成课</div></div><div class="info-2"><div class="info-item-1">计算机早期历史 Early Computing 公认最早的计算设备的算盘，注意不是中国的，而是美索不达米亚文明的，它没有计算的功能，只是用于记录数据。 最早使用计算机 computer 一词的文献是 1613 年的一本书，指的是一种职业，即负责计算的人，他们有时也会使用机器辅助计算，所以渐渐地“计算机”也代指机器。 步进计算器：由莱布尼兹发明，像汽车的里程表   加法：由多个齿轮组成，每当一个齿轮转过 9，它会转回 0，同时让旁边的齿轮前进一个齿   减法：反向旋转   乘除：本质上是加法或减法的叠加   所以它是第一台能做“加减乘除”的机器   计算表：预先算好，也就是早期的打表法，类似与字典之类的工具书，但不够灵活。 Charles Babbage 提出了“差分机”，能近似多项式，但最终没做出来，后来有人历史学家按照它的设计图做了出来，发现确实可以做到。 在做这台机器的过程中，这个人提出了一种“分析机”的概念，是“通用计算机”，和后来的冯诺依曼结构是一种东西，但实在是太超前了，当时仅存在于概念上。 此人被认为是“计算之父” Ada Lovelace...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/%E5%A4%B4%E5%83%8F_%E7%81%B0%E5%A4%AA%E7%8B%BC.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Aefrivern</div><div class="author-info-description">我一定会回来的</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">186</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">240</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/aefrivern" rel="external nofollow noreferrer" target="_blank" title="icon-github"><i class="GitHub"></i></a><a class="social-icon" href="mailto:2771503468@qq.com" rel="external nofollow noreferrer" target="_blank" title="icon-youxiang"><i class="QQ邮箱"></i></a><a class="social-icon" href="https://steamcommunity.com/id/old_driver_zero" rel="external nofollow noreferrer" target="_blank" title="icon-steam"><i class="Steam"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><a class="faa-parent animated-hover"><svg class="faa-tada icon" style="height:25px;width:25px;fill:currentColor;position:relative;top:5px" aria-hidden="true"><use xlink:href="#icon-mulu"></use></svg></a><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%A8%80%E4%B8%8E%E5%9F%BA%E7%A1%80-Introduction-and-Basics"><span class="toc-number">1.</span> <span class="toc-text">引言与基础 Introduction and Basics</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%83%E8%A1%A1%EF%BC%8C%E6%8C%87%E6%A0%87-Tradeoffs-Metrics"><span class="toc-number">2.</span> <span class="toc-text">权衡，指标 Tradeoffs, Metrics</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF-Combinational-Logic"><span class="toc-number">3.</span> <span class="toc-text">组合逻辑电路 Combinational Logic</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1-Sequential-Logic-Design"><span class="toc-number">4.</span> <span class="toc-text">时序逻辑设计 Sequential Logic Design</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80%E5%92%8C-Verilog-Hardware-Desccription-Languages-and-Verilog"><span class="toc-number">5.</span> <span class="toc-text">硬件描述语言和 Verilog Hardware Desccription Languages and Verilog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%92%8C%E9%AA%8C%E8%AF%81-Timing-and-Verification"><span class="toc-number">6.</span> <span class="toc-text">时间和验证 Timing and Verification</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84-Von-Neumann-Model"><span class="toc-number">7.</span> <span class="toc-text">冯诺依曼结构 Von Neumann Model</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%9E%84-Instruction-Set-Architectures"><span class="toc-number">8.</span> <span class="toc-text">指令集架构 Instruction Set Architectures</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9E%B6%E6%9E%84-Microarchitecture"><span class="toc-number">9.</span> <span class="toc-text">微架构 Microarchitecture</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%91%A8%E6%9C%9F%E5%BE%AE%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-Multi-Cycle-Microarchitecture-Design"><span class="toc-number">10.</span> <span class="toc-text">多周期微架构设计 Multi-Cycle Microarchitecture Design</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF-Pipelining"><span class="toc-number">11.</span> <span class="toc-text">流水线 Pipelining</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1-Pipelined-Processor-Design"><span class="toc-number">12.</span> <span class="toc-text">流水线处理器设计 Pipelined Processor Design</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B2%BE%E7%A1%AE%E5%BC%82%E5%B8%B8-Precise-Exceptions"><span class="toc-number">13.</span> <span class="toc-text">精确异常 Precise Exceptions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C-Out-of-Order-Execution"><span class="toc-number">14.</span> <span class="toc-text">乱序执行 Out-of-Order Execution</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E6%A0%87%E9%87%8F%E6%89%A7%E8%A1%8C-Superscalar-Execution"><span class="toc-number">15.</span> <span class="toc-text">超标量执行 Superscalar Execution</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B-Branch-Prediction"><span class="toc-number">16.</span> <span class="toc-text">分支预测 Branch Prediction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B-Advanced-Branch-Prediction"><span class="toc-number">17.</span> <span class="toc-text">进阶分支预测 Advanced Branch Prediction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VLIW-%E7%BB%93%E6%9E%84%EF%BC%8C%E8%84%89%E5%8A%A8%E9%98%B5%E5%88%97%E7%BB%93%E6%9E%84%EF%BC%8C%E8%A7%A3%E8%80%A6%E5%90%88%E8%AE%BF%E9%97%AE-%E6%89%A7%E8%A1%8C-VLIW-Systolic-Array-Architectures-Decoupled-Access-Execute"><span class="toc-number">18.</span> <span class="toc-text">VLIW 结构，脉动阵列结构，解耦合访问-执行 VLIW, Systolic Array Architectures, Decoupled Access-Execute</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SIMD-%E5%A4%84%E7%90%86%E5%99%A8-SIMD-Processors"><span class="toc-number">19.</span> <span class="toc-text">SIMD 处理器 SIMD Processors</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83-Graphic-Processing-Units"><span class="toc-number">20.</span> <span class="toc-text">图形处理单元 Graphic Processing Units</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A6%82%E8%A7%88%EF%BC%8C%E7%BB%84%E7%BB%87%E4%B8%8E%E6%8A%80%E6%9C%AF-Memory-Overview-Organization-Technology"><span class="toc-number">21.</span> <span class="toc-text">内存概览，组织与技术 Memory Overview, Organization &amp; Technology</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%93%E5%AD%98-Memory-Hierachy-and-Caches"><span class="toc-number">22.</span> <span class="toc-text">内存层次结构与缓存 Memory Hierachy and Caches</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6%E7%BC%93%E5%AD%98-Advanced-Caches"><span class="toc-number">23.</span> <span class="toc-text">进阶缓存 Advanced Caches</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E8%AF%BB-Prefetching"><span class="toc-number">24.</span> <span class="toc-text">预读 Prefetching</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98-Virtual-Memory"><span class="toc-number">25.</span> <span class="toc-text">虚拟内存 Virtual Memory</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>安得广厦千万间，大庇天下寒士俱欢颜，风雨不动安如山。</div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/comments/">留点什么</a><a href="/random/">随便逛逛</a></li><li><a href="/about/">关于</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/gallery/">我的画廊</a><a href="/charts/">网站统计</a></li></ul></div></div></div></div><div class="copyright">&copy;2022 - 2025 By Aefrivern</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (true) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script></div><script async src="//at.alicdn.com/t/c/font_4031045_1yiosqv4vch.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      window.location.href = e.request.responseURL
    }
  })
})()</script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/c/font_4031045_izvon5l4fr8.js"></script><!-- hexo injector body_end end --></body></html>