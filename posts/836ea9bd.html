<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CMU 15-213：计算机系统导论 | old-driver-zeroの小屋</title><meta name="author" content="old_driver_zero"><meta name="copyright" content="old_driver_zero"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="比特，字节和整数 Bits, Bytes, and Integers 布尔代数 位移操作：   左移 x &lt;&lt; y：丢弃左边多余的位，右边补 0   右移 x &gt;&gt; y：  逻辑右移：左边补 0 算术右移：左边重复最高位 c 语言默认为算术右移，Java 用 &gt;&gt;&gt; 区分出逻辑右移    当位移长度 &lt; 0 或 &gt; 字长时，为定义   数字范围">
<meta property="og:type" content="article">
<meta property="og:title" content="CMU 15-213：计算机系统导论">
<meta property="og:url" content="https://old-driver-zero.github.io/posts/836ea9bd.html">
<meta property="og:site_name" content="old-driver-zeroの小屋">
<meta property="og:description" content="比特，字节和整数 Bits, Bytes, and Integers 布尔代数 位移操作：   左移 x &lt;&lt; y：丢弃左边多余的位，右边补 0   右移 x &gt;&gt; y：  逻辑右移：左边补 0 算术右移：左边重复最高位 c 语言默认为算术右移，Java 用 &gt;&gt;&gt; 区分出逻辑右移    当位移长度 &lt; 0 或 &gt; 字长时，为定义   数字范围">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://old-driver-zero.github.io/gallery/cover/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA.webp">
<meta property="article:published_time" content="2023-09-06T00:17:22.000Z">
<meta property="article:modified_time" content="2024-05-01T07:36:10.000Z">
<meta property="article:author" content="old_driver_zero">
<meta property="article:tag" content="CMU">
<meta property="article:tag" content="计算机系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://old-driver-zero.github.io/gallery/cover/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA.webp"><link rel="shortcut icon" href="/illustration/favicon.ico"><link rel="canonical" href="https://old-driver-zero.github.io/posts/836ea9bd.html"><link rel="preconnect" href="//cdnjs.cloudflare.com"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.32/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"GY5EJYJ1FS","apiKey":"c443c952672ec7062840aac45536181e","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdnjs.cloudflare.com/ajax/libs/egjs-infinitegrid/4.11.0/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CMU 15-213：计算机系统导论',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-01 15:36:10'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4031045_1yiosqv4vch.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/highlight.css"><link rel="stylesheet" href="/css/custom.css"><script src="/js/echarts.min.js"></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/c/font_4031045_izvon5l4fr8.js"></script><!-- hexo injector body_end end --></body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/%E5%A4%B4%E5%83%8F_%E7%81%B0%E5%A4%AA%E7%8B%BC.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">183</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-shouye-01"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shouye-01"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-guidang"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guidang"></use></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw icon-a-16-01-01"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-a-16-01-01"></use></svg><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-wenjianjia"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wenjianjia"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/anime/"><i class="fa-fw icon-zhifeiji"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhifeiji"></use></svg><span> 二次元</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/gallery/"><i class="fa-fw icon-xiangce"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiangce"></use></svg><span> 画廊</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-guanyu"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyu"></use></svg><span> 关于</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/charts/"><i class="fa-fw icon-tongjichaxun"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tongjichaxun"></use></svg><span> 统计</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-liuyan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyan"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/random/"><i class="fa-fw icon-suiji"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-suiji"></use></svg><span> 随便逛逛</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/gallery/cover/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="old-driver-zeroの小屋"><span class="site-name">old-driver-zeroの小屋</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-sousuo1"></use></svg><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-shouye-01"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shouye-01"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-guidang"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guidang"></use></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw icon-a-16-01-01"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-a-16-01-01"></use></svg><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-wenjianjia"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wenjianjia"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/anime/"><i class="fa-fw icon-zhifeiji"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhifeiji"></use></svg><span> 二次元</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/gallery/"><i class="fa-fw icon-xiangce"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiangce"></use></svg><span> 画廊</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-guanyu"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyu"></use></svg><span> 关于</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/charts/"><i class="fa-fw icon-tongjichaxun"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tongjichaxun"></use></svg><span> 统计</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-liuyan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyan"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/random/"><i class="fa-fw icon-suiji"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-suiji"></use></svg><span> 随便逛逛</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CMU 15-213：计算机系统导论</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-06T00:17:22.000Z" title="发表于 2023-09-06 08:17:22">2023-09-06</time><span class="post-meta-separator">|</span><svg class="meta_icon post-ui-icon" style="width:13px;height:13px;position:relative;top:2px"><use xlink:href="#icon-gengxin"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-01T07:36:10.000Z" title="更新于 2024-05-01 15:36:10">2024-05-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><a class="faa-parent animated-hover"></a><svg class="meta_icon post-ui-icon" style="width:13px;height:13px;position:relative;top:2px"><use xlink:href="#icon-fenlei"></use></svg><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-word"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">1.3w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>44分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="比特，字节和整数-Bits-Bytes-and-Integers">比特，字节和整数 Bits, Bytes, and Integers</h1>
<p>布尔代数</p>
<p>位移操作：</p>
<ul>
<li>
<p>左移 <code>x &lt;&lt; y</code>：丢弃左边多余的位，右边补 0</p>
</li>
<li>
<p>右移 <code>x &gt;&gt; y</code>：</p>
<ul>
<li>逻辑右移：左边补 0</li>
<li>算术右移：左边重复最高位</li>
<li>c 语言默认为算术右移，Java 用 <code>&gt;&gt;&gt;</code> 区分出逻辑右移</li>
</ul>
</li>
<li>
<p>当位移长度 &lt; 0 或 &gt; 字长时，为定义</p>
</li>
</ul>
<p>数字范围：</p>
<ul>
<li>无符号：UMin = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>=</mo><mn>000</mn><mo>…</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0 = 000…0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span></span></span></span>，UMax = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>w</mi></msup><mo>−</mo><mn>1</mn><mo>=</mo><mn>111...1</mn></mrow><annotation encoding="application/x-tex">2^w - 1 = 111...1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">1</span></span></span></span></li>
<li>补码：TMin = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mrow><mi>w</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><mn>100...0</mn></mrow><annotation encoding="application/x-tex">-2^{w-1} = 100...0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">0</span></span></span></span>，TMax = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>w</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn><mo>=</mo><mn>011...1</mn></mrow><annotation encoding="application/x-tex">2^{w-1}-1 = 011...1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">1</span></span></span></span></li>
</ul>
<p>其它值：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><mo>=</mo><mn>111...1</mn></mrow><annotation encoding="application/x-tex">-1 = 111...1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">1</span></span></span></span></p>
<p>编码整数：</p>
<ul>
<li>无符号：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mn>2</mn><mi>U</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>w</mi><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mi>x</mi><mi>i</mi></msub><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">B2U(X) = \sum_{i=0}^{w-1} x_i 2^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.253718em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.954008em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span></li>
<li>补码：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mn>2</mn><mi>T</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><msub><mi>x</mi><mrow><mi>w</mi><mo>−</mo><mn>1</mn></mrow></msub><msup><mn>2</mn><mrow><mi>w</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>w</mi><mo>−</mo><mn>2</mn></mrow></msubsup><msub><mi>x</mi><mi>i</mi></msub><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">B2T(X) = -x_{w-1} 2^{w-1} + \sum_{i=0}^{w-2} x_i 2^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0224389999999999em;vertical-align:-0.208331em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.253718em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.954008em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>w</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_{w-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 表示的是符号位，0 是非负数，1 是负数</li>
</ul>
<p>观察可以发现：</p>
<ul>
<li>|TMin| = TMax + 1</li>
<li>UMax = 2 * TMAX + 1</li>
</ul>
<p>两者之间转换时二进制表示不变，而是更换了解码方式，故</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%9C%89%E7%AC%A6%E5%8F%B7%E7%9A%84%E8%BD%AC%E6%8D%A2.webp" alt=""></p>
<p>在无符号和有符号整数同时出现在一个表达式（包括比较操作）时，有符号值隐式转化为无符号值</p>
<p>扩展：将 w 位的整数保持大小不变，扩展到 w + k 位</p>
<ul>
<li>
<p>无符号：加 0</p>
</li>
<li>
<p>有符号：重复 k 次符号位</p>
</li>
</ul>
<p>截断：</p>
<ul>
<li>无符号：模运算</li>
<li>有符号：类似于模运算</li>
</ul>
<p>无符号加法：忽略溢出，相当于 mod <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>w</mi></msup></mrow><annotation encoding="application/x-tex">2^w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span></span></span></p>
<p>有符号加法溢出会由正数变成负数，负数变成正数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E5%8A%A0%E6%B3%95.webp" alt=""></p>
<p>乘法同样只留下了 w 位，忽略多余的位</p>
<p>无符号：</p>
<ul>
<li>
<p>2 的次方乘法和位移：<code>u &lt;&lt; k</code> 相当于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>∗</mo><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">u * 2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<p>2 的次方除法和位移：<code>u &gt;&gt; k</code> 相当于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mi>u</mi><mi mathvariant="normal">/</mi><msup><mn>2</mn><mi>k</mi></msup><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">⌊ u / 2^k \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathnormal">u</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mclose">⌋</span></span></span></span>，使用逻辑位移</p>
</li>
</ul>
<p>每个机器都有一个给定的<strong>字长 word size</strong>，表示处理的最大内存范围，现在多为 64 位</p>
<p>多字节的单词在内存中的存放顺序分为大端 Big endian 和小端，名称来自格列佛游记</p>
<ul>
<li>大端（Sun，Internet）：最低位内存地址最大</li>
<li>小端（x86，ARM）：最低位内存地址最小</li>
</ul>
<h1 id="浮点-Floating-Point">浮点 Floating Point</h1>
<p>浮点右边的部分表示 2 的分数次幂</p>
<p>可以发现，只有形式为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi mathvariant="normal">/</mi><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">x/2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> 的数字可以精确表示</p>
<p>数字形式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>s</mi></msup><mi>M</mi><msup><mn>2</mn><mi>E</mi></msup></mrow><annotation encoding="application/x-tex">(-1)^sM2^E
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 决定数字是正数还是负数（所以会区分 +0 和 -0），且溢出不会变化符号</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 是<strong>尾码 significand</strong>，<em>通常</em>是表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1.0</mn><mo separator="true">,</mo><mn>2.0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1.0,2.0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 的分数值</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> 是二的幂次的值</li>
</ul>
<p>编码：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E6%B5%AE%E7%82%B9.webp" alt=""></p>
<p>注意：</p>
<ul>
<li>exp 编码 E，但与 E 有一些不同</li>
<li>frac 编码 M，但与 M 有一些不同</li>
</ul>
<p>单精度各部分的长度为：1 - 8 - 23，双精度：1 - 11 - 52</p>
<p>正常值（exp != 000…0 且 exp != 111…1）：</p>
<ul>
<li>阶码部分：E = exp - Bias，其中 Bias = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{k-1} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，其中 k 是指数位数（单精度 bias 为 127）</li>
<li>尾码部分有隐藏的 1：M = <a target="_blank" rel="noopener external nofollow noreferrer" href="http://1.xxx">1.xxx</a>…x，相当于白嫖了一个位</li>
</ul>
<p>非规格化：（exp = 000…0）</p>
<ul>
<li>指数：E = 1 - Bias</li>
<li>尾码部分有隐藏的 0：M = <a target="_blank" rel="noopener external nofollow noreferrer" href="http://0.xxx">0.xxx</a>…x</li>
<li>exp = 000…0，frac != 000…0 时表示接近 0 的数字，等间距</li>
</ul>
<p>特殊的值（exp = 111…1）</p>
<ul>
<li>exp = 111…1，frac = 000…0：无穷大或操作溢出，可正可负</li>
<li>exp = 111…1，frac = 000…0：没有数字 NaN</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E6%95%B0%E8%BD%B4%E4%B8%8A%E7%9A%84%E6%B5%AE%E7%82%B9.webp" alt="数轴上的浮点"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4.webp" alt=""></p>
<p>从这张表中可以看出为什么这么设计，实际上规格化和非规格化之间既实现了平滑过渡，又充分利用了每一位</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9C%A8%E6%95%B0%E8%BD%B4%E4%B8%8A1.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9C%A8%E6%95%B0%E8%BD%B4%E4%B8%8A2.webp" alt=""></p>
<p>结合两张图，不难看出浮点数的分布</p>
<p>在比较浮点时</p>
<ul>
<li>先比较符号位</li>
<li>考虑 -0 = +0</li>
<li>考虑 NaN</li>
<li>其余同无符号整数</li>
</ul>
<p>浮点计算：</p>
<ul>
<li>先计算确切值</li>
<li>将其化为要求的精度</li>
</ul>
<p><strong>圆整 rounding</strong>：默认为向最近的偶数取整，这样做没有偏向</p>
<p>浮点的乘法：</p>
<ul>
<li>符号：s1 ^ s2</li>
<li>尾码：M1 * M2</li>
<li>指数：E1 + E2</li>
<li>如果 M &gt;= 2，右移 M，增加 E</li>
<li>溢出</li>
<li>round M 以填入 frac 精度</li>
</ul>
<p>FP 加法/乘法的性质：</p>
<ul>
<li>可交换，但不可结合（尤其是大数和小数之间的运算）</li>
<li>几乎可以单调（除了溢出和 NaN）</li>
</ul>
<h1 id="机器层次编程-I：基础-Machine-Level-Programming-I-Basics">机器层次编程 I：基础 Machine-Level Programming I: Basics</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/C%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.webp" alt=""></p>
<p>反汇编：<code>objdump -d sum</code></p>
<p>x86-64 有 16 个寄存器</p>
<table>
<thead>
<tr>
<th>%rax</th>
<th>%rbx</th>
<th>%rcx</th>
<th>%rdx</th>
</tr>
</thead>
<tbody>
<tr>
<td>%rsi</td>
<td>%rdi</td>
<td>%rsp</td>
<td>%rbp</td>
</tr>
<tr>
<td>%r8</td>
<td>%r9</td>
<td>%r10</td>
<td>%r11</td>
</tr>
<tr>
<td>%r12</td>
<td>%r13</td>
<td>%r14</td>
<td>%r15</td>
</tr>
</tbody>
</table>
<p>因为历史原因，<code>r</code> 代表 64 位，<code>e</code> 代表 32 位，如 <code>%rax</code> 的另一个名字是 <code>%eax</code>，其只使用 <code>%rax</code> 的低 32 位</p>
<p>移动数据：<code>movq Source, Dest:</code></p>
<ul>
<li><strong>立即</strong>：整数常数，如 <code>$0x400</code>、<code>$-533</code></li>
<li><strong>寄存器</strong>：如 <code>%rax</code></li>
<li><strong>内存</strong>：用括号包围寄存器，如 <code>(%rax)</code>，表示 Mem[%rax]</li>
<li>不能操作两个内存</li>
</ul>
<p>内存寻址的一般模式：<code>D(Rb, Ri, S)</code> 表示 <code>Mem[Reg[Rb] + S*Reg[Ri] + D]</code></p>
<ul>
<li><code>D</code>：偏移常数字节</li>
<li><code>Rb</code>：基本寄存器</li>
<li><code>Ri</code>：索引寄存器</li>
<li><code>S</code>：缩放 1，2，4，8 倍</li>
</ul>
<p><code>leaq</code> 指令可以提供一个简单的计算方式，如 <code>leaq (%rdi, %rdi, 2), %rax</code> 计算了 <code>3 * %rdi</code> 并保存到 <code>%rax</code> 中</p>
<p>还有一些算术操作，注意操作 <code>op</code> 是 <code>dest = dest op src</code>，这种写法是 ATT 写法，而微软和 Intel 的写法是相反的</p>
<p>二元指令：</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>表示</th>
<th>名字</th>
<th>表示</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>addq</code></td>
<td>+</td>
<td><code>subq</code></td>
<td>-</td>
</tr>
<tr>
<td><code>imulq</code></td>
<td>*</td>
<td><code>salq</code> / <code>shlq</code></td>
<td>&lt;&lt;</td>
</tr>
<tr>
<td><code>sarq</code></td>
<td>算术 &gt;&gt;</td>
<td><code>shrq</code></td>
<td>逻辑 &gt;&gt;</td>
</tr>
<tr>
<td><code>xorq</code></td>
<td>^</td>
<td><code>andq</code></td>
<td>&amp;</td>
</tr>
<tr>
<td><code>orq</code></td>
<td>|</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>一元指令：</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>表示</th>
<th>名字</th>
<th>表示</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>incq</code></td>
<td>+1</td>
<td><code>decq</code></td>
<td>-1</td>
</tr>
<tr>
<td><code>negq</code></td>
<td>-</td>
<td><code>notq</code></td>
<td>~</td>
</tr>
</tbody>
</table>
<h1 id="机器层次编程-II：控制-Machine-Level-Programming-II-Control">机器层次编程 II：控制 Machine-Level Programming II: Control</h1>
<p>当前执行的程序的信息：</p>
<ul>
<li>临时数据：%rax…</li>
<li>运行栈的位置：%rsp</li>
<li>当前代码控制点的位置：%rip…</li>
<li>最近 test 的状态：CF，ZF，SF，OF</li>
</ul>
<p>单 bit 寄存器：</p>
<ul>
<li>CF：进位（无符号）</li>
<li>SF：符号</li>
<li>ZF：零</li>
<li>OF：溢出（有符号）</li>
</ul>
<p>显示设置这些位：<code>testq src2, src1</code>，相当于计算 <code>a &amp; b</code> 但没有指定目的地</p>
<p>setX 指令：基于条件代码设置目标的最低字节是 0 还是 1，不改变其它 7 个字节</p>
<ul>
<li>包括 <code>sete</code>，<code>setg</code>，…，注意 <code>seta</code> 是无符号整数的 &gt;，<code>setb</code> 是无符号整数的 &lt;，而 <code>setg</code> 是有符号整数的 &gt;</li>
</ul>
<p><code>movzbl</code> 将 32 位的数复制到 64 位的 dest 中，并将剩余 32 位用 0 补齐，当然还有其他字节之间的数据移动 + 填充的指令</p>
<p>jX 指令：基于条件代码跳转到代码的不同地方，包括 <code>jmp</code>，<code>jge</code> 等</p>
<p>条件表达式翻译（使用分支）：<code>val =  Test ? Then_Expr : Else_Expr</code> 转为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">	ntest = !Test;<br>	<span class="hljs-keyword">if</span> (ntest) <span class="hljs-keyword">goto</span> Else;<br>	val = Then_Expr;<br>    <span class="hljs-keyword">goto</span> Done;<br>Else:<br>	val = Else_Expr;<br>Done:<br>	...<br></code></pre></td></tr></table></figure>
<p>流水线：预测两个分支哪个更有可能发生，在判断条件时提前计算出该分支的结果</p>
<p><code>do-while</code> 比较简单：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">loop:<br>	body<br>    <span class="hljs-title function_">if</span> <span class="hljs-params">(Test)</span><br>        <span class="hljs-keyword">goto</span> loop<br></code></pre></td></tr></table></figure>
<p><code>while</code> 有两种方式实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 方法 1：跳转到中间的方法</span><br>	<span class="hljs-keyword">goto</span> test;<br>loop:<br>	Body<br>test:<br>	<span class="hljs-keyword">if</span> (Test)<br>        <span class="hljs-keyword">goto</span> loop;<br>done:<br><br><span class="hljs-comment">// 方法 2：转化为 do-while</span><br>	<span class="hljs-keyword">if</span> (!Test)<br>        <span class="hljs-keyword">goto</span> done;<br>loop:<br>	Body<br>    <span class="hljs-title function_">if</span> <span class="hljs-params">(Test)</span><br>        <span class="hljs-keyword">goto</span> loop;<br>done:<br></code></pre></td></tr></table></figure>
<p><code>for</code> 转化为 <code>while</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">Init;<br><span class="hljs-keyword">while</span> (Test) &#123;<br>    Body<br>    Update;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>switch</code> 语句相对于多重 if 的好处是创建了一张 Jump 表，能够快速定位到对应的代码块中，而不是依次遍历，这张表由编译器生成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">.L4<br>	.quad	.L8	# x = 0<br>	.quad	.L3	# x = 1<br>	.quad	.L5	# x = 2<br>	.quad	.L9	# x = 3<br>	.quad	.L8	# x = 4<br>	.quad	.L7	# x = 5<br>	.quad	.L7	# x = 6<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">switch_eg:<br>	movq	%rdx, %rcx<br>	cmpq	$6, %rdi	# x: 6<br>	ja		.L8			# 使用默认<br>	jmp		* .L4(, %rdi, 8) # goto *JTab[x]<br></code></pre></td></tr></table></figure>
<p>如果 switch 的分支范围特别大，如只有 0 和 1000，则会建立一个 if-else 树</p>
<h1 id="机器层次编程-III：程序-Machine-Level-Programming-III-Procedures">机器层次编程 III：程序 Machine-Level Programming III: Procedures</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E6%A0%88.webp" alt="x86的栈"></p>
<p>注意这里的栈口朝下，添加元素时栈顶的地址减小</p>
<p><code>pushq Src</code></p>
<ul>
<li>获取 <code>Src</code> 处的操作数</li>
<li>将 <code>%rsp</code> 减少 8</li>
<li>在 <code>%rsp</code> 的地址处写操作数</li>
</ul>
<p><code>popq Dest</code></p>
<ul>
<li>读 <code>%rsp</code> 所给地址处的值</li>
<li>将 <code>%rsp</code> 增加 8</li>
<li>在 <code>Dest</code>（必须是寄存器）处存放值</li>
</ul>
<p>过程控制流：</p>
<ul>
<li>调用：<code>call label</code>
<ul>
<li>将返回地址放入栈中</li>
<li>跳转到 label</li>
</ul>
</li>
<li>返回：<code>ret</code>
<ul>
<li>从栈中 pop 地址</li>
<li>跳到该地址</li>
</ul>
</li>
</ul>
<p>数据流：</p>
<ul>
<li>前 6 个参数放到 <code>%rdi</code>、<code>%rsi</code>、<code>rdx</code>、<code>rcx</code>、<code>r8</code>、<code>r9</code>，多出来的放到栈中</li>
<li>返回值在 <code>%rax</code> 中</li>
</ul>
<p>本地数据管理：栈在<strong>栈帧 frame</strong> 中分配</p>
<p>frame 内容：</p>
<ul>
<li>返回信息</li>
<li>本地存储</li>
<li>临时存储</li>
</ul>
<p>当进入程序时建立，返回时释放</p>
<p>寄存器保存惯例：</p>
<ul>
<li>caller：在 call 之前在它的 frame 中保存临时变量</li>
<li>callee：在使用之前它的 frame 中保存临时变量，在返回 caller 之前恢复</li>
</ul>
<p>该方法对于递归和相互调用都有效</p>
<h1 id="机器层次编程-IV：数据-Machine-Level-Programming-IV-Data">机器层次编程 IV：数据 Machine-Level Programming IV: Data</h1>
<p>数组 <code>T A[L]</code>：在内存中连续分配 <code>L * sizeof(T)</code> 个字节的区域</p>
<p>索引数组 <code>(%rdi, %rsi, 4)</code></p>
<ul>
<li><code>%rdi</code> 是数组名地址</li>
<li><code>%rsi</code> 是索引</li>
<li><code>4</code> 是每个基本元素的字节数</li>
</ul>
<p>多维数组 <code>A[i][j]</code> 的类型是 <code>T</code>，该类型需要 <code>K</code> 字节，故地址 <code>A + (i * C  + j) * K</code></p>
<p>注意对于一个已知大小的矩阵数组（如 <code>16 x 16</code>），则只需通过 <code>salq $6, %rsi</code> 移动获得索引，而如果编译时未知维度（如 <code>n x n</code>），则使用乘法 <code>imulq %rdx, %rdi</code> 获得索引</p>
<p>结构体要对齐数据：</p>
<ul>
<li>原始数据类型需要 K 字节，则其地址必须是 K 的整数倍</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%901.webp" alt=""></p>
<ul>
<li>最大的对齐需要 K，则整个结构体必须是 K 的整数倍</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%902.webp" alt=""></p>
<p>为了节省空间，可以把大的数据类型放前面，这种贪心策略是最优的</p>
<p>对于浮点数，用 XMM0-15 的寄存器存储和传递参数，有专门的浮点运算指令</p>
<h1 id="机器层次编程-V：进阶主题-Machine-Level-Programming-V-Advanced-Topics">机器层次编程 V：进阶主题 Machine-Level Programming V: Advanced Topics</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.webp" alt="内存布局"></p>
<p>当堆中需求的内存过大时，会从上面往下开辟堆空间</p>
<p>缓冲区溢出，如 <code>gets</code>，可能覆盖下面的 <code>ret</code> 命令，使其跳转到自己想要执行的程序</p>
<p><strong>蠕虫 Worm</strong>：</p>
<ul>
<li>可以自己运行</li>
<li>可以向其它电脑复制一份完全工作的自己</li>
</ul>
<p><strong>病毒 Virus</strong>：</p>
<ul>
<li>把自己添加到其它程序中</li>
<li>不能独立运行</li>
</ul>
<p>解决方法：</p>
<ul>
<li>避免代码中的溢出问题，如使用 <code>fgets</code> 代替 <code>gets</code></li>
<li>系统级别的防护，如随机化栈的偏移，给不同的段加上可读、可写、可执行的权限</li>
<li>使用金丝雀，即在缓冲区中放上一个随机的数，检查执行完函数后改数字是否改变</li>
</ul>
<p>联合体 Union 是将不同的类型合并占用</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/union.webp" alt=""></p>
<h1 id="程序优化-Program-Optimization">程序优化 Program Optimization</h1>
<p>通用方法：</p>
<p>代码移动：减少计算次数，尤其是在循环中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> j;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>    a[n*i+j] = b[j];<br><br><span class="hljs-comment">// 改为</span><br><span class="hljs-type">long</span> j;<br><span class="hljs-type">int</span> ni = n * i;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>    a[ni+j] = b[j];<br></code></pre></td></tr></table></figure>
<p>事实上，如果使用了 <code>-O1</code> 优化，则编译生成了代码就使用了类似的原理</p>
<p>将花费多的操作换成更简单的，如将 <code>*4</code> 换成 <code>&lt;&lt;2</code></p>
<p>共享共同的子表达式，如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">(i<span class="hljs-number">-1</span>)*n + j;<br>(i+<span class="hljs-number">1</span>)*n + j;<br>i*n + j<span class="hljs-number">-1</span>;<br>i*n + j+<span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 改成</span><br><span class="hljs-type">long</span> inj = i*n + j;<br>inj - n;<br>inj + n;<br>inj - <span class="hljs-number">1</span>;<br>inj + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>
<p>过程调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(s); i++)<br>    <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>)<br>        s[i] -= (<span class="hljs-string">&#x27;A&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p>该算法是二次的，因为重复调用了 <code>strlen(s)</code>，这个方法是线性的，所以应该改成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> i;<br><span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strlen</span>(s);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>    <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>)<br>        s[i] -= (<span class="hljs-string">&#x27;A&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p>而编译器一般不会优化这点，是因为</p>
<ul>
<li>过程可能有副作用</li>
<li>函数可能会对给定参数返回不同的值（修改了 <code>s[i]</code>）</li>
</ul>
<p>解决方法：</p>
<ul>
<li>使用<strong>内联 inline</strong> 函数（gcc -O1 会这么做）（只能在单个文件中）</li>
<li>手动移动代码</li>
</ul>
<p>内存很重要：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    b[i] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>        b[i] += a[i*n + j];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从汇编代码中可以看出，编译器在每次循环中都从内存中取出 <code>b[i]</code> 放到寄存器中，计算完再放回去，因为其无法确定修改了 <code>b[i]</code> 会不会影响 <code>a[i]</code>，即两个数组使用了相同的内存。故应修改为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-type">double</span> val = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>        val += a[i*n + j];<br>    b[i] = val;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>每个元素的循环 Cycles Per Element(CPE)</strong>：用来表达对 list 的效率</p>
<p>T = CPE*n + Overhead</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">combine1</span><span class="hljs-params">(vec_ptr v, <span class="hljs-type">data_t</span> *dest)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">int</span> i;<br>    *dest = IDENT;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; vec_length(v); i++) &#123;<br>        <span class="hljs-type">data_t</span> val;<br>        get_vec_element(v, i, &amp;val);<br>        *dest = *dest OP val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>基础的优化：</p>
<ul>
<li>减少对 <code>vec_length(v)</code> 的调用</li>
<li>避免在每轮循环中 <code>get_vec_element</code> 检查越界</li>
<li>临时计算</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">combine4</span><span class="hljs-params">(vec_ptr v, <span class="hljs-type">data_t</span> *dest)</span> &#123;<br>    <span class="hljs-type">long</span> i;<br>    <span class="hljs-type">long</span> length = vec_length(v);<br>    <span class="hljs-type">data_t</span> *d = get_vec_start(v);<br>    <span class="hljs-type">data_t</span> t = IDENT;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; i++)<br>        t = t OP d[i];<br>    *dest = t;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>该优化立刻提升了许多倍速度，但似乎受到了一些限制，原因是 CPU 在执行每个操作时都有“读取-计算-存入”的操作，每个阶段都会花费一些时间</p>
<p>很多现代的 CPU 都支持<strong>流水线 pipeline</strong>，即在一个循环中同时处理多条指令，基本思想是在某计算执行到 stage2 时，执行下一个不依赖于该指令结果的指令于 stage1，以此类推</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/combine4.webp" alt="combine4"></p>
<p>效率由延迟决定</p>
<p>循环展开（2*1）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> limit = length - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; limit; i += <span class="hljs-number">2</span>)<br>    x = x (d[i] OP d[i+<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">for</span> (; i &lt; length; i++)<br>    x = x OP d[i];<br>*dest = x;<br></code></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80%EF%BC%882x1%EF%BC%89.webp" alt="循环展开（2x1）"></p>
<p>可以发现延迟短了一半</p>
<p>另一种展开方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">data_t</span> x0 = IDENT;<br><span class="hljs-type">data_t</span> x1 = IDENT;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; limit; i += <span class="hljs-number">2</span>) &#123;<br>    x0 = x0 OP d[i];<br>    x1 = x1 OP d[i+<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">for</span> (; i &lt; length; i++)<br>    x0 = x0 OP d[i];<br>*dest = x0 OP x1;<br></code></pre></td></tr></table></figure>
<p>如果使用计算浮点数的硬件，可以一次计算多个整数的加法或乘法，且 ymm 寄存器通常并不在使用</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/SIMD%E6%93%8D%E4%BD%9C.webp" alt="SIMD操作"></p>
<p>对于分支，会猜测执行哪个分支，并优先执行该分支的内容，正确率 &gt;90%</p>
<h1 id="内存层次结构-The-Memory-Hierarchy">内存层次结构 The Memory Hierarchy</h1>
<p>内存有两类：</p>
<ul>
<li>SRAM（较快、贵，通常用于 cache）</li>
<li>DRAM（比 SRAM 慢、便宜，用于主要的内存、frame buffer）</li>
</ul>
<p>这两者断点都会丢失消息</p>
<p>非易失性 memory：</p>
<ul>
<li>ROM：只读存储器</li>
<li>PROM：可编程 ROM</li>
<li>EPROM：可大容量擦除 PROM</li>
<li>EEPROM：电子 EPROM</li>
<li>闪存 EEPROMs：部分（block 级）可删除</li>
<li>通常用于磁盘</li>
</ul>
<p><strong>总线 bus</strong> 是一堆能传递地址、数据、控制信号的线，被多个设备共用</p>
<ul>
<li><strong>磁盘 disk</strong> 由<strong>盘片 platters</strong> 组成，每个有两个<strong>表面 surfaces</strong></li>
<li>每个 surface 由多个叫<strong>磁道 tracks</strong> 的同心圆组成</li>
<li>每个 track 由被<strong>空隙 gaps</strong> 分割的<strong>扇区 sectors</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E7%A3%81%E7%9B%98%E5%87%A0%E4%BD%95%E7%BB%93%E6%9E%84.webp" alt="磁盘几何结构"></p>
<p>从多个 platter 来看，多个对齐的 track 形成一个圆柱</p>
<p>磁盘容量 = (# bytes/sector) _ (avg. # sectors/tracks) _ (# tracks/surfaces) _ (# surfaces/platter) _ (platters/disk)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E7%A3%81%E7%9B%98%E6%93%8D%E4%BD%9C.webp" alt="磁盘操作"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E7%A3%81%E7%9B%98%E8%AE%BF%E9%97%AE.webp" alt="磁盘访问"></p>
<p>Taccess = Tavg seek + Tavg rotation + Tavg transfer</p>
<p>其中 Tavg seek 被物理因素限制，无法提升，其余两个可以通过磁盘转速提升</p>
<p>逻辑硬盘块：</p>
<ul>
<li>硬件设备硬盘控制器将逻辑块（0,1,2…）映射到实际扇区中</li>
<li>有一些备用圆柱面，当一些扇区损坏时，可以将损坏扇区的逻辑块映射给备用柱面，实现硬盘坏了但没有完全坏</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/IO%E6%80%BB%E7%BA%BF.webp" alt="IO总线"></p>
<p><strong>固态硬盘 Solid State Disk(SSDs)</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98.webp" alt="固态硬盘"></p>
<ul>
<li>页：512KB 到 4KB，块：32 到 128 页</li>
<li>必须以页为单位读写数据</li>
<li>只有在整个块被擦除时，页才能被写入</li>
<li>一个块在大约 100000 次写入后失效</li>
</ul>
<p>所以顺序读写会比随机读写快很多</p>
<p>我们可以观察到，SRAM,DRAM,SSD,Disk 的速度有显著的差距（价格也是），为了以更低的价格获得更快的速度，需要架起桥梁</p>
<p><strong>局部性 locality</strong>：程序倾向使用靠近或等于最近使用的数据或指令</p>
<ul>
<li>时间：最近引用的物品更可能在不久的将来再次引用</li>
<li>空间：地址相近的物品倾向于一起被引用</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; M; i++)<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; N; j++)<br>        sum += a[i][j];<br></code></pre></td></tr></table></figure>
<p>该程序有良好的局部性，若将 i，j 的循环顺序颠倒，则速度大幅下降</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E5%86%85%E5%AD%98%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.webp" alt="内存层次结构"></p>
<p><strong>缓存 cache</strong>：一个更小、更快的存储设备，充当暂存</p>
<p>程序倾向于使用 k 层中的数据，而不是 k+1 层的数据</p>
<p>如果成功使用了 cache 中的内容，则称为<strong>缓存命中 cache hit</strong>；反之，则为 <strong>miss</strong></p>
<h1 id="缓存内存-Cache-Memories">缓存内存 Cache Memories</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E4%B8%80%E8%88%AC%E7%BC%93%E5%AD%98%E7%BB%84%E7%BB%87.webp" alt="一般缓存组织"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E5%AD%97%E5%9C%B0%E5%9D%80.webp" alt="字地址"></p>
<p>读操作：靠索引获取 set 位置，比较 tag，若不同，则 miss，查找下一级内存；若相同，则 hit，使用该 cache 中的内容</p>
<p>写：</p>
<ul>
<li>hit：将写回内存的时间推迟到这里的内容被覆盖（需要一个<strong>脏位 dirty bit</strong>），类似于线段树的 tag 标记</li>
<li>miss：载入到 cache 中，更新 cache 的内容</li>
</ul>
<p>所以</p>
<ul>
<li>对变量的重复引用是好的（temporal locality）</li>
<li>步伐为 1 的模式是好的（spatial locality）</li>
</ul>
<p>内存山：考虑到 spatial 和 temporal locality 的内容 read through</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E5%86%85%E5%AD%98%E5%B1%B1.webp" alt="内存山"></p>
<p>对于矩阵乘法，分别计算三种循环方式</p>
<ul>
<li>ijk 每次迭代的 miss 为 1.25</li>
<li>kij 为 0.5</li>
<li>ikj 为 2.0</li>
</ul>
<p>故以下代码是最优的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; n; k++)<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        r = a[i][k];<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            c[i][j] += r * b[k][j];<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>分块矩阵乘法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i, j, k;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i+=B)<br>	<span class="hljs-keyword">for</span> (j=<span class="hljs-number">0</span>;j&lt;n;j+=B)<br>		<span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;n;k+=B)<br>			<span class="hljs-comment">/* B x B mini matrix multiplications */</span><br>			<span class="hljs-keyword">for</span> (il=i;il&lt;i+B;i++)<br>				<span class="hljs-keyword">for</span> (jl = j; jl &lt; j+B; j++)<br>					<span class="hljs-keyword">for</span> (k1=k;k1&lt;k+B;k++)<br>						c[il*n + j1] += a[il*n + k1] * b[k1*n + j1];<br></code></pre></td></tr></table></figure>
<p>通过计算可以得到</p>
<ul>
<li>不使用分块 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>9</mn><mi mathvariant="normal">/</mi><mn>8</mn><mo stretchy="false">)</mo><mo>∗</mo><msup><mi>n</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">(9/8)*n^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">9</span><span class="mord">/</span><span class="mord">8</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></li>
<li>使用分块 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mn>4</mn><mi>B</mi><mo stretchy="false">)</mo><mo>∗</mo><msup><mi>n</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">1/(4B) * n^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mopen">(</span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></li>
</ul>
<p>似乎 B 越大越好，但有限制 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><msup><mi>B</mi><mn>2</mn></msup><mo>&lt;</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">3B^2 &lt; C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.853208em;vertical-align:-0.0391em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></p>
<p>因为矩阵乘法有固有的局部性，输入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">3n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>，输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">2n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>，必然有数据重复使用</p>
<h1 id="链接-Linking">链接 Linking</h1>
<p>多个 .o 文件通过<strong>链接器 linker</strong> 链接在一起</p>
<p>链接器的优点：</p>
<ul>
<li>模块化</li>
<li>高效。时间上：无需重新编译其他文件；空间上：常用函数不必包含于每个文件中</li>
</ul>
<p>链接器的用途：</p>
<ul>
<li><strong>符号解析 symbol resolution</strong>：将每个符号引用与一个符号定义关联</li>
<li><strong>重定向 relocation</strong>：将数据和代码分割到不同的段中，重定向符号的关联位置，更新所有对符号的引用</li>
</ul>
<p>三种对象文件：</p>
<ul>
<li><strong>重定向</strong>对象文件（.o 文件）</li>
<li><strong>可执行</strong>对象文件（a.out 文件）</li>
<li><strong>共享</strong>对象文件（.so 文件），Windows 中的 DLL 文件</li>
</ul>
<p>这三者都使用了 <strong>ELF (Executable and Linkable)</strong> 格式</p>
<ul>
<li>头</li>
<li>段头表 segment header table</li>
<li>.text 段：代码</li>
<li>.rodata 段：只读数据，如 jump table</li>
<li>.data 段：初始化全局变量</li>
<li>.bss 段：未初始化的全局变量，理由是 “better save space”</li>
<li>.symtab 段：符号表，过程和静态变量名，段名和位置</li>
<li>.rel.text 段：.text 段的重定位消息，需要被修改的指令地址</li>
<li>.rel.data 段：.data 段的重定位消息</li>
<li>.debug 段：符号调试的信息，gcc -g</li>
<li>段头表 section header table：每个段的偏移和大小</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/ELF%E7%BB%93%E6%9E%84.webp" alt="ELF结构"></p>
<p>链接器符号：</p>
<ul>
<li><strong>全局</strong>符号，如非 static 函数和非 static 全局变量</li>
<li><strong>外部</strong>符号，定义在其他模块，被模块 m 引用的全局变量</li>
<li><strong>局部</strong>符号，被模块 m 定义和引用的符号，如使用 static 的函数和全局变量，<em>注意局部链接器符号不是局部程序变量</em></li>
</ul>
<p>程序符号有 <strong>strong</strong> 和 <strong>weak</strong> 之分：</p>
<ul>
<li>strong：过程和初始化的全局变量</li>
<li>weak：未初始化的全局</li>
</ul>
<p>符号规则：</p>
<ul>
<li>不允许多个强符号</li>
<li>如果有一个强符号和多个弱符号，使用强符号</li>
<li>如果有多个弱符号，任选一个</li>
</ul>
<p>所以为了防止这种冲突覆盖发生，可以：</p>
<ul>
<li>使用 <code>static</code></li>
<li>定义全局变量时初始化</li>
<li>引用外部全局变量时使用 <code>extern</code></li>
</ul>
<p>链接时多个可重定位对象文件的各个段组合到一个可执行对象文件的一个段中：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E9%87%8D%E5%AE%9A%E4%BD%8D.webp" alt="重定位"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%A3%85%E8%BD%BD.webp" alt="装载"></p>
<p>静态库：(.a archive files)使用索引将相关的可重定位文件合并到一个文件中</p>
<p>这样做允许增量更新，只需要重新编译 archive 中改变和替换 .o 文件</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E9%9D%99%E6%80%81%E5%BA%93.webp" alt="静态库"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5.webp" alt="静态链接"></p>
<p>共享库（DLL，.so 文件）：可以动态将代码和数据装载并链接到应用程序中，<em>装载时间和运行时间都可以</em></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%A3%85%E8%BD%BD%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.webp" alt="装载时动态链接"></p>
<p>运行时动态链接：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">void</span>  *handle;<br>    <span class="hljs-type">void</span> (*addvec)(<span class="hljs-type">int</span> *, <span class="hljs-type">int</span> *, <span class="hljs-type">int</span> *, <span class="hljs-type">int</span>);<br>    <span class="hljs-type">char</span> *error;<br>    <span class="hljs-comment">/* 动态装载包含 addvec 的共享库 */</span><br>    handle = dlopen(<span class="hljs-string">&quot;./libvector.so&quot;</span>, RTLD_LAZY);<br>    <span class="hljs-keyword">if</span> (!handle) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s\n&quot;</span>, dlerror());<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* 获取指向 addvec() 函数的指针 */</span><br>    addvec = dlsym(handle, <span class="hljs-string">&quot;addvec&quot;</span>);<br>    <span class="hljs-keyword">if</span> ((error = dlerror()) != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* 调用 addvec() */</span><br>    addvec(x, y, z, <span class="hljs-number">2</span>);<br>    <span class="hljs-comment">/* 卸载共享库 */</span><br>    <span class="hljs-keyword">if</span> (dlclose(handle) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>库插入 Library Interpositioning：拦截对任意函数的调用，同样可以发生在编译、链接、装载、运行时</p>
<p>可用于安全、调试、监视和追踪等</p>
<p>编译时拦截：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gcc -Wall -DCOMPILETIME -c mymalloc.c<br>gcc -Wall -I. -o intc int.c mymallo.c<br></code></pre></td></tr></table></figure>
<p>链接时拦截：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gcc -Wall -DLINKTIME -c mymalloc.c<br>gcc -Wall -c int.c<br>gcc -Wall -Wl,--wrap,malloc -Wl,--wrap,free -o intl<br></code></pre></td></tr></table></figure>
<ul>
<li><code>-Wl</code> 向链接器传递参数</li>
<li><code>--wrap,malloc</code> 表示对 <code>malloc</code> 的引用替换为 <code>__wrap_malloc</code>，对 <code>__real_malloc</code> 的引用替换为 <code>malloc</code></li>
</ul>
<p>运行时拦截：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gcc -Wall -DRUNTIME -shared -fpic -o mymalloc.so mymalloc.c -ldl<br>gcc -Wall -o intr int.c<br>(LD_PRELOAD=&quot;./mymalloc.so&quot; ./intr)<br></code></pre></td></tr></table></figure>
<p><code>LD_PRELOAD</code> 环境变量告诉动态链接器先查看 <code>mymalloc.so</code> 寻找未解决的引用，如 <code>malloc</code></p>
<h1 id="异常控制流：异常和进程-Exceptional-Control-Flow-Exceptions-and-Processes">异常控制流：异常和进程 Exceptional Control Flow: Exceptions and Processes</h1>
<p>一般来说，CPU 按顺序依次执行指令</p>
<p>有两种改变控制流的方法：</p>
<ul>
<li>程序状态：
<ul>
<li>跳跃和分支</li>
<li>调用和返回</li>
</ul>
</li>
<li>但还有系统状态：
<ul>
<li>Ctrl - C</li>
<li>除零</li>
</ul>
</li>
</ul>
<p>即<strong>异常控制流 Exceptional Control Flow（ECF）</strong></p>
<p>其存在于计算机系统的所有层次：</p>
<ul>
<li>低层次：
<ul>
<li>异常 Exception</li>
</ul>
</li>
<li>高层次：
<ul>
<li>过程上下文切换 Process context switch</li>
<li>信号 Signal</li>
<li>非本地跳跃 Nonlocal jumps</li>
</ul>
</li>
</ul>
<p>异常是为了响应一些事件，将控制转移给<strong>操作系统内核 OS kernel</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E5%BC%82%E5%B8%B8.webp" alt=""></p>
<p><strong>异常表 Exception Tables</strong>：每个事件都有一个独有的异常号 k</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E5%BC%82%E5%B8%B8%E8%A1%A8.webp" alt=""></p>
<p>异常分类：</p>
<ul>
<li>异步异常 asynchronous
<ul>
<li><strong>打断 interrupt</strong>
<ul>
<li>由处理器的 interrupt pin 指示</li>
<li>返回到 next 指令</li>
<li>计时器中断/外部设备 IO</li>
</ul>
</li>
</ul>
</li>
<li>同步异常 synchronous
<ul>
<li><strong>陷阱 trap</strong>
<ul>
<li>返回到 next</li>
<li>system call</li>
</ul>
</li>
<li><strong>错误 fault</strong>
<ul>
<li>可能重新执行或终止</li>
<li>页错误 page fault（可恢复），保护错误 protection fault（不可恢复）</li>
</ul>
</li>
<li><strong>终止 abort</strong>
<ul>
<li>终止当前程序</li>
<li>错误指令</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>进程 process</strong>：一个运行着的程序的实例*（注意不同于<strong>程序 program</strong> 和<strong>处理器 processor</strong>）*</p>
<p>进程为每个程序提供了两个关键的抽象：</p>
<ul>
<li>逻辑控制流
<ul>
<li>每个程序似乎可以利用整个 CPU</li>
<li>由<strong>上下文切换 context switch</strong> 实现</li>
</ul>
</li>
<li>私有地址空间
<ul>
<li>每个程序似乎可以利用整个内存</li>
<li>由<strong>虚拟内存 virtual memory</strong> 提供</li>
</ul>
</li>
</ul>
<p><strong>并发过程 concurrent process</strong>：两个过程的流在时间上有重叠</p>
<p>否则称为<strong>顺序 sequential</strong></p>
<p>过程由内存中的 OS 代码叫做<strong>内核 kernel</strong> 的东西管理</p>
<p><em>内核不是一个单独的进程，而是作为某个存在的进程运行</em></p>
<p>从一个过程到另一个的控制流切换通过<strong>上下文切换 context switch</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2.webp" alt=""></p>
<p>系统调用：Linux 系统函数如果出错，通常返回 -1 并设置全局变量 errno 来指示原因</p>
<p>法则：对于每个系统级函数都必须检查返回值，如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((pid = fork()) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fork error: %s\n&quot;</span>, strerror(errno));<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>为了简化代码，可以使用 Stevens 风格的错误处理包装函数，如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">pid_t</span> <span class="hljs-title function_">Fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">pid_t</span> pid;<br><br>    <span class="hljs-keyword">if</span> ((pid = fork()) &lt; <span class="hljs-number">0</span>)<br>        unix_error(<span class="hljs-string">&quot;Fork error&quot;</span>);<br>    <span class="hljs-keyword">return</span> pid;<br>&#125;<br><br>pid = Fork();<br></code></pre></td></tr></table></figure>
<p>获取进程 ID：</p>
<ul>
<li><code>pid_t getpid(void)</code> 返回当前进程 PID</li>
<li><code>pid_t getppid(void)</code> 返回父进程 PID</li>
</ul>
<p>进程有三种状态：</p>
<ul>
<li><strong>运行中 running</strong>：在执行、等待执行、将会被<strong>安排 schedule</strong></li>
<li><strong>停止 stopped</strong>：被<strong>暂停 suspended</strong>，直到信号到来不会被安排</li>
<li><strong>终止 terminated</strong></li>
</ul>
<p>进程终止的原因：</p>
<ul>
<li>结束到信号</li>
<li>从 <code>main</code> 过程返回</li>
<li>调用 <code>exit</code> 函数（调用一次，不返回）</li>
</ul>
<p>创建进程：<code>int fork(void)</code></p>
<ul>
<li>对于子进程返回 0，对于父进程返回子进程的 PID（调用一次，返回两次）</li>
<li>子进程和父进程几乎相同：
<ul>
<li>复制了虚拟内存地址</li>
<li>复制了打开的文件描述符</li>
<li>和父进程的 PID 不同</li>
</ul>
</li>
</ul>
<p>fork：</p>
<ul>
<li>并发执行</li>
<li>重复但独立的地址空间</li>
<li>共享打开的文件</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E5%9B%BE.webp" alt="进程图"></p>
<p>每个进程图的拓扑序都是一个可行的顺序</p>
<p>收割子进程：当进程终止时，仍消耗系统资源，被称作<strong>僵尸</strong></p>
<ul>
<li>由父进程对终止的子进程使用（用 <code>wait</code> 和 <code>waitpid</code>）</li>
<li>父进程被提供退出状态信息</li>
<li>内核删除僵尸子进程</li>
</ul>
<p>如果有父进程在没有收割子进程就终止了，则该子进程会被 <code>init</code> （pid = 1）的进程收割。但在长时间运行的进程还是需要显示收割</p>
<p><code>int wait(int *child_status)</code></p>
<ul>
<li>暂停直到一个它的子进程终止</li>
<li>返回终止的子进程的 PID</li>
<li><code>child_status</code> 指向的整数会被设为一个值指示子进程终止的原因和退出状态
<ul>
<li>可以使用 <code>wait.h</code> 中定义的宏检查，包括 <code>WIFEXITED</code>、<code>WEXITSTATIS</code>等</li>
</ul>
</li>
</ul>
<p><code>pid_t waitpid(pid_t pid, int &amp;status, int options)</code> 等待一个指定的进程</p>
<p><code>int execve(char *filename, char *argv[], char *envp[])</code></p>
<ul>
<li>装载并在当前进程中执行</li>
<li><code>argv[0] == filename</code></li>
<li>调用一次，无返回</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E6%96%B0%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%A7%8B%E7%9A%84%E6%A0%88.webp" alt="新程序开始的栈"></p>
<h1 id="异常控制流：信号和非本地跳转-Exceptional-Control-Flow-Signals-and-Nonlocal-Jumps">异常控制流：信号和非本地跳转 Exceptional Control Flow: Signals and Nonlocal Jumps</h1>
<p><strong>信号 signal</strong> 是通知一个进程某事件发生了的小信息</p>
<ul>
<li>由小整数 ID（1-30）识别</li>
<li>唯一的信息是它的 ID 和它抵达的事实</li>
</ul>
<table>
<thead>
<tr>
<th>ID</th>
<th>名字</th>
<th>默认动作</th>
<th>对应事件</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>终止</td>
<td>键入 ctrl-c</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>终止</td>
<td>杀死程序（不可重载或忽略）</td>
</tr>
<tr>
<td>17</td>
<td>SIGCHLD</td>
<td>忽略</td>
<td>子进程停止或终止了</td>
</tr>
</tbody>
</table>
<p>一些对信号的反应：</p>
<ul>
<li>忽略 ignore</li>
<li>终止进程</li>
<li>用执行用户级别的<strong>信号处理器 signal handler</strong> 捕捉信号（类似与硬件级别的）</li>
</ul>
<p>如果一个信号被发送了但还没有被接收，则称为<strong>待定 pending</strong></p>
<p><strong>注意：信号不会排队，即有一个待定的类型 k 的信号，则接下来的所有类型为 k 的信号都被忽略</strong></p>
<p>进程可以<strong>阻塞 block</strong> 特定信号的接收</p>
<ul>
<li>被阻塞的信号可以发送，但直到被解除阻塞前都不会被接收</li>
</ul>
<p>内核在每个进程的上下文中维持了 pending 和 blocked 位向量，用第 k 位表示</p>
<p>每个进程属于一个进程组</p>
<ul>
<li><code>getpgrp()</code> 返回当前进程组</li>
<li><code>setpgid()</code> 改变当前进程组 ID</li>
</ul>
<p>正数表示对某个进程操作，负数表示对某个进程组操作</p>
<p>键入 <kbd>Ctrl</kbd> + <kbd>C</kbd> 表示对每个前台的进程组发送 SIGINT 信号</p>
<p>内核计算 <code>pnb = pending &amp; ~blocked</code></p>
<ul>
<li>如果 <code>pnb == 0</code> 则执行下一条指令</li>
<li>反之选择 <code>pnb</code> 中最小的非零位，并执行相关的信号开关</li>
</ul>
<p><code>handler_t *signal(int signum, handler_t *handler)</code> 修改信号 <code>signum</code> 的默认接收行为</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81.webp" alt="信号处理器的控制流"></p>
<p>隐式阻塞信号：内核阻塞任何当前处理的同类型的信号</p>
<p>显式阻塞：<code>sigprocmask</code> 函数</p>
<p>相关函数：</p>
<ul>
<li><code>sigemptyset</code>：创建一个空集合</li>
<li><code>sigfillset</code>：把每个信号数字加入到集合中</li>
<li><code>sigaddset</code>：把信号数字加入到集合中</li>
<li><code>sigdelset</code>：从集合中删除信号数字</li>
</ul>
<p>安全的信号处理器的设计原则：</p>
<ul>
<li>保持处理器尽可能简单</li>
<li>只调用<strong>异步信号安全 async-signal-safe</strong> 的函数</li>
<li>在进入和退出时保存和恢复 <code>errno</code></li>
<li>通过阻塞所有信号保护共享的数据结构的访问</li>
<li>声明全局变量为 volatile，以防止编译器将其储存在寄存器中</li>
<li>声明全局标识符为 volatile sig_atomicity</li>
</ul>
<p>显式等待信号：<code>int sigsuspend(const sigset_t *mask)</code></p>
<p>非本地跳转：</p>
<ul>
<li>
<p><code>int setjmp(jmp_buf env)</code> 在 <code>env</code> buffer 中保存当前调用环境；返回值不可赋值给一个变量，但可以用在 <code>switch</code> 中</p>
</li>
<li>
<p><code>void longjmp(jmp_buf env, int retval)</code> 从 <code>env</code> 中恢复调用环境并跳转到最近一次 <code>setjmp</code> 调用，然后 <code>setjmp</code> 以 <code>retval</code> 返回</p>
</li>
</ul>
<p>应用：</p>
<ul>
<li>从多重函数中跳转</li>
<li>让信号处理器能够跳转到其它指令而不是返回下一条指令</li>
</ul>
<h1 id="系统层次输入-输出-System-Level-I-O">系统层次输入/输出 System-Level I/O</h1>
<p><strong>文件 file</strong> 是字节序列</p>
<ul>
<li>所有的 I/O 设备都被表示为文件</li>
<li>内核也被表示为文件</li>
</ul>
<p>Unix I/O 接口：</p>
<ul>
<li>打开和关闭文件：<code>open()</code> 和 <code>close()</code></li>
<li>读和写文件：<code>read()</code> 和 <code>write</code></li>
<li>改变当前文件位置（seek）：<code>lseek()</code></li>
</ul>
<p>文件类型：</p>
<ul>
<li>一般文件 regular file</li>
<li>目录 directory</li>
<li>套接字 socket</li>
</ul>
<p>一般文件：</p>
<ul>
<li>应用程序往往区分为<strong>文本文件</strong>和<strong>二进制文件</strong>，但内核不区分</li>
<li>文本文件由文本行组成，EOL 在 Windows 和 Internet 协议中使用 ‘\r\n’(0xd 0xa)(CRLF)，在 Linux 和 Mac OS 中使用 ‘\n’(0xa)(LF)</li>
</ul>
<p>目录：由许多<strong>链接 link</strong> 组成</p>
<ul>
<li><code>.</code> 指向它自己的链接</li>
<li><code>..</code> 父目录的链接</li>
</ul>
<p>打开文件：<code>fd = open(&quot;/etc/hosts&quot;, O_RDONLY)</code></p>
<p>返回一个<strong>文件描述符 file descriptor</strong></p>
<ul>
<li>若为 -1，则出错</li>
<li>0：stdin</li>
<li>1：stdout</li>
<li>2：stderr</li>
</ul>
<p>关闭文件：<code>retval = close(fd)</code></p>
<p>在多线程程序中关闭一个已经关闭的文件会出错</p>
<p>读文件：<code>nbytes = write(fd, buf, sizeof(buf))</code></p>
<p>返回写入 buf 的字节数</p>
<p><strong>短计数 short count</strong> 通常出现在</p>
<ul>
<li>遇到 EOF</li>
<li>从终端读文本行</li>
<li>读写网络套接字</li>
</ul>
<p>RIO 是更<strong>健壮 robust</strong> 的 I/O 包装，用于网络程序，提供两种类型的函数：</p>
<ul>
<li>无缓冲的二进制数据：<code>rio_readn</code> 和 <code>rio_writen</code></li>
<li>有缓冲的文本和二进制数据：<code>rio_readlineb</code> 和 <code>rio_readnb</code>
<ul>
<li>线程安全，可以在相同文件上任意交错</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E6%9C%89%E7%BC%93%E5%86%B2%E7%9A%84IO%E5%AE%9E%E7%8E%B0.webp" alt="有缓冲的IO实现"></p>
<p><strong>元数据 metadata</strong> 是数据的数据，通过 <code>stat</code> 和 <code>fstat</code> 函数访问</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80.webp" alt="文件打开"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB.webp" alt="文件共享"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E6%96%87%E4%BB%B6fork.webp" alt="文件fork"></p>
<p>I/O 重定向：<code>ls &gt; foo.txt</code> 使用了函数 <code>dup2(oldfd, newfd)</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/IO%E9%87%8D%E5%AE%9A%E5%90%91.webp" alt="IO重定向"></p>
<p>C 语言提供了标准 I/O 函数：</p>
<ul>
<li>打开和关闭文件：<code>fopen</code> 和 <code>fclose</code></li>
<li>读和写二进制文件：<code>fread</code> 和 <code>fwrite</code></li>
<li>读和写文本文件：fgets<code>和</code>fputs`</li>
<li>格式化读和写：<code>fscanf</code> 和 <code>fprintf</code></li>
</ul>
<p>其中使用了 buffer，一般遇到 <code>\n</code> 时自动<strong>刷新 flush</strong>，也可以使用 <code>fflush(fd)</code> 手动 flush</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E4%B8%89%E7%A7%8DIO%E6%96%B9%E5%BC%8F.webp" alt="三种IO方式"></p>
<p>一般来说使用标准 IO 即可，在使用网络时使用 RIO，在信号处理器中使用 Unix IO</p>
<h1 id="虚拟内存：概念-Virtual-Memory-Concepts">虚拟内存：概念 Virtual Memory: Concepts</h1>
<p>使用<strong>内存管理单元 memory manage unit</strong> 将虚拟地址转化为物理地址</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.webp" alt="虚拟内存"></p>
<p>虚拟内存优点：</p>
<ul>
<li>主内存的效率更高</li>
<li>简化内存管理</li>
<li>隔离地址空间</li>
</ul>
<p>内存<strong>页 page</strong> 的大小一般为 4KB，有的是 4MB</p>
<p><strong>页表 page table</strong> 是**页表项 page table entries（PTE）**的数组，其将虚拟页映射到物理页</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E9%A1%B5%E8%A1%A8.webp" alt="页表"></p>
<p>当对虚拟内存的引用没有出现在物理内存中时，出现<strong>页错误 page fault</strong>，处理器选择一个受害者逐出，然后将需要的虚拟内存地址指向物理内存，并重新执行上一条指令</p>
<p>虚拟内存看似低效，但因为局部性，效率不错</p>
<p>程序倾向于访问活跃的虚拟内存页的集合叫<strong>工作集合 working set</strong>，时间局部性较好的程序 working set 较小</p>
<p>虚拟内存对内存管理很有用：</p>
<ul>
<li>简化内存分配</li>
<li>在进程间共享代码和数据</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E4%B8%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%B7%A5%E5%85%B7.webp" alt=""></p>
<p>虚拟内存也有利于保护内存：</p>
<ul>
<li>PTE 有许可位</li>
<li>MMU 在每次访问时检查这些位</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E4%B8%BA%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%E7%9A%84%E5%B7%A5%E5%85%B7.webp" alt=""></p>
<p>地址转换的符号：</p>
<ul>
<li>参数
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">N = 2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>：虚拟地址空间的地址数</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">M = 2^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span>：物理地址空间的地址数</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><msup><mn>2</mn><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">P = 2^p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span>：页大小</li>
</ul>
</li>
<li>虚拟内存 VA
<ul>
<li>TLBI：TLB 索引</li>
<li>TLBT：TLB 标签</li>
<li>VPO：虚拟页偏移</li>
<li>VPN：虚拟页数字</li>
</ul>
</li>
<li>物理地址 PA
<ul>
<li>PPO：物理页偏移</li>
<li>PPN：物理页数字</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91.webp" alt="地址翻译"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91%EF%BC%9A%E9%A1%B5%E5%91%BD%E4%B8%AD.webp" alt="地址翻译：页命中"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91%EF%BC%9A%E9%A1%B5%E9%94%99%E8%AF%AF.webp" alt="地址翻译：页错误"></p>
<p>使用的缓存是<strong>转译后备缓冲器 translation lookaside buffer(TLB)</strong></p>
<p>多级页表：解决使用过多空间的问题</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.webp" alt="二级页表层次结构"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/k%E7%BA%A7%E9%A1%B5%E8%A1%A8.webp" alt="k级页表"></p>
<h1 id="虚拟内存：系统-Virtual-Memory-Systems">虚拟内存：系统 Virtual Memory: Systems</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E9%85%B7%E7%9D%BFi7%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F.webp" alt="酷睿i7内存系统"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E9%85%B7%E7%9D%BFi7%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91.webp" alt="酷睿i7地址翻译"></p>
<p>加快 L1 访问的技巧：因为物理地址和虚拟地址的偏移是相等的，所以可以直接将其加入到缓存中</p>
<p>Linux 将地址组成叫做 <strong>area</strong> 的集合，即一个个的内存段</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/Linux%E5%86%85%E5%AD%98.webp" alt="Linux内存"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E9%A1%B5%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.webp" alt="页错误处理"></p>
<p>**写时复制 copy-on-write（COW）**的策略：两个进程先共享同样的内存，若想要修改该内存，则需复制一份</p>
<p><code>fork</code> 就使用了这种策略，故速度很快，只有在需要是才会复制</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E9%A1%B5%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.webp" alt="页错误处理"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6.webp" alt="写时复制"></p>
<p><code>void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset)</code> 可以对指定文件创建一个虚拟内存地址，这样就做到了只有在需要读的时候才会写入内存</p>
<h1 id="动态内存分配：基本概念-Dynamic-Memory-Allocation-Basic-Concepts">动态内存分配：基本概念 Dynamic Memory Allocation: Basic Concepts</h1>
<p>程序员在运行时使用<strong>动态内存分配器 Dynamic Memory Allocators</strong>（例如 malloc）获取 VM，因为一些数据结构只有在运行时才能得知其大小</p>
<p>动态内存分配器维护的 VM 区域叫<strong>堆 heap</strong></p>
<p>分配器把堆作为大小为<strong>块 blocks</strong> 的变量，其只有<strong>已分配 allocated</strong> 和<strong>释放了 free</strong></p>
<p>分配器的类型：</p>
<ul>
<li>显式分配器：应用分配空间和释放空间，如 malloc 和 free</li>
<li>隐式分配器：应用分配空间，但不释放空间，如 garbage collector</li>
</ul>
<p><code>void *malloc(size_t size)</code>：</p>
<ul>
<li>成功时返回一个至少为 <code>size </code>对齐于 8 byte（x86）或 16 byte（x86-64）的内存块的边界的指针</li>
<li>未成功：返回 <code>NULL</code> 并设置 <code>errno</code></li>
</ul>
<p><code>void free(void *p)</code>：</p>
<ul>
<li>返回被 p 指向的可用区域的块</li>
<li>p 必须从 <code>malloc</code> 或 <code>realloc</code> 得来</li>
</ul>
<p>其它函数：</p>
<ul>
<li><code>calloc</code>：初始化变量为 0 的 <code>malloc</code></li>
<li><code>realloc</code>：改变之前分配的块的大小</li>
<li><code>sbrk</code>：被分配器在其内部使用以增大或减小堆的大小</li>
</ul>
<p>约束：</p>
<p>对于应用：</p>
<ul>
<li>可以发出<strong>任意</strong> <code>malloc</code> 和 <code>free</code> 的请求序列</li>
<li><code>free</code> 请求必须对应 <code>malloc</code> 块</li>
</ul>
<p>对于分配器：</p>
<ul>
<li>无法控制已分配的块的数量和大小</li>
<li>必须<strong>立刻</strong>回应 <code>malloc</code> 请求</li>
<li>必须从空闲的内存中分配块</li>
<li>必须返回的块对齐</li>
<li>可以操作或修改空隙内存，但不能移动已分配块</li>
</ul>
<p>表现目标：</p>
<ul>
<li><strong>吞吐量 throughput</strong>：每单位时间完成的请求数量</li>
<li><strong>峰值内存使用 peak memory utilization</strong>：在 k + 1 次请求后，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>k</mi></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mo><mi>max</mi><mo>⁡</mo></mo><mrow><mi>i</mi><mo>&lt;</mo><mo>=</mo><mi>k</mi></mrow></msub><msub><mi>P</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msub><mi>H</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">U_k = (\max_{i&lt;=k} P_i) / H_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mop"><span class="mop">max</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999985em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">&lt;</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17737em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">P_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示<strong>负载 payload</strong>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">H_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示当前堆大小</li>
</ul>
<p><strong>内部碎片 internal fragmentation</strong>：负载小于块大小，主要由维护堆的数据结构的开销和对齐造成</p>
<p><strong>外部碎片 external fragmentation</strong>：有足够的内存，但没有空闲的块足够大</p>
<p>跟踪空闲块：</p>
<ul>
<li>使用长度<strong>隐式</strong>列表（链接所有的块）</li>
<li>使用指针对所有空闲块<strong>显式</strong>列表</li>
<li>分开空闲列表，如把不同大小的类分成不同的列表</li>
<li>通过大小排序块，如使用平衡树用指针指向空闲块，长度作为键使用</li>
</ul>
<p>方法一：隐式列表</p>
<p>因为块是对齐的，所以一些地位地址总是 0，所以可以用其当作分配的状态位</p>
<p>找到一个空闲块：</p>
<ul>
<li><strong>第一次</strong>合适：从开头搜索，选择<strong>第一个</strong>合适的块</li>
<li>下一个合适：从<strong>上一次结束的地方</strong>开始搜索，其余和第一次合适一样</li>
<li>最优匹配：选择<strong>最优</strong>的空闲列表</li>
</ul>
<p>在空闲块中分配：<strong>分裂 split</strong></p>
<p>释放块：需要<strong>合并 coalesce</strong> 之前的和下一个空闲的块</p>
<p>查找前一个块的方法是边界标签，即在块的尾部添加和头部一样的标签，同时只有分配的才需要</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BE%B9%E7%95%8C%E6%A0%87%E8%AE%B0.webp" alt="边界标记"></p>
<p>合并策略：</p>
<ul>
<li>立即合并</li>
<li>推迟合并</li>
</ul>
<h1 id="动态内存分配：进阶概念-Dynamic-Memory-Allocation-Advanced-Concepts">动态内存分配：进阶概念 Dynamic Memory Allocation: Advanced Concepts</h1>
<p>显式列表：类似于一个链表</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E6%98%BE%E5%BC%8F%E5%88%97%E8%A1%A8%20(2).webp" alt="显式列表结构"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E6%98%BE%E5%BC%8F%E5%88%97%E8%A1%A8%20(1).webp" alt=""></p>
<p>释放：插入策略：</p>
<ul>
<li>LIFO</li>
<li>地址顺序</li>
</ul>
<p><strong>分开列表 segregated list</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E5%88%86%E5%BC%80%E5%88%97%E8%A1%A8.webp" alt=""></p>
<p><strong>垃圾回收 garbage collection</strong>：C 语言中是<strong>保守的 conservative</strong>，因为无法区分指针和非指针</p>
<p>把内存视为一个有向图：</p>
<ul>
<li>块是节点</li>
<li>指针是边</li>
<li>不在堆中的包括指向堆的指针叫 root 节点</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.webp" alt=""></p>
<p><strong>标记和清扫 Mark and Sweep</strong>：使用 <code>malloc</code> 直到用尽空间</p>
<ul>
<li>在每个块的头部使用<strong>标记位</strong></li>
<li>标记：从根开始标记每个可到达的块</li>
<li>清扫：搜索所有的块并释放没有标记的块</li>
</ul>
<p>对于指针，注意运算符优先级</p>
<p>常见错误：</p>
<ul>
<li><code>scanf</code> 没有使用 <code>&amp;</code></li>
<li>假设堆的数据已经初始化</li>
<li>分配错误大小的对象</li>
<li>数组索引多了 1</li>
<li>没有检查最大 string 大小</li>
<li>误解指针算术</li>
<li>引用不存在的变量，如局部变量</li>
<li>多次释放块</li>
<li>引用释放的块</li>
<li>忘了释放块</li>
</ul>
<h1 id="网络编程-Network-Programming">网络编程 Network Programming</h1>
<p><strong>客户端-服务器交易 Client-Server Transaction</strong>：</p>
<ul>
<li>一个服务器进程和一个或多个客户端进程</li>
<li>服务器管理一些<strong>资源 resource</strong></li>
<li>服务器通过操作资源为客户端提供<strong>服务 service</strong></li>
<li>服务器被客户端的请求激活</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%A4%E6%98%93.webp" alt=""></p>
<p>将网络抽象为一个文件</p>
<p><strong>网络 network</strong> 是主机的系统的集合，包括 SAN，LAN，WAN</p>
<p><strong>internet</strong> 是相互连接的网络的集合</p>
<p>最低层级：<strong>以太网段 Ethernet segment</strong> 由<strong>主机 hosts</strong> 由线连接为一个 <strong>hub</strong> 组成</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1.webp" alt=""></p>
<p>下一个层级：桥接的以太网</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2.webp" alt=""></p>
<p>下一个层次：internet，通过<strong>路由器 routers</strong> 连接多重不兼容的 LAN</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B3.webp" alt=""></p>
<p><strong>协议 protocol</strong>：</p>
<ul>
<li>提供命名方案：主机地址</li>
<li>提供分发机制：定义了转移单位<strong>包 packet</strong>，包由 <strong>header</strong> 和 <strong>payload</strong> 组成</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BD%AC%E7%A7%BBinternet%E6%95%B0%E6%8D%AE.webp" alt=""></p>
<p>全局 IP Internet，基于 TCP/IP 协议：</p>
<ul>
<li><strong>IP（Internet Protocol）</strong>：提供<strong>基本命名方案</strong>和不可靠的从<strong>主机到主机</strong>的包的<strong>分发兼容性</strong></li>
<li><strong>UDP（Unreliable Datagram Protocol）</strong>：使用 IP 提供<strong>不可靠的</strong>从<strong>进程到进程</strong>的数据分发</li>
<li><strong>TCP（Transmission Control Protocol）</strong>：使用 IP 提供<strong>可靠的</strong>通过<strong>连接</strong>的从<strong>进程到进程</strong>的字节流</li>
</ul>
<p>通过 Unix 文件 I/O 和<strong>套接字接口 socket interface</strong> 中的函数访问</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%92%8C%E7%A1%AC%E4%BB%B6%E7%BB%84%E7%BB%87.webp" alt=""></p>
<ul>
<li>主机被映射为一个 32 位的 <strong>IP 地址 IP address</strong></li>
<li>IP 地址集合被映射为一个标识符集合叫做 Internet <strong>域名 domain names</strong></li>
<li>一个 Internet 主机上的进程可以通过<strong>连接 connection</strong> 和另一个主机上的进程交流</li>
</ul>
<p>IPv4 和 IPv6</p>
<p>IP 地址：被储存在一个 <strong>IP 地址结构中</strong>，为大端序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> s_addr;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用这个 struct 可以不用手动转换大端序和小端序</p>
<p>转换二进制 IP 地址和用点分割的十进制字符串的函数：（“n” 表示 network，“p” 表示 presentation）</p>
<ul>
<li><code>inet_pton</code>：string -&gt; IP address</li>
<li><code>inet_ntop</code>：IP address -&gt; string</li>
</ul>
<p>Internet 使用<strong>域名系统 Domain Naming System（DNS）</strong> 维护从 IP 地址和域名的映射，使用的是一个巨大的全世界范围的分布式数据库，可以将其视为许多条<strong>主机项</strong>的集合，主机项定义了域名集合与 IP 地址的映射</p>
<p>多个域名被映射到多个 IP 地址，有些有效的域名没有被映射到任何 IP 地址</p>
<p>每个连接是：</p>
<ul>
<li>点对点的</li>
<li>完全双重的 full-deplex</li>
<li>可靠的</li>
</ul>
<p><strong>套接字 socket</strong> 是一个连接的终点</p>
<p><strong>端口 port</strong> 是一个 16 位整数，其识别一个进程：</p>
<ul>
<li>短暂的 ephemeral，当客户端发起一个连接请求时，客户端内核自动分配</li>
<li>众所周知的 well-know，如 80 端口被用于 web</li>
</ul>
<p>一些常见的服务和对应的端口：</p>
<ul>
<li>echo：7/echo</li>
<li>ssh：22/ssh</li>
<li>email：25/smtp</li>
<li>web：80/http</li>
</ul>
<p>端口-服务名的映射别储存在 Linux 的 /etc/services</p>
<p>套接字：</p>
<ul>
<li>对内核来说，socket 是通信的终点</li>
<li>对应用来说，socket 是一个让应用读写网络的文件描述符</li>
</ul>
<p>客户端和服务器通过读写 socket 描述符通信</p>
<p>Internet 的 socket 地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> &#123;</span><br>    <span class="hljs-type">uint16_t</span> sin_family; <span class="hljs-comment">// 通常是 AF_INET</span><br>    <span class="hljs-type">uint16_t</span> sin_port;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> sin_zero[<span class="hljs-number">8</span>]; <span class="hljs-comment">// 填充</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.webp" alt=""></p>
<p>socket 接口：</p>
<ul>
<li>socket：<code>int socket(int domain, int type, int protocol);</code>，一般使用 <code>getaddrinfo</code>自动生成参数，则无关协议</li>
<li>bind：<code>int bind(int sockfd, SA *addr, socklen_t addrlen);</code>，将 socket 地址和 socket 描述符联系到一起</li>
<li>listen：<code>int listen(int sockfd, int backlog);</code>，用于告诉内核一个描述符会被用于服务网而不是客户端</li>
<li>accept：<code>int accept(int listenfd, SA *addr, int *addrlen);</code> 等待连接请求到达该连接，并在 addr 中填充客户端的 socket 地址和大小，返回用于交流的描述符</li>
<li>connect：<code>int connect(int clientfd, SA *addr, socklen_t addrlen);</code>，建立连接</li>
</ul>
<p><code>getaddrinfo</code> 是转换字符串表示的主机名，主机地址，端口和服务名为 socket 地址的方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">getaddrinfo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *host, <span class="hljs-comment">// 主机名或地址</span></span><br><span class="hljs-params">                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *service, <span class="hljs-comment">// 服务名或端口</span></span><br><span class="hljs-params">                <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> addrinfo *hints,</span><br><span class="hljs-params">                <span class="hljs-keyword">struct</span> addrinfo **result)</span>; <span class="hljs-comment">// 输出一个链表</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">freeaddrinfo</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> addrinfo *result)</span>; <span class="hljs-comment">// 释放链表</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">gai_strerror</span><span class="hljs-params">(<span class="hljs-type">int</span> errcode)</span>; <span class="hljs-comment">// 返回错误信息</span><br></code></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/getaddrinfo.webp" alt=""></p>
<p><code>getnameinfo</code> 是 <code>getaddrinfo</code> 的逆，将 socket 地址转为主机和服务：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">getnameinfo</span><span class="hljs-params">(<span class="hljs-type">const</span> SA *sa, <span class="hljs-type">socklen_t</span> salen, <span class="hljs-comment">// 输入：socket 地址</span></span><br><span class="hljs-params">                <span class="hljs-type">char</span> *host, <span class="hljs-type">size_t</span> hostlen,		<span class="hljs-comment">// 输出：host</span></span><br><span class="hljs-params">                <span class="hljs-type">char</span> *serv, <span class="hljs-type">size_t</span> servlen,		<span class="hljs-comment">// 输出：service</span></span><br><span class="hljs-params">                <span class="hljs-type">int</span> flags)</span>;<br></code></pre></td></tr></table></figure>
<p>Web 服务：</p>
<p>使用<strong>超文本传输协议 HyperText Transfer Protocol(HTTP)</strong> 通信，当前版本是 HTTP 2.0</p>
<p>Web 服务返回<strong>内容 content</strong> 给客户端，内容是一个 <strong>MIME（Multipurpose Internet Mail Extensions）</strong> 类型的字节序列</p>
<p>返回的内容可以是<strong>静态的</strong>，也可以是<strong>动态的</strong></p>
<p>每个文件专有的名字：<strong>URL（Universal Resource Locator)</strong></p>
<p>对于 URL：<a href="https://old-driver-zero.github.io:443/index.html">https://old-driver-zero.github.io:443/index.html</a></p>
<ul>
<li>客户端使用前缀 <code>https://old-driver-zero.github.io:443</code> 推断：
<ul>
<li>使用何种协议（HTTPS）</li>
<li>那个服务器（<a href="http://old-driver-zero.github.io">old-driver-zero.github.io</a>）</li>
<li>哪个端口（443）</li>
</ul>
</li>
<li>服务器使用后缀（/index.html）来：
<ul>
<li>确定是静态的还是动态的内容（没有硬性规定，但一个惯例是：可执行文件储存在 <code>cgi-bin</code> 目录下）</li>
<li>在文件系统上找到文件：
<ul>
<li>使用 <code>/</code> 分割</li>
<li>最小前缀是 <code>/</code>，服务器将其扩展为配置好的文件名（一般是 index.html）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>HTTP 请求</strong>是一个<strong>请求行 request line</strong>，跟着零或更多<strong>请求头 request headers</strong></p>
<ul>
<li>请求行：<code>&lt;method&gt; &lt;uri&gt; &lt;version&gt;</code>
<ul>
<li><code>&lt;method&gt;</code> 是 <code>GET, POST, OPTIONS, HEAD, PUT, DELETE, TRACE</code> 之一</li>
<li><code>&lt;uri&gt;</code> 是代理的 URL，URL 是 URI 的一个类型</li>
<li><code>&lt;version&gt;</code> 是 HTTP 版本</li>
</ul>
</li>
<li>请求头：<code>&lt;header name&gt;: &lt;header data&gt;</code></li>
</ul>
<p><strong>HTTP 回应</strong>是一个回应行，跟着零或更多<strong>回应头 request headers</strong>，空行用 <code>\r\n</code> 分割</p>
<ul>
<li>回应行：<code>&lt;version&gt; &lt;status code&gt; &lt;status msg&gt;</code>
<ul>
<li><code>&lt;version&gt;</code> 是 HTTP 版本</li>
<li><code>&lt;status code&gt;</code> 是数字状态，如 404</li>
<li><code>&lt;status msg&gt;</code> 是相关的英语文本</li>
</ul>
</li>
<li>回应头：<code>&lt;header name&gt;: &lt;header data&gt;</code></li>
</ul>
<h1 id="并发编程-Concurrent-Programming">并发编程 Concurrent Programming</h1>
<p>并发编程很难，因为</p>
<ul>
<li>人类的头脑倾向于顺序</li>
<li>时间经常被忽略</li>
<li>考虑所有可能的事件顺序很难</li>
</ul>
<p>并发程序的问题分类：</p>
<ul>
<li><strong>竞争 race</strong>：结果取决于任意调度</li>
<li><strong>死锁 deadlock</strong>：阻碍继续前进</li>
<li><strong>饿死 starvation</strong>：轮不到你</li>
</ul>
<p>迭代式服务器：一次处理一个请求</p>
<p>写并发服务器的方法：</p>
<ul>
<li><strong>基于进程</strong>：
<ul>
<li><strong>内核</strong>自动交错多个逻辑流</li>
<li>每个流有它自己的<strong>私有</strong>地址空间</li>
</ul>
</li>
<li><strong>基于事件</strong>：
<ul>
<li><strong>程序员</strong>手动交错多重逻辑流</li>
<li>所有流<strong>共享</strong>相同的地址空间</li>
<li>使用被称作 <strong>I/O 多路复用</strong>的技术</li>
</ul>
</li>
<li><strong>基于线程</strong>：
<ul>
<li><strong>内核</strong>自动交错多重逻辑流</li>
<li>每个流共享相同的地址空间</li>
<li>算是前两者的杂交</li>
</ul>
</li>
</ul>
<p>基于进程的服务器：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8.webp" alt="基于进程的服务器"></p>
<p>因为父和子进程都有 listenfd 和 connectfd 的复制，所以</p>
<ul>
<li>父必须关闭 connfd</li>
<li>子应该关闭 listenfd</li>
</ul>
<p>且必须收割僵尸子进程</p>
<p>基于事件的服务器：决定哪个描述符有待定的输入，例如使用 <code>select</code> 或 <code>epoll</code> 函数，待定的输入的到达是一个事件</p>
<p>进程 = 进程上下文 + 代码，数据和栈</p>
<p>线程 = 线程 + 代码，数据和内核上下文</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B.webp" alt="进程"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E7%BA%BF%E7%A8%8B.webp" alt="线程"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E4%B8%80%E4%B8%AA%E6%9C%89%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%9B%E7%A8%8B.webp" alt="一个有多线程的进程"></p>
<p>线程和线程形成一个 peer 池，而进程形成树层次结构</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E9%80%BB%E8%BE%91%E8%A7%86%E8%A7%92.webp" alt="逻辑视角"></p>
<p>线程的花费比进程小</p>
<p><strong>POSIX 线程</strong>（Pthread）接口：</p>
<ul>
<li>创建和收割线程：<code>pthread_create(), pthread_join()</code></li>
<li>确定自己的线程 ID：<code>pthread_self()</code></li>
<li>终止线程：<code>pthread_cancel(), pthread_exit()</code></li>
</ul>
<p>线程在 detached 模式中运行：</p>
<ul>
<li>一个线程要么是<strong>可连接 joinable</strong>，要么是<strong>脱离的 detached</strong></li>
<li>一个可连接的线程可以被其他线程收割或杀死，必须使用 <code>pthread_join</code> 释放内存资源</li>
<li>脱离的线程不可以被被其他线程收割或杀死，终止时资源自动被内核收割</li>
<li>默认状态是可连接的，使用 <code>pthread_detach(pthread_self())</code> 脱离</li>
</ul>
<h1 id="同步：基础-synchronization：Basics">同步：基础 synchronization：Basics</h1>
<p><em>定义</em>：当且仅当多个线程引用某个 x 的实例，则称变量 x 是<strong>共享的 shared</strong></p>
<p>全局变量：</p>
<ul>
<li>在函数外声明</li>
<li>虚拟内存包括一个全局变量实例</li>
</ul>
<p>局部变量：</p>
<ul>
<li>在函数内部声明，没有 static</li>
<li>每个线程栈包括每个局部变量的一个实例</li>
</ul>
<p>局部静态变量：</p>
<ul>
<li>在函数内声明，有 static</li>
<li>虚拟内存包括一个局部静态变量实例</li>
</ul>
<p>并发执行：一般来说，任何顺序一致的交错都是可能的，但是有些给出意料之外的结果</p>
<p><strong>过程图 progress graph</strong> 描绘了并发线程的离散的<strong>执行状态空间 execution state space</strong></p>
<ul>
<li>每个轴代表一个线程顺序执行指令</li>
<li>每个点关系到一个可能的执行状态</li>
<li><strong>轨迹 trajectory</strong> 合法转移序列，其描述了一个并发线程可能的执行</li>
<li>L，U，S 形成了对变量 cnt 的<strong>临界段 critical section</strong></li>
<li>临界段中的指令不能交错，这种交错出现的状态集合形成了<strong>不安全区域 unsafe regions</strong></li>
</ul>
<p>所以当且仅当一个没有进入任何不安全区域时，这个轨迹是<strong>安全的</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%87%E7%A8%8B%E5%9B%BE.webp" alt="过程图"></p>
<p>为了确保安全的轨迹，必须<strong>同步 synchronize</strong> 线程的执行，即保证对临界段的<strong>互斥访问 mutually exclusive access</strong></p>
<p><strong>信号量 Semaphore</strong>：由 P 和 V 操作控制的非负全局整数同步变量</p>
<p><code>P(s)</code>：</p>
<ul>
<li>如果 s 非 0，则 s - 1 并立即返回</li>
<li>如果 s 为 0，则暂停直到 s 变成 0 且该线程由 V 操作重启</li>
<li>在重启后，P 操作减小 s 并返回控制权给 callee</li>
</ul>
<p><code>V(s)</code>：</p>
<ul>
<li>s + 1</li>
<li>如果有线程被等待 s 变成非 0 的 P 操作阻塞了，则重启其中一个线程</li>
</ul>
<p><strong>这两个操作共同形成了不变量：s &gt;= 0</strong></p>
<p>Pthreads 提供的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_init</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *s, <span class="hljs-number">0</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> val)</span>; <span class="hljs-comment">/* s = val */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_wait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *s)</span>; <span class="hljs-comment">/* P(s) */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_post</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *s)</span>; <span class="hljs-comment">/* V(s) */</span><br></code></pre></td></tr></table></figure>
<p>使用信号量的互斥：</p>
<p>基本思想：</p>
<ul>
<li>将一个初始为 1 的唯一信号量 mutex 与每个共享的变量关联</li>
<li>在临界段周围加上 <code>P(mutex)</code> 和 <code>V(mutex)</code> 操作</li>
</ul>
<p>术语：</p>
<ul>
<li><strong>二进制信号量 Binary semaphore</strong>：值总是 0 或 1 的信号量</li>
<li><strong>Mutex</strong>：用于互斥的二进制信号量
<ul>
<li>P 操作：<strong>锁上 locking</strong> mutex</li>
<li>V 操作：<strong>解锁 unlocking</strong> 或<strong>释放 releasing</strong> mutex</li>
<li><strong>保持 holding</strong> mutex：锁上但没有解锁</li>
</ul>
</li>
<li><strong>计数信号量 counting semaphore</strong>：用于可获得的资源的集合的计数器</li>
</ul>
<p>从过程图来看，信号量创造了一个<strong>禁止区域</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/Mutex%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.webp" alt="Mutex工作原理"></p>
<h1 id="同步：进阶-Synchronization-Advanced">同步：进阶 Synchronization: Advanced</h1>
<p>使用信号量协调对共享资源的访问：</p>
<p>基本思想：线程使用信号量操作通知另一个线程某情况已经满足了</p>
<ul>
<li>使用计数信号量跟踪资源状态并通知其他线程</li>
<li>使用 mutex 保护对资源的访问</li>
</ul>
<p>两个经典例子：</p>
<p><strong>生产者-消费者问题 Producer-Consumer Problem</strong>：</p>
<ul>
<li>生产者等待空<strong>槽 slot</strong>，在 buffer 中插入物品，通知消费者</li>
<li>消费者等待<strong>物品 item</strong>，将其从 buffer 中移除，通知生产者</li>
</ul>
<p><strong>读者-写者问题 Readers-Writers Problem</strong>：</p>
<ul>
<li>读者只读对象</li>
<li>写者修改对象</li>
<li>写者必须互斥访问对象</li>
<li>访问对象的读者无数量限制</li>
</ul>
<p>变种：</p>
<ul>
<li>读者优先</li>
<li>写者优先</li>
</ul>
<p>两者情况饿死都会存在</p>
<p>一个线程中的函数必须是<strong>线程安全的 thread-safe</strong></p>
<p><em>定义</em>：当且仅当一个函数从多重并发线程中重复调用时，总是返回正确的结果，则该函数是<strong>线程安全的</strong></p>
<p>线程不安全的函数分类：</p>
<ul>
<li>没有保护共享变量的函数</li>
<li>从多重调用中保留了状态的函数</li>
<li>返回指向一个静态变量的指针的函数</li>
<li>调用线程不安全的函数的函数</li>
</ul>
<p><em>定义</em>：当且仅当一个函数访问没有共享的变量，则该函数是<strong>可重入的 reentrant</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0.webp" alt="可重入函数"></p>
<p><strong>竞争 race</strong> 发生在程序的正确性依赖于一个线程在另一个线程达到 y 点前到达 x 点</p>
<p><em>定义</em>：当且仅当一个线程等待一个不可能发生的条件时，其是<strong>死锁的 deadlocked</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E6%AD%BB%E9%94%81.webp" alt="死锁"></p>
<p>避免死锁的方法：以相同的顺序获取资源</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81.webp" alt="避免死锁"></p>
<h1 id="线程层次并行-Thread-Level-Parallelism">线程层次并行 Thread-Level Parallelism</h1>
<p>因为往往 CPU 的一个核心中的所有算术单元不会同时使用到，故使用<strong>超线程 hyperthread</strong> 可以提高其利用率</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%B6%85%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0.webp" alt="超线程实现"></p>
<p>并行程序效率：</p>
<ul>
<li><strong>加速比 speedup</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>p</mi></msub><mo>=</mo><msub><mi>T</mi><mn>1</mn></msub><mi mathvariant="normal">/</mi><msub><mi>T</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">S_p = T_1 / T_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></li>
<li><strong>效率 effciency</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mi>p</mi></msub><mo>=</mo><msub><mi>S</mi><mi>p</mi></msub><mi mathvariant="normal">/</mi><mi>p</mi><mo>=</mo><msub><mi>T</mi><mn>1</mn></msub><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>p</mi><msub><mi>T</mi><mi>p</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E_p= S_p / p = T_1 / (p T_p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<p><strong>阿姆达尔定律 Amdahl's Law</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>k</mi></msub><mo>=</mo><mi>p</mi><mi>T</mi><mi mathvariant="normal">/</mi><mi>k</mi><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">T_k = pT/k + (1-p)T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span> 为可以被加速的部分比例</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 加速因子</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> 需要的总时间</li>
<li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">k = ∞</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi mathvariant="normal">∞</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">T_∞ = (1-p)T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></li>
</ul>
<p>对于硬件设计者要注意<strong>内存一致性</strong>，即两个线程的缓存是不同的，一个修改了内存，但因为<strong>延迟回写</strong>，内存中内容没有变，改变的是其缓存的内容。此时另一个线程想要访问值，获得的还是原来的值。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E7%BC%93%E5%AD%98.webp" alt="不一致的缓存"></p>
<p>解决方法为缓存增加一个状态位：当其为 E 时，需要请求另一个线程中的缓存而不是找下级内存</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CMU/">CMU</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</a></div><div class="post_share"><div class="social-share" data-image="/gallery/cover/CMU%2015-213%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/1be398e4.html" title="GDB 学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/GDB%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">GDB 学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/posts/a98766fe.html" title="做自己的英雄"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/%E5%9C%A8%E5%9C%B0%E4%B8%8B%E5%9F%8E%E5%AF%BB%E6%B1%82%E9%82%82%E9%80%85%E6%98%AF%E5%90%A6%E6%90%9E%E9%94%99%E4%BA%86%E4%BB%80%E4%B9%88.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">做自己的英雄</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="iconfont icon-tuijian"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/17492bb9.html" title="CMU 15-445：数据库系统"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/CMU%2015-445%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-30</div><div class="title">CMU 15-445：数据库系统</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/%E5%A4%B4%E5%83%8F_%E7%81%B0%E5%A4%AA%E7%8B%BC.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">old_driver_zero</div><div class="author-info__description">我一定会回来的</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">183</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/old-driver-zero" rel="external nofollow noreferrer" target="_blank" title="GitHub"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-github"></use></svg></a><a class="social-icon faa-parent animated-hover" href="mailto:2771503468@qq.com" rel="external nofollow noreferrer" target="_blank" title="QQ邮箱"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://steamcommunity.com/id/old_driver_zero" rel="external nofollow noreferrer" target="_blank" title="Steam"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-steam"></use></svg></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><a class="faa-parent animated-hover"><svg class="faa-tada icon" style="height:25px;width:25px;fill:currentColor;position:relative;top:5px" aria-hidden="true"><use xlink:href="#icon-mulu"></use></svg></a><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AF%94%E7%89%B9%EF%BC%8C%E5%AD%97%E8%8A%82%E5%92%8C%E6%95%B4%E6%95%B0-Bits-Bytes-and-Integers"><span class="toc-number">1.</span> <span class="toc-text">比特，字节和整数 Bits, Bytes, and Integers</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9-Floating-Point"><span class="toc-number">2.</span> <span class="toc-text">浮点 Floating Point</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BC%96%E7%A8%8B-I%EF%BC%9A%E5%9F%BA%E7%A1%80-Machine-Level-Programming-I-Basics"><span class="toc-number">3.</span> <span class="toc-text">机器层次编程 I：基础 Machine-Level Programming I: Basics</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BC%96%E7%A8%8B-II%EF%BC%9A%E6%8E%A7%E5%88%B6-Machine-Level-Programming-II-Control"><span class="toc-number">4.</span> <span class="toc-text">机器层次编程 II：控制 Machine-Level Programming II: Control</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BC%96%E7%A8%8B-III%EF%BC%9A%E7%A8%8B%E5%BA%8F-Machine-Level-Programming-III-Procedures"><span class="toc-number">5.</span> <span class="toc-text">机器层次编程 III：程序 Machine-Level Programming III: Procedures</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BC%96%E7%A8%8B-IV%EF%BC%9A%E6%95%B0%E6%8D%AE-Machine-Level-Programming-IV-Data"><span class="toc-number">6.</span> <span class="toc-text">机器层次编程 IV：数据 Machine-Level Programming IV: Data</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BC%96%E7%A8%8B-V%EF%BC%9A%E8%BF%9B%E9%98%B6%E4%B8%BB%E9%A2%98-Machine-Level-Programming-V-Advanced-Topics"><span class="toc-number">7.</span> <span class="toc-text">机器层次编程 V：进阶主题 Machine-Level Programming V: Advanced Topics</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96-Program-Optimization"><span class="toc-number">8.</span> <span class="toc-text">程序优化 Program Optimization</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84-The-Memory-Hierarchy"><span class="toc-number">9.</span> <span class="toc-text">内存层次结构 The Memory Hierarchy</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%86%85%E5%AD%98-Cache-Memories"><span class="toc-number">10.</span> <span class="toc-text">缓存内存 Cache Memories</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5-Linking"><span class="toc-number">11.</span> <span class="toc-text">链接 Linking</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%9A%E5%BC%82%E5%B8%B8%E5%92%8C%E8%BF%9B%E7%A8%8B-Exceptional-Control-Flow-Exceptions-and-Processes"><span class="toc-number">12.</span> <span class="toc-text">异常控制流：异常和进程 Exceptional Control Flow: Exceptions and Processes</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%9A%E4%BF%A1%E5%8F%B7%E5%92%8C%E9%9D%9E%E6%9C%AC%E5%9C%B0%E8%B7%B3%E8%BD%AC-Exceptional-Control-Flow-Signals-and-Nonlocal-Jumps"><span class="toc-number">13.</span> <span class="toc-text">异常控制流：信号和非本地跳转 Exceptional Control Flow: Signals and Nonlocal Jumps</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA-System-Level-I-O"><span class="toc-number">14.</span> <span class="toc-text">系统层次输入&#x2F;输出 System-Level I&#x2F;O</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9A%E6%A6%82%E5%BF%B5-Virtual-Memory-Concepts"><span class="toc-number">15.</span> <span class="toc-text">虚拟内存：概念 Virtual Memory: Concepts</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9A%E7%B3%BB%E7%BB%9F-Virtual-Memory-Systems"><span class="toc-number">16.</span> <span class="toc-text">虚拟内存：系统 Virtual Memory: Systems</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-Dynamic-Memory-Allocation-Basic-Concepts"><span class="toc-number">17.</span> <span class="toc-text">动态内存分配：基本概念 Dynamic Memory Allocation: Basic Concepts</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%9A%E8%BF%9B%E9%98%B6%E6%A6%82%E5%BF%B5-Dynamic-Memory-Allocation-Advanced-Concepts"><span class="toc-number">18.</span> <span class="toc-text">动态内存分配：进阶概念 Dynamic Memory Allocation: Advanced Concepts</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Network-Programming"><span class="toc-number">19.</span> <span class="toc-text">网络编程 Network Programming</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-Concurrent-Programming"><span class="toc-number">20.</span> <span class="toc-text">并发编程 Concurrent Programming</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%EF%BC%9A%E5%9F%BA%E7%A1%80-synchronization%EF%BC%9ABasics"><span class="toc-number">21.</span> <span class="toc-text">同步：基础 synchronization：Basics</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%EF%BC%9A%E8%BF%9B%E9%98%B6-Synchronization-Advanced"><span class="toc-number">22.</span> <span class="toc-text">同步：进阶 Synchronization: Advanced</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%82%E6%AC%A1%E5%B9%B6%E8%A1%8C-Thread-Level-Parallelism"><span class="toc-number">23.</span> <span class="toc-text">线程层次并行 Thread-Level Parallelism</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>不必要做的事不做，必须做的一律从简</div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/comments/">留点什么</a><a href="/random/">随便逛逛</a></li><li><a href="/about/">关于</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/gallery/">我的画廊</a><a href="/charts/">网站统计</a></li></ul></div></div></div></div><div class="copyright">&copy;2022 - 2024 By old_driver_zero</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.32/fancybox/fancybox.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instant.page/5.2.0/instantpage.min.js" type="module"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/17.8.5/lazyload.iife.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script async src="//at.alicdn.com/t/c/font_4031045_1yiosqv4vch.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.22.0/algoliasearch-lite.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.63.0/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.12.0"></script></div></div></html>