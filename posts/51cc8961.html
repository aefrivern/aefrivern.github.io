<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据密集型应用系统设计 | Aefrivernの小屋</title><meta name="author" content="Aefrivern"><meta name="copyright" content="Aefrivern"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基于 Designing Data-Intensive Application 编写 数据系统基础 可靠性、可扩展性、可维护性应用 可靠性 reliability： 出错的东西叫 故障 fault，能够处理故障的系统叫 容错 fault-tolerant，但是 失效 failure 是指系统整体不可用，而不是单个组件出现故障 硬件故障：通常是增加冗余 软件错误：通常涉及多个节点，所以一般要较长时间">
<meta property="og:type" content="article">
<meta property="og:title" content="数据密集型应用系统设计">
<meta property="og:url" content="https://aefrivern.github.io/posts/51cc8961.html">
<meta property="og:site_name" content="Aefrivernの小屋">
<meta property="og:description" content="基于 Designing Data-Intensive Application 编写 数据系统基础 可靠性、可扩展性、可维护性应用 可靠性 reliability： 出错的东西叫 故障 fault，能够处理故障的系统叫 容错 fault-tolerant，但是 失效 failure 是指系统整体不可用，而不是单个组件出现故障 硬件故障：通常是增加冗余 软件错误：通常涉及多个节点，所以一般要较长时间">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://aefrivern.github.io/gallery/cover/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1.webp">
<meta property="article:published_time" content="2024-11-26T08:31:32.000Z">
<meta property="article:modified_time" content="2024-12-01T08:14:44.000Z">
<meta property="article:author" content="Aefrivern">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="分布式系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://aefrivern.github.io/gallery/cover/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1.webp"><link rel="shortcut icon" href="/illustration/favicon.ico"><link rel="canonical" href="https://aefrivern.github.io/posts/51cc8961.html"><link rel="preconnect" href="//unpkg.com"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"GY5EJYJ1FS","apiKey":"c443c952672ec7062840aac45536181e","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据密集型应用系统设计',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-01 16:14:44'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4031045_1yiosqv4vch.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/highlight.css"><link rel="stylesheet" href="/css/custom.css"><script src="/js/echarts.min.js"></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://unpkg.com/pace-js@1.2.4/themes/blue/pace-theme-minimal.css"/><script src="https://unpkg.com/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/c/font_4031045_izvon5l4fr8.js"></script><!-- hexo injector body_end end --></body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/%E5%A4%B4%E5%83%8F_%E7%81%B0%E5%A4%AA%E7%8B%BC.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">166</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">224</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-shouye-01"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shouye-01"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-guidang"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guidang"></use></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw icon-a-16-01-01"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-a-16-01-01"></use></svg><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-wenjianjia"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wenjianjia"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/anime/"><i class="fa-fw icon-zhifeiji"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhifeiji"></use></svg><span> 二次元</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/gallery/"><i class="fa-fw icon-xiangce"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiangce"></use></svg><span> 画廊</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-guanyu"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyu"></use></svg><span> 关于</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/charts/"><i class="fa-fw icon-tongjichaxun"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tongjichaxun"></use></svg><span> 统计</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-liuyan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyan"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/random/"><i class="fa-fw icon-suiji"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-suiji"></use></svg><span> 随便逛逛</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/gallery/cover/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="Aefrivernの小屋"><span class="site-name">Aefrivernの小屋</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-sousuo1"></use></svg><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-shouye-01"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shouye-01"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-guidang"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guidang"></use></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw icon-a-16-01-01"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-a-16-01-01"></use></svg><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-wenjianjia"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wenjianjia"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/anime/"><i class="fa-fw icon-zhifeiji"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhifeiji"></use></svg><span> 二次元</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/gallery/"><i class="fa-fw icon-xiangce"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiangce"></use></svg><span> 画廊</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-guanyu"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyu"></use></svg><span> 关于</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/charts/"><i class="fa-fw icon-tongjichaxun"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tongjichaxun"></use></svg><span> 统计</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-liuyan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyan"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/random/"><i class="fa-fw icon-suiji"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-suiji"></use></svg><span> 随便逛逛</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据密集型应用系统设计</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-26T08:31:32.000Z" title="发表于 2024-11-26 16:31:32">2024-11-26</time><span class="post-meta-separator">|</span><svg class="meta_icon post-ui-icon" style="width:13px;height:13px;position:relative;top:2px"><use xlink:href="#icon-gengxin"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-01T08:14:44.000Z" title="更新于 2024-12-01 16:14:44">2024-12-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><a class="faa-parent animated-hover"></a><svg class="meta_icon post-ui-icon" style="width:13px;height:13px;position:relative;top:2px"><use xlink:href="#icon-fenlei"></use></svg><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-word"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">9.3k</span><span class="post-meta-separator">|</span><svg class="meta_icon post-ui-icon" style="width:16px;height:16px;position:relative;top:3px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>基于 <em>Designing Data-Intensive Application</em> 编写</p>
<h2 id="数据系统基础">数据系统基础</h2>
<h3 id="可靠性、可扩展性、可维护性应用">可靠性、可扩展性、可维护性应用</h3>
<p><strong>可靠性 reliability</strong>：</p>
<p>出错的东西叫 <strong>故障 fault</strong>，能够处理故障的系统叫 <strong>容错 fault-tolerant</strong>，但是 <strong>失效 failure</strong> 是指系统整体不可用，而不是单个组件出现故障</p>
<p>硬件故障：通常是增加冗余</p>
<p>软件错误：通常涉及多个节点，所以一般要较长时间才能发现。处理方法包括：假设和交互、监视行为、测试等</p>
<p>人为错误：人是不可靠的，绝大多数错误都来自运维人员错误。处理方法包括：设计防止人为错误的系统、解耦、监控、培训等</p>
<p><strong>可扩展性 scalability</strong>：系统应对负载增长时的能力</p>
<p>描述负载：使用一些参数，通常和系统架构有关</p>
<p>描述性能：</p>
<ul>
<li>批处理系统：吞吐量</li>
<li>在线系统：响应时间</li>
</ul>
<p>对于响应时间，由于存在变化，故通常会得出一个分布，然后使用百分位点来评估（p99 等）</p>
<p>处理负载的方法：</p>
<ul>
<li>scaling up：增加单个节点的处理能力</li>
<li>scaling out：增加节点数量</li>
</ul>
<p>弹性系统：能够自动调整资源以适应负载变化</p>
<p><strong>可维护性 maintainability</strong>：系统应该容易理解、容易修改、容易操作</p>
<p>关注三个设计原则：</p>
<ul>
<li>可操作性 operability：运维容易</li>
<li>简单性 simplicity：理解起来容易，抽象</li>
<li>演化性 evolvability：修改起来容易，敏捷</li>
</ul>
<h3 id="数据模型和查询语言">数据模型和查询语言</h3>
<p>数据模型至关重要，因为其不仅影响着软件如何编写，还影响着我们对问题的看法</p>
<p>应用可以视为一层一层的数据模型，每一层都是前一层的抽象</p>
<p>绝大多数应用都以面向对象编程语言开发，这和 SQL 数据模型存在着较大的不匹配。因此，<strong>对象关系映射 Object-Relation Match ORM</strong> 出现了，但并不能隐藏两个模型之间的差异</p>
<p>因为某项数据是需要的，所以才会出现在数据库中，故数据之间一定会存在着大量的互联。即使不在数据库中连接，也会在应用程序中执行连接</p>
<p>曾经有过和使用 JSON 模型的 <strong>文档数据库</strong> 类似的层次数据库，擅长处理一对多关系，但由于难以处理多对多关系，故最终失败了</p>
<p>文档数据库和关系型数据库在处理多对一和多对多的关系时方案类似</p>
<ul>
<li>文档数据模型的优势在于 schema 灵活，局部性带来的性能，以及和某些应用程序的数据结构更接近</li>
<li>关系模型的优势在于 join 的强大支持</li>
</ul>
<p>因此，如果数据有类似文档的结构，那么文档数据库是一个不错的选择；但对于高度相连的数据，文档模型就不太适合了</p>
<p>文档数据库被称为 <strong>无模式 schemaless</strong>，但实际上是 <strong>读时模式 schema-on-read</strong>，即数据库并不强制执行某个 schema，但读取时应用程序需要知道数据的结构</p>
<p>在变更模式时，读时模式只需要变更应用程序代码，效率高</p>
<p>查询的数据局部性：</p>
<ul>
<li>如果经常需要访问整个文档，那么存储局部性会带来性能提升</li>
<li>在写时，通常会更新整个文档，因此文档不宜过大</li>
</ul>
<p>事实上，文档数据库和关系型数据库也在逐渐融合，例如 PostgreSQL 的 JSONB 类型，一些文档数据库也支持 join</p>
<p><strong>图数据模型</strong> 更适合处理多对多关系</p>
<p>属性图：</p>
<ul>
<li>顶点 vertex：实体
<ul>
<li>顶点标识符</li>
<li>出边</li>
<li>入边</li>
<li>属性</li>
</ul>
</li>
<li>边 edge：实体之间的关系
<ul>
<li>边标识符</li>
<li>尾部顶点</li>
<li>头部顶点</li>
<li>描述两个顶点关系的标签</li>
<li>属性</li>
</ul>
</li>
</ul>
<p>这个模型的重要方面：</p>
<ul>
<li>任何顶点都可以连接到任何其他顶点</li>
<li>对于任何顶点都能高效地找到其相邻顶点，从而遍历图</li>
<li>通过对不同类型的关系使用不同的标签，可以在一个图中存储几种不同的信息</li>
</ul>
<p><strong>Cypher</strong> 是属性图的声明式查询语言，为 <strong>Neo4j</strong> 图形数据库而发明</p>
<p>另一个模型是 <strong>三元组存储 triple-store</strong>，每个三元组是一个主语、谓语和宾语的三元组</p>
<p><strong>资源描述框架 RDF</strong> 是三元组的标准化格式，<strong>SPARQL</strong> 是 RDF 的查询语言</p>
<h3 id="存储与检索">存储与检索</h3>
<p>索引：</p>
<ul>
<li><strong>哈希索引</strong>：适合等值查询，但不适合范围查询</li>
<li><strong>B+ 树</strong>：适合范围查询，且支持排序</li>
</ul>
<p>对于 <strong>日志结构存储 log-structured storage</strong>，写入时会先写入日志，然后再写入索引。这样可以减少写入时的随机写入，提高性能</p>
<ul>
<li><strong>SSTable (Sorted String Table)</strong>：将数据分块，每块称为一个 <strong>SSTable</strong>，每个块都是有序的</li>
<li><strong>LSM 树</strong>：将多个 SSTable 组织成一个树，每个 SSTable 称为一个层，每个层的 SSTable 有一个索引，索引中存储了块的最小键和最大键</li>
<li><strong>Bloom Filter</strong>：用于判断某个键是否存在于 SSTable 中，但可能会误判</li>
<li><strong>Compaction</strong>：将多个 SSTable 合并成一个 SSTable，以减少 SSTable 数量</li>
</ul>
<p><strong>页式存储 page storage</strong>：将数据分块，每块称为一个页，每个页有一个地址，地址中存储了块的最小键和最大键</p>
<p><strong>WAL (Write-Ahead Log)</strong>：在写入数据之前，先写入日志，以防止数据丢失</p>
<p>并发访问：</p>
<ul>
<li>使用 <strong>latch</strong> 保护 B+树的数据结构</li>
<li>LSM 则在后台进行合并，然后通过 <strong>原子交换</strong> 换入新的分段</li>
</ul>
<p>LSM 树的写入速度更快，而 B 树的读取速度更快</p>
<p>LSM 树：</p>
<ul>
<li>优点：
<ul>
<li>更高的写入吞吐量（较低的写放大和顺序写入）</li>
<li>较低的存储开销</li>
</ul>
</li>
<li>缺点：
<ul>
<li>压缩过程会导致性能下降</li>
<li>磁盘的写入带宽需要在写入和压缩线程之间共享</li>
<li>压缩速度需要跟上写入速度</li>
<li>一个键可能会出现在不同的段中</li>
</ul>
</li>
</ul>
<p>二级索引通常对于 join 的性能提升有很大帮助</p>
<p>内存数据库的性能优势在于省去了将内存数据结构转换为磁盘数据结构的开销，而不是不需要从磁盘读取数据</p>
<p>此外还提供了难以用基于磁盘的索引实现的数据模型</p>
<p>事务处理：OLTP</p>
<p>事务分析：OLAP</p>
<p>由于 OLTP 系统对业务运作很重要，因而通常会要求高可用与低延迟，不会做影响事务性能的分析查询。因此会有一个专门的数据仓库来处理分析查询</p>
<p>从 OLTP 数据库中提取数据（使用定期的数据转储或连续的更新流），转换成适合分析的模式，清理并加载到数据仓库中，也就是 <strong>抽取-转换-加载 ETL (Extract-Transform-Load)</strong></p>
<p><strong>星型模式</strong>：一个中心的 <strong>事实表</strong>，周围是维度表，事实表的每一行代表在特定时间发生的事件，所以可能会非常大</p>
<p><strong>雪花模式</strong>：维度表也可以进一步分解，以节省空间</p>
<p><strong>聚合：数据立方体和物化视图</strong>：可以预先计算聚合的立方体，以提高查询性能</p>
<h3 id="编码和演化">编码和演化</h3>
<p>应用程序总是会改变，因此存储的数据模式也会改变</p>
<p>新旧版本的代码和数据可能会共处一段时间，因此需要有：</p>
<ul>
<li><strong>向前兼容性 forward compatibility</strong>：旧版本的代码能够读取新版本的数据</li>
<li><strong>向后兼容性 backward compatibility</strong>：新版本的代码能够读取旧版本的数据</li>
</ul>
<p>由于是新代码的作者，同时知道旧数据的格式，因此向后兼容性更容易实现</p>
<p>这里设计两种形态的数据：</p>
<ul>
<li>内存中的数据，通常会用到指针等针对 CPU 高效访问的优化</li>
<li>文件或网络中的数据，是自包含的字节序列，无指针</li>
</ul>
<p>两种表示之间需要一种翻译：</p>
<ul>
<li><strong>序列化 serialization</strong>：从内存中表示到字节序列的转换</li>
<li><strong>反序列化 deserialization</strong>：从字节序列到内存中表示的转换</li>
</ul>
<p>许多编程语言都内置了序列化库，但是通常只适合临时使用：</p>
<ul>
<li>为了恢复相同对象类型的数据，解码过程需要实例化任意类的能力，导致一系列安全问题</li>
<li>数据版本控制不方便</li>
<li>效率也不高</li>
</ul>
<p><strong>Thrift</strong> 和 <strong>Protocol Buffers</strong> 都是不错的编码库，都需要定义一个模式：</p>
<p>thrift:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-number">1</span>: required <span class="hljs-built_in">string</span>       userName,<br>    <span class="hljs-number">2</span>: optional i64          favoriteNumber,<br>    <span class="hljs-number">3</span>: optional <span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">string</span>&gt; interests<br>&#125;<br></code></pre></td></tr></table></figure>
<p>protobuf:</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">required</span> <span class="hljs-type">string</span> user_name       = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">optional</span> <span class="hljs-type">int64</span>  favorite_number = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">repeated</span> <span class="hljs-type">string</span> interests       = <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>模式演变：</p>
<ul>
<li>向前兼容：可以添加新字段，只要有一个新的标记号码</li>
<li>向后兼容：后来添加的每个字段必须是可选的或具有默认值</li>
<li>删除字段：只能删除可选字段；不能再次使用相同的标签号码</li>
</ul>
<p><strong>Avro</strong> 是另一种二进制编码格式，它的其中一种模式是 JSON 格式，更容易阅读</p>
<p>核心思想是 Reader 和 Writer 模式不一定相同，只需要兼容</p>
<p>Reader 得知 Writer 模式的方法取决于应用场景，通常有：</p>
<ul>
<li>如果有很多记录的大文件，可以在文件的开头只包含一次 Writer 模式</li>
<li>支持独立写入记录的数据库，保留一个模式版本列表</li>
<li>在连接设置上协商模式版本，然后在连接的生命周期中使用该模式</li>
</ul>
<p>Avro 的一个优点是架构不包含任何标签号码，不需要手动写字段标签即可实现自动兼容</p>
<p>数据流的方式：</p>
<ul>
<li>数据库</li>
<li>服务调用</li>
<li>异步消息传递</li>
</ul>
<p><strong>数据库</strong>：</p>
<ul>
<li>在不同的时间写入不同的值：整个数据库看起来像是单个模式编码，但底层存储可能包含各种历史版本编码的记录</li>
<li>归档储存：数据库的快照，是一次写入的，通常使用最新的编码格式</li>
</ul>
<p><strong>服务</strong> 中的：</p>
<ul>
<li>微服务：将一个大型服务拆分成多个小型服务，每个服务都能从其他服务处请求功能或数据
<ul>
<li>每个服务都能独立部署和演化，并期望服务的新旧版本同时运行</li>
</ul>
</li>
<li>Web 服务：REST、SOAP、GraphQL
<ul>
<li>REST：资源、标识符、表述性状态转移，最常见</li>
<li>SOAP：简单对象访问协议，基于 XML，只有一些大型企业仍在使用</li>
<li>GraphQL：查询语言</li>
</ul>
</li>
</ul>
<p><strong>RPC</strong>：向远程网络服务发出请求，看起来与在同一进程中调用编程语言中的函数或方法相同（位置透明）</p>
<p>缺陷：</p>
<ul>
<li>网络请求不可预知</li>
<li>由于超时，可能会不返回结果</li>
<li>重试将导致重复请求（除非幂等）</li>
<li>网络请求慢得多</li>
<li>对于较大的对象，速度慢</li>
</ul>
<p>演化：</p>
<ul>
<li>所有的服务器都会先更新，其次是所有的客户端，那么只需要对请求有向后兼容性，对响应具有前向兼容性</li>
<li>对于 RESTful API，常用方法是在 URL 或者 HTTP Accept 头部使用版本号</li>
</ul>
<p><strong>消息传递</strong>：使用 <strong>消息队列（消息代理）</strong> 的优点：</p>
<ul>
<li>如果接收者不可用或过载，可以充当缓冲区，从而提高系统的可靠性</li>
<li>可以自动将消息重新发送到已经崩溃的进程，从而防止消息丢失</li>
<li>避免发送者需要知道接收者的 IP 地址和端口号</li>
<li>允许将一条消息发送给多个接收者</li>
</ul>
<p>与 RPC 的区别：</p>
<ul>
<li>消息传递通常是单向的</li>
<li>通信模式是异步的</li>
</ul>
<p><strong>Actor 模型</strong>：</p>
<ul>
<li>单进程中的并发模型</li>
<li>逻辑被封装在 actor 中，每个 actor 代表一个实体，有一些本地状态</li>
<li>不保证消息传送，每个 actor 可以由框架独立调度</li>
</ul>
<p><strong>分布式 actor 框架</strong>：</p>
<ul>
<li>跨多个节点伸缩应用程序</li>
<li>位置透明比 RPC 更好，因为 actor 模型已经假定消息可能会丢失</li>
<li>实质上是将消息代理和 actor 编程模型集成到一个框架中</li>
</ul>
<h2 id="分布式数据">分布式数据</h2>
<h3 id="复制">复制</h3>
<p>复制的目的：</p>
<ul>
<li>数据和用户物理位置接近，减少延迟</li>
<li>系统一部分出现故障后仍正常工作，提高可用性</li>
<li>扩展可以接受读的机器的数量，提高读取的吞吐量</li>
</ul>
<p>复制的难点在于复制变更，有三种方法：</p>
<ul>
<li>单领导者</li>
<li>多领导者</li>
<li>无领导者</li>
</ul>
<p><strong>主从复制</strong>：</p>
<ul>
<li>一个节点是主节点，其他节点是从节点</li>
<li>从节点复制主节点的数据</li>
<li>从节点可以处理读请求，但写请求必须发送到主节点</li>
</ul>
<p>主库和从库的关系：</p>
<ul>
<li>同步：主库等待从库确认写入成功，如果从库故障，主库也会阻塞</li>
<li>异步：主库写入后立即返回，从库异步复制，基于领导者的复制通常为完全异步</li>
<li>半同步：主库等待至少一个从库确认写入成功</li>
</ul>
<p>设置新从库：</p>
<ul>
<li>从主库获取快照</li>
<li>将快照复制到从库</li>
<li>从主库获取快照之后的所有变更</li>
</ul>
<p>节点失效：</p>
<ul>
<li>从库失效：追赶恢复</li>
<li>主库失效：选举新主库</li>
</ul>
<p>复制日志的实现：</p>
<ul>
<li>基于语句的复制
<ul>
<li>有的语句有副作用</li>
</ul>
</li>
<li>WAL
<ul>
<li>复制与存储引擎紧密耦合</li>
</ul>
</li>
<li>逻辑日志复制（基于行）
<ul>
<li>逻辑日志与存储引擎分离</li>
</ul>
</li>
<li>基于触发器的复制：
<ul>
<li>开销大，但更灵活</li>
</ul>
</li>
</ul>
<p>复制延迟：</p>
<ul>
<li>主从异步同步会有延迟，导致同时对主库和从库的查询结果可能不同</li>
<li>因为从库会赶上主库，所以被称为 <strong>最终一致性 eventual consistency</strong></li>
</ul>
<p>常见的因延迟而产生的问题：</p>
<ul>
<li>
<p><strong>读你自己写 read your own writes</strong>：写入后立即读取，但读取到的是旧数据，感觉数据丢失</p>
<ul>
<li>对于可能出现这种问题的情况，从主库读</li>
<li>强制更新后的时间窗口中从主库读</li>
<li>从库查询时，保证该时间戳前的变更都已经传播到了本从库</li>
<li>多个数据中心则比较复杂</li>
</ul>
</li>
<li>
<p><strong>单调读 monotonic read</strong>：第二次读的库更落后，导致出现了时光倒流</p>
<ul>
<li>每个用户总是从同一副本来读取</li>
</ul>
</li>
<li>
<p><strong>一致前缀读 consistent prefix read</strong>：一系列事件可能出现前后顺序不一致</p>
<ul>
<li>主要是由于不同分区的写入顺序不一致，于是因果相关的写入要写入相同分区</li>
</ul>
</li>
</ul>
<p><strong>多主复制</strong>：一般用在多个数据中心，每个数据中心都有一个主库</p>
<ul>
<li>每个写操作都可以在本地数据中心进行处理，与其他数据中心异步复制，性能更好</li>
<li>每个数据中心都可以独立于其他数据中心继续运行，若发生故障的数据中心归队，复制会自动赶上</li>
</ul>
<p>缺点：写冲突</p>
<p>另一适用场景：需要离线操作的客户端，其中每个客户端都相当于一个临时的数据中心</p>
<p>处理写入冲突：</p>
<ul>
<li>读时执行 vs 写时执行冲突解决</li>
<li>自动冲突解决</li>
</ul>
<p>复制拓扑结构：最普遍的是全部到全部的通信路径</p>
<ul>
<li>防止无限复制循环：复制日志中记录了经过的节点</li>
<li>问题在于可能导致消息顺序混乱，解决办法是 <strong>版本向量技术</strong>，即每个节点都有一个版本向量，记录了每个节点的最新版本号</li>
</ul>
<p><strong>无主复制</strong>：客户端直接写入到几个副本中</p>
<p>读写的法定人数：</p>
<ul>
<li><strong>N、R、W</strong>：N 为副本数，R 为读取副本数，W 为写入副本数</li>
<li><strong>R + W &gt; N</strong>：保证一定有一个副本包含最新数据</li>
<li>不是绝对的保证，而是概率性的保证</li>
</ul>
<p>由于没有固定的写入顺序，因此监控陈旧度困难，最终一致性难以保证</p>
<p>宽松的法定人数与提示移交：有利于高可用、低延时、且能够容忍偶尔读到陈旧值的应用场景</p>
<ul>
<li><strong>宽松的法定人数 sloppy quorum</strong>：如果出现了严重的网络中断，为了保证仍然使用，可以接受写入到一些可达的节点，但不在应该在的 n 个节点上。写和读仍然需要 w 和 r 个成功的响应，但是可以不来自指定的 n 个节点中</li>
<li><strong>提示移交 hinted handoff</strong>：当网络修复好后，将写入的数据移交给正确的节点</li>
</ul>
<p>检测并发写入：</p>
<ul>
<li><strong>最后写入胜出 last write wins</strong>：时间戳较大的胜出
<ul>
<li>以持久性为代价实现最终一致性，即尽管可能报告成功，但最终只有一个数据存活</li>
</ul>
</li>
<li>此前发生的关系：服务器可以通过查看版本号来确定两个操作是否是并发的</li>
</ul>
<p>合并同时写入的值：优点是没有数据被无声地丢弃，但客户端必须合并并发写入的值，有额外工作</p>
<h3 id="分区">分区</h3>
<p>如果分区不公平，被称为 <strong>偏斜 skew</strong>，不均衡导致的高负载的分区被称为 <strong>热点 hot spot</strong></p>
<p>键值对的数据分区：</p>
<ul>
<li>键的范围</li>
<li>键的哈希</li>
<li>负载偏斜与热点消除：大量的读写操作都是针对同一个键的，因此所有请求会被路由到同一个分区
<ul>
<li>可以在主键中添加一个随机数实现分区</li>
</ul>
</li>
</ul>
<p>次级索引：不能整齐地映射到分区</p>
<ul>
<li><strong>基于文档 document-based</strong>：每个分区维护自己的二级索引，即 <strong>本地索引</strong>
<ul>
<li>查询被称为 <strong>分散/聚集 scatter/gather</strong>，代价高</li>
<li>广泛使用</li>
</ul>
</li>
<li><strong>基于关键词 term-based</strong>：建一个覆盖所有分区数据的 <strong>全局索引</strong>，该索引当然也需要分区
<ul>
<li>读取速度快，只需要向包含关键词的分区发出请求</li>
<li>但写入较为复杂，对全局二级索引的更新通常是异步的</li>
</ul>
</li>
</ul>
<p>分区再平衡：</p>
<ul>
<li>固定数量的分区：创建比节点数量多的分区，为每个节点分配多个分区</li>
<li>动态分区：按键的范围进行分区的数据库会动态创建分区
<ul>
<li>当分区增长到超过配置的大小时，会被分成两个分区</li>
<li>如果分区缩小到某个阈值以下，则可以将其与相邻分区合并</li>
</ul>
</li>
<li>按节点比例分区：每个节点有固定数量的分区，需要一致性哈希</li>
</ul>
<p>请求路由：</p>
<ul>
<li>允许客户联系任何节点，如果该节点拥有请求的分区，则直接处理该请求；否则，转发请求到适当的节点，接收回复并传递给客户端</li>
<li>将所有请求发送到路由层决定应该处理请求的节点，并相应地转发</li>
<li>客户端若知道分区和节点的分配，可以直接连接到适当的节点，而不需要中介</li>
</ul>
<p>难题：达成分区-节点之间的分配关系的共识</p>
<p>常见方案是使用 Zookeeper</p>
<h3 id="事务">事务</h3>
<p><strong>原子性</strong>，<strong>隔离性</strong> 和 <strong>持久性</strong> 是数据库的属性，而 <strong>一致性</strong> 是应用程序的 <strong>不变量</strong> 属性。应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库</p>
<p>最基本的事务隔离级别是 <strong>读已提交 Read Committed</strong>，它提供了两个保证：</p>
<ul>
<li>从数据库读时，只能看到已提交的数据（<strong>没有脏读 dirty reads</strong>）</li>
<li>写入数据库时，只会覆盖已经写入的数据（<strong>没有脏写 dirty writes</strong>）</li>
</ul>
<p>实现：</p>
<ul>
<li>使用 <strong>行锁 row-level lock</strong> 来防止脏写</li>
<li>对于写入的每个对象，数据库都会记住旧的已提交值，和由当前持有写入锁的事务设置的新值</li>
<li>当事务正在进行时，任何其他读取对象的事务都会拿到旧值。</li>
<li>只有当新值提交后，事务才会切换到读取新值</li>
</ul>
<p>这种级别存在的问题是 <strong>不可重复读 nonrepeatable read</strong> 或 <strong>读取偏差 read skew</strong>，即两次读的时候可能出现暂时的不一致</p>
<ul>
<li>备份可能会导致暂时的不一致成为永久的不一致</li>
<li>分析查询和完整性检查也会因这种不一致而出现问题</li>
</ul>
<p><strong>快照隔离 snapshot isolation</strong>：每个事务都从数据库的一致快照中读取，即事务可以看到事务开始时在数据库中提交的所有数据，即使这些数据随后被另一个事务更改，每个事务也只能看到该特定时间点的旧数据</p>
<p>实现：数据库必须可能保留一个对象的几个不同的提交版本，因为各种正在进行的事务可能需要看到数据库在不同的时间点的状态，这种技术被称为 <strong>多版本并发控制 MVCC, multi-version concurrency control</strong></p>
<p>上面两个隔离级别主要保证了只读事务在并发写入时可以看到什么，另外一个重要的事务并发场景是脏写，因此并发事务还有 <strong>丢失更新 lost update</strong> 问题</p>
<ul>
<li>一种方法是使用数据库提供的 <strong>原子更新操作</strong>，如 <code>UPDATE ... SET balance = balance + 100</code></li>
<li>另一种是 <strong>显式锁定</strong>，如使用 <code>SELECT ... FOR UPDATE</code></li>
</ul>
<p>在复制数据库中，冲突解决方法是允许并发写入创建多个冲突版本的值，并使用应用代码或特殊数据结构在事实发生之后解决和合并这些版本</p>
<ul>
<li>但是最后写入胜利 LWW 的冲突解决方法很容易丢失更新</li>
</ul>
<p><strong>写倾斜 write skew</strong>：两个事务读取相同的对象，然后更新其中一些对象（不同的事务可能更新不同的对象）</p>
<p>这种问题遵循着类似的模式：</p>
<ul>
<li>一个 SELECT 查询找出符合条件的行，并检查是否符合一些要求</li>
<li>按照第一个查询的结果，应用代码决定是否继续</li>
<li>如果应用决定继续操作，就执行写入并提交事务
<ul>
<li>这个写入的效果改变了的先决条件，即如果在提交写入后，重复执行一次 SELECT 查询，将会得到不同的结果</li>
</ul>
</li>
</ul>
<p><strong>幻读 phantom</strong>：一个事务中的写入改变另一个事务的搜索查询结果</p>
<p><strong>可串行化 Serializable</strong>：保证即使事务可以并行执行，最终的结果也是一样的，如同没有任何并发性，挨个执行</p>
<ul>
<li><strong>2PL</strong></li>
<li><strong>可串行化快照隔离 SSI serializable snapshot isolation</strong></li>
</ul>
<h3 id="分布式系统的挑战">分布式系统的挑战</h3>
<p>分布式系统相比单机来说最大的特点在于 <strong>部分失效 partial failure</strong>，即系统的某些部分可能会以某种不可预知的方式被破坏，而其他部分工作正常</p>
<ul>
<li>超级计算机处理故障：作业会不时地保存，如果发送故障，则重新加载继续计算</li>
<li>互联网服务处理故障：必须能够在不中断服务的情况下处理故障</li>
</ul>
<p><strong>不可靠的网络</strong>：存在丢失、排队、失效等许许多多的问题</p>
<p>处理方法：超时</p>
<ul>
<li>但是无法确定远程节点是否收到了请求</li>
<li>超时时间没有正确的值，需要通过实验来确定</li>
</ul>
<p><strong>不可靠的时钟</strong>：</p>
<ul>
<li>通信不是实时的，存在不稳定的网络延迟，因此无法得知事件发生的顺序</li>
<li>每个机器自己的时钟——石英晶体振荡器——会因为温度、电压等因素而产生 <strong>漂移 drift</strong>，因此无法保证时钟的准确性，需要通过 <strong>NTP</strong> 等协议来同步</li>
</ul>
<p>计算机中存在两种时钟：</p>
<ul>
<li><strong>日历时钟 time-of-day clock</strong>：用于记录时间戳，需要同步</li>
<li><strong>单调时钟 monotonic clock</strong>：用于测量时间间隔，不需要同步</li>
</ul>
<p><strong>知识、真相与谎言</strong>：</p>
<ul>
<li>真相由多数人定义
<ul>
<li>确保一个误认为自己是唯一的节点，不能扰乱系统的其它部分，的技术叫 <strong>防护 fencing</strong>，服务器会返回一个 <strong>防护令牌 fencing token</strong>，需要在服务端进行检查令牌</li>
</ul>
</li>
<li>当一个系统在部分节点发生故障、不遵守协议、甚至恶意攻击、扰乱网络时仍然能继续正确工作，称之为 <strong>拜占庭容错 Byzantine fault-tolerant</strong>
<ul>
<li>一般不需要考虑，因为 Web 系统是中心化的，服务器决定客户端的行为</li>
<li>拜占庭容错对于安全性也没有什么提高，如果攻击者可以渗透进一个节点，那么可能会渗透所有的节点，因为运行着相同的软件</li>
</ul>
</li>
</ul>
<p>将可能发生的错误形式化建立 <strong>模型</strong>：</p>
<p>时序假设：</p>
<ul>
<li>同步模型：假设网络延迟、进程暂停和和时钟误差都是受限的</li>
<li>部分同步：一个系统在大多数情况下像一个同步系统一样运行，但有时候会超出界限</li>
<li>异步模型：不对时序做任何假设，甚至没有时钟</li>
</ul>
<p>节点失效：</p>
<ul>
<li><strong>崩溃-停止 crash-stop</strong>：算法假设一个节点只能以一种方式失效，即通过崩溃</li>
<li><strong>崩溃-恢复 crash-recovery</strong>：可能会在任何时候崩溃，但也许会在未知的时间之后再次开始响应</li>
<li>拜占庭故障：节点可能会做任何事</li>
</ul>
<p>最常用的模型：具有崩溃-恢复故障的部分同步模型</p>
<p>算法的属性：</p>
<ul>
<li><strong>唯一性 uniqueness</strong>：没有两个防护令牌请求返回相同的值</li>
<li><strong>单调序列 monotonic sequence</strong>：如果请求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 返回了令牌 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">t_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，并且请求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 返回了令牌 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">t_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，并且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 开始之前已经完成，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>x</mi></msub><mo>&lt;</mo><msub><mi>t</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">t_x &lt;t_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></li>
<li><strong>可用性 availability</strong>：请求防护令牌并且不会崩溃的节点，最终会收到响应</li>
</ul>
<p>安全性和活性：</p>
<ul>
<li><strong>安全 safety</strong> 属性：没有坏事发生</li>
<li><strong>活性 liveness</strong> 属性：最终好事发生</li>
<li>唯一性和单调序列是安全属性，而可用性是活性属性</li>
</ul>
<p>精确定义：</p>
<ul>
<li>如果安全属性被违反，则可以指向一个特定的安全属性被破坏的时间点</li>
<li>对于活性，在某个时间点可能不成立，但总是希望在未来能成立</li>
</ul>
<p>区分原因：</p>
<ul>
<li>在模型的所有可能情况下，通常要求始终保持安全属性</li>
<li>只有在大多数节点没有崩溃的情况下才要求活性</li>
</ul>
<h3 id="一致性和共识">一致性和共识</h3>
<p><strong>线性一致性 Linearizability</strong> 是读取和写入寄存器（单个对象）的 <strong>新鲜度保证</strong></p>
<ul>
<li>只要一个客户端成功完成写操作，所有客户端从数据库中读取数据必须能够看到刚刚写入的值</li>
<li>系统应保障读到的值是最近的、最新的，而不是来自陈旧的缓存或副本</li>
</ul>
<p>而 <strong>可串行化 Serializability</strong> 是事务的隔离属性，每个事务可以读写多个对象，确保事务的行为与它们按照某种顺序依次执行的结果相同</p>
<p>由于可变的网络延迟，可能存在竞争条件，故严格的法定人数读写不是线性一致的</p>
<p><strong>CAP 定理</strong>：在分区时要么选择一致，要么选择可用</p>
<ul>
<li>只考虑了一个一致性模型（即线性一致性）和一种故障（网络分区），而没有讨论任何关于网络延迟，死亡节点或其他权衡的事</li>
<li>因此对于设计系统而言并没有实际价值，成了历史古迹</li>
</ul>
<p>线性一致性系统很少，例如现代多核 CPU 上的内存不是线性一致的，和绝大多数分布式系统一样，为了提高性能而不是容错，才选择了牺牲线性一致性</p>
<p><strong>因果关系</strong> 对事件施加了一种 <strong>顺序</strong>：因在果之前，消息发送在消息收取之前。这些因果依赖的操作链定义了系统中的因果顺序，即什么在什么之前发生。</p>
<ul>
<li>如果一个系统服从因果关系所规定的顺序，我们说它是 <strong>因果一致 causally consistent</strong> 的。</li>
</ul>
<p>因果关系不是 <strong>全序</strong> 的，因为一些操作是无法比较的（并发）</p>
<p>线性一致性隐含因果关系：任何线性一致的系统都能正确保持因果性，因此线性一致性强于因果一致性</p>
<ul>
<li>绝大多数情况下只需要因果一致性，这样性能更高</li>
</ul>
<p>一个非常简单的因果一致的序列号产生方法：<strong>兰伯特时间戳</strong></p>
<ul>
<li>每个节点都有一个递增的计数器，每次生成一个新的时间戳时，都会将计数器递增</li>
<li>当一个节点发送一个消息时，它会将自己的时间戳附加到消息中</li>
<li>当一个节点接收到一个消息时，它会将自己的时间戳与消息中的时间戳进行比较，然后选择较大的时间戳（每个因果依赖都会导致时间戳增长，确保兰伯特时间戳的排序与因果一致）</li>
<li>兰伯特时间戳：（计数器，节点 ID）</li>
</ul>
<p>只有在所有的操作都被收集之后，操作的全序才会出现，但有时节点需要马上决定这个请求是成功还是失败，因此这个方法不能满足要求</p>
<p><strong>全序广播 total order broadcast</strong> 或 <strong>原子广播 atomic broadcast</strong>：</p>
<ul>
<li>可靠交付：没有消息丢失，如果消息被传递到一个节点，它将被传递到所有节点</li>
<li>全序交付：消息以相同的顺序传递给每个节点</li>
</ul>
<p><strong>状态机复制 state machine replication</strong>：如果每个消息都代表一次数据库的写入，且每个副本都按相同的顺序处理相同的写入，那么副本间将相互保持一致</p>
<p>全序广播是异步的：消息被保证以固定的顺序可靠地传送，但是不能保证消息何时被送达</p>
<p>可以证明：<strong>线性一致的 CAS（或自增并返回）寄存器与全序广播都都等价于共识问题</strong></p>
<p><strong>FLP</strong> 告诉我们，共识是做不到的，但前提是在一个相当严格的异步模型中，但在实践中，能够使用包括超时等方法来解决共识问题</p>
<p>对于单节点，原子提交比较简单，因为事务的提交主要取决于数据持久化落盘的顺序：首先是数据，然后是提交记录。事务提交或终止的关键决定时刻是磁盘完成写入提交记录的时刻，故是 <strong>单一的设备</strong> 使得提交具有原子性。而当涉及多节点时，就不容易了</p>
<p>二阶段提交保证原子性的两个承诺：</p>
<ul>
<li>当参与者投票“是”时，它承诺稍后肯定能够提交（协调者可以放弃）</li>
<li>一旦协调者做出决定，这一决定是不可撤销的</li>
</ul>
<p>当协调者失效时，参与者只能等待协调者恢复，这种事务状态称为 <strong>存疑 in doubt</strong></p>
<ul>
<li>因此，2PC 的提交点归结为协调者上的常规单节点原子提交</li>
</ul>
<p>异构的分布式事务能够通过原子提交实现恰好一次的消息处理</p>
<p>共识算法必须满足：</p>
<ul>
<li>一致同意：没有两个节点的决定不同</li>
<li>完整性：没有节点决定两次</li>
<li>有效性：如果一个节点决定了值 v ，则 v 由某个节点所提议</li>
<li>终止：由所有未崩溃的节点来最终决定值，是一个活性属性</li>
</ul>
<p>全序广播相当于重复进行多轮共识，Raft 和 Zab 实现了全序广播</p>
<p><strong>成员资格服务 membership services</strong>：确定哪些节点当前处于活动状态并且是集群的活动成员</p>
<p>一些等价的问题：</p>
<ul>
<li>线性一致性的 CAS 寄存器：寄存器需要基于当前值是否等于操作给出的参数，原子地决定是否设置新值</li>
<li>原子事务提交：数据库必须决定是否提交或中止分布式事务</li>
<li>全序广播：消息系统必须决定传递消息的顺序</li>
<li>锁和租约：当几个客户端争抢锁或租约时，由锁来决定哪个客户端成功获得锁</li>
<li>成员/协调服务：给定某种故障检测器（例如超时），系统必须决定哪些节点活着，哪些节点因为会话超时需要被宣告死亡</li>
<li>唯一性约束：当多个事务同时尝试使用相同的键创建冲突记录时，约束必须决定哪一个被允许，哪些因为违反约束而失败</li>
</ul>
<h2 id="派生数据">派生数据</h2>
<p>存储和处理数据的系统分成两类：</p>
<ul>
<li>记录系统：真相之源，保持数据的权威版本</li>
<li>派生数据系统：从记录系统中提取数据，并以某种方式处理，如果丢失，没有太大的影响。例如缓存。是冗余的，为了高效读取，通常是非规范化的，便于从不同视角看数据</li>
</ul>
<p>数据库只是一个工具，这两类系统的差异来源于如何在应用中使用</p>
<h3 id="批处理">批处理</h3>
<p>之前讨论的都是在线系统，实际上有三类系统：</p>
<ul>
<li>服务（在线系统）：处理客户的请求或指令。衡量指标：响应时间，可用性</li>
<li>批处理系统（离线系统）：跑一个作业，处理大量的输入数据，定时运行。衡量指标：吞吐量</li>
<li>流处理系统（准实时系统）：介于在线系统和离线系统之间。消费输入并产生输出（不需要响应请求），在事件发生不久就对事件进行操作</li>
</ul>
<p>UNIX 哲学：</p>
<ul>
<li>每个程序都应该只做一件事，并且做好</li>
<li>每个程序都应该能够与其他程序协作</li>
<li>期望程序的输出成为另一个程序的输入</li>
<li>优先使用文本流进行通信</li>
</ul>
<p>发展到今天，换了些花哨的名字，叫做自动化，快速原型设计，增量式迭代，对实验友好，将大型项目分解成可管理的块</p>
<p><strong>广播散列连接 broadcast hash join</strong>：每个 join 较大输入端分区的 Mapper 都会将较小输入端数据集整个读入内存中（所以较小输入实际上“广播”到较大数据的所有分区上）</p>
<p>使用原始格式保存数据的优点：通常要比事先决定理想数据模型要更有价值</p>
<ul>
<li>稍后再操心模式的设计，能使数据收集速度加快</li>
<li>转移了解释数据的负担，有利于跨团队合作</li>
<li><strong>寿司原则 sushi principle</strong>：“原始数据更好”</li>
</ul>
<p>MapReduce 非常急切地将数据写入磁盘，一方面是为了容错，另一部分是因为假设数据集太大而不能适应内存</p>
<p>MapReduce 由于要 <strong>物化 materialization</strong> 中间状态，所以性能不佳，于是数据流引擎诞生了</p>
<p><strong>数据流引擎</strong>：把整个工作流作为单个作业来处理，而不是把它分解为独立的子作业</p>
<ul>
<li>用户定义的函数不需要严格扮演交织的 Map 与 Reduce 的角色，而是可以以更灵活的方式进行组合，称为 <strong>算子 operators</strong></li>
</ul>
<p>当然，代价就是如果一台机器发生故障，就需要从其他仍然可用的数据重新计算，这里要求跟踪一个给定的数据是如何计算的</p>
<p><strong>Pregel</strong>：图处理系统，将图分解为小的分区，每个分区都是一个顶点，然后在每个分区上运行一个用户定义的函数，然后将结果传递给下一个分区。即一个顶点可以沿着图的边发送向另一个顶点“发送消息”，此外顶点每次迭代时都会记住上一次迭代的状态</p>
<p>并行算法：中间状态（节点之间发送的消息）往往比原始图大，因而网络发送消息的开销会显著拖慢分布式图算法的速度</p>
<p>现在批处理系统越来越像 MPP 了</p>
<h3 id="流处理">流处理</h3>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">分布式系统</a></div><div class="post_share"><div class="social-share" data-image="/gallery/cover/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/e90c0012.html" title="你的恶行从爱尔兰到契丹无人不知，无人不晓"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/%E5%8D%81%E5%AD%97%E5%86%9B%E4%B9%8B%E7%8E%8B.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">你的恶行从爱尔兰到契丹无人不知，无人不晓</div></div></a></div><div class="next-post pull-right"><a href="/posts/9db17c0a.html" title="“游戏人生”板块序言"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/%E2%80%9C%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F%E2%80%9D%E6%9D%BF%E5%9D%97%E5%BA%8F%E8%A8%80.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">“游戏人生”板块序言</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="iconfont icon-tuijian"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/17492bb9.html" title="CMU 15-445：数据库系统"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/CMU%2015-445%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-30</div><div class="title">CMU 15-445：数据库系统</div></div></a></div><div><a href="/posts/a541262a.html" title="Spring Boot"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/Spring%20Boot.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-17</div><div class="title">Spring Boot</div></div></a></div><div><a href="/posts/df05de46.html" title="MIT 6.824：分布式系统"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/cover/MIT%206.824%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-20</div><div class="title">MIT 6.824：分布式系统</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/illustration/%E5%A4%B4%E5%83%8F_%E7%81%B0%E5%A4%AA%E7%8B%BC.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Aefrivern</div><div class="author-info__description">我一定会回来的</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">166</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">224</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/aefrivern" rel="external nofollow noreferrer" target="_blank" title="GitHub"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-github"></use></svg></a><a class="social-icon faa-parent animated-hover" href="mailto:2771503468@qq.com" rel="external nofollow noreferrer" target="_blank" title="QQ邮箱"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://steamcommunity.com/id/old_driver_zero" rel="external nofollow noreferrer" target="_blank" title="Steam"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-steam"></use></svg></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><a class="faa-parent animated-hover"><svg class="faa-tada icon" style="height:25px;width:25px;fill:currentColor;position:relative;top:5px" aria-hidden="true"><use xlink:href="#icon-mulu"></use></svg></a><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">数据系统基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%80%A7%E3%80%81%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7%E3%80%81%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%E5%BA%94%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">可靠性、可扩展性、可维护性应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80"><span class="toc-number">1.2.</span> <span class="toc-text">数据模型和查询语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E4%B8%8E%E6%A3%80%E7%B4%A2"><span class="toc-number">1.3.</span> <span class="toc-text">存储与检索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%92%8C%E6%BC%94%E5%8C%96"><span class="toc-number">1.4.</span> <span class="toc-text">编码和演化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE"><span class="toc-number">2.</span> <span class="toc-text">分布式数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6"><span class="toc-number">2.1.</span> <span class="toc-text">复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA"><span class="toc-number">2.2.</span> <span class="toc-text">分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">2.3.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-number">2.4.</span> <span class="toc-text">分布式系统的挑战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E5%85%B1%E8%AF%86"><span class="toc-number">2.5.</span> <span class="toc-text">一致性和共识</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E6%95%B0%E6%8D%AE"><span class="toc-number">3.</span> <span class="toc-text">派生数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">批处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E5%A4%84%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">流处理</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>安得广厦千万间，大庇天下寒士俱欢颜，风雨不动安如山。</div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/comments/">留点什么</a><a href="/random/">随便逛逛</a></li><li><a href="/about/">关于</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/gallery/">我的画廊</a><a href="/charts/">网站统计</a></li></ul></div></div></div></div><div class="copyright">&copy;2022 - 2024 By Aefrivern</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://unpkg.com/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.js"></script><script src="https://unpkg.com/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://unpkg.com/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><script async src="//at.alicdn.com/t/c/font_4031045_1yiosqv4vch.js"></script><link rel="stylesheet" href="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://unpkg.com/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://unpkg.com/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://unpkg.com/algoliasearch@4.22.0/dist/algoliasearch-lite.umd.js"></script><script src="https://unpkg.com/instantsearch.js@4.63.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.12.0"></script></div></div></html>